<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toki Pona Maze</title>

  <style>
    :root {
      --topbar-h: 56px;
      --side-w: 200px;

      --bg: #F3DFC0;
      --ink: #111;
      --muted: #3f4750;
      --panel: rgba(255,255,255,0.35);
      --panel-border: rgba(17,17,17,0.18);
    }

    @font-face {
      font-family: "PatrickHand";
      src: url("./fonts/patrickhead-regular.ttf") format("truetype");
      font-display: swap;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src:
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.woff2") format("woff2"),
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.woff")  format("woff"),
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.otf")   format("opentype");
      font-display: swap;
    }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: "PatrickHand", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--ink);
    }

    .topbar {
      height: var(--topbar-h);
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      box-sizing: border-box;
      border-bottom: 1px solid var(--panel-border);
      background: var(--panel);
      backdrop-filter: blur(6px);
    }

    .btn {
      appearance: none;
      border: 1px solid var(--panel-border);
      background: rgba(255,255,255,0.5);
      padding: 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
      font-family: "PatrickHand", system-ui, sans-serif;
      font-size: 16px;
    }
    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .select {
      appearance: none;
      border: 1px solid var(--panel-border);
      background: rgba(255,255,255,0.5);
      padding: 8px 34px 8px 10px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      color: var(--ink);
      font-family: "PatrickHand", system-ui, sans-serif;
      font-size: 16px;
      line-height: 1;
      position: relative;
    }
    .select:disabled { opacity: 0.55; cursor: not-allowed; }
    .selectWrap { position: relative; display: inline-flex; align-items: center; }
    .selectWrap::after {
      content: "▾";
      position: absolute;
      right: 10px;
      pointer-events: none;
      color: rgba(0,0,0,0.6);
      font-size: 14px;
    }

    .checkWrap {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      border: 1px solid var(--panel-border);
      background: rgba(255,255,255,0.5);
      padding: 6px 10px;
      border-radius: 10px;
      user-select: none;
    }
    .checkWrap input[type="checkbox"] {
      width: 16px;
      height: 16px;
      margin: 0;
      accent-color: rgba(0,0,0,0.75);
      cursor: pointer;
    }
    .checkWrap input[type="checkbox"]:disabled { cursor: not-allowed; }
    .checkWrap .checkLabel {
      font-weight: 700;
      font-size: 16px;
      line-height: 1;
      cursor: pointer;
    }
    .checkWrap.disabled { opacity: 0.55; }

    .timerCanvas {
      margin-left: auto;
      height: 36px;
      width: 170px;
      display: block;
    }

    .status {
      margin-left: 12px;
      color: var(--muted);
      font-size: 16px;
      max-width: 46vw;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .wrap {
      height: calc(100% - var(--topbar-h));
      position: relative;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .gameArea {
      position: relative;
      flex: 1 1 auto;
      min-height: 0;
    }

    #c {
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.55);
      z-index: 10;
      font-family: "PatrickHand", system-ui, sans-serif;
    }
    .overlay.show { display: flex; }

    .modal {
      width: min(520px, 92vw);
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(0,0,0,0.18);
      border-radius: 16px;
      padding: 16px;
      box-shadow: 0 18px 60px rgba(0,0,0,0.35);
    }
    .modal h2 { margin: 0 0 8px 0; font-size: 22px; }
    .modal p { margin: 0 0 14px 0; color: var(--muted); line-height: 1.35; font-size: 16px; }
    .modal .row { display: flex; gap: 10px; justify-content: flex-end; }

    .mazeHidden #c { visibility: hidden; }

    .footer {
      flex: 0 0 auto;
      border-top: 1px solid var(--panel-border);
      background: rgba(255,255,255,0.25);
      padding: 10px 12px;
      box-sizing: border-box;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.35;
    }
    .footer a { color: var(--ink); text-decoration: underline; }
    .footerRow {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
    }
    .footerLeft { min-width: 240px; }
    .footerRight { white-space: nowrap; }

    /* ============================================================
       D-PAD (mobile only)
       ============================================================ */
    .dpad {
      position: absolute;
      z-index: 6;
      display: none;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    @media (pointer: coarse) {
      .dpad { display: grid; }
    }

    .dpad {
      grid-template-columns: 52px 52px 52px;
      grid-template-rows: 52px 52px 52px;
      gap: 8px;
      padding: 10px;
      border-radius: 18px;
      background: rgba(255,255,255,0.30);
      border: 1px solid rgba(0,0,0,0.12);
      backdrop-filter: blur(6px);
    }

    .dpadBtn {
      width: 52px;
      height: 52px;
      border-radius: 14px;
      border: 1px solid rgba(0,0,0,0.18);
      background: rgba(255,255,255,0.55);
      color: rgba(0,0,0,0.85);
      font-family: "PatrickHand", system-ui, sans-serif;
      font-weight: 900;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .dpadBtn:active,
    .dpadBtn.pressed {
      background: rgba(255,255,255,0.80);
      border-color: rgba(0,0,0,0.28);
    }

    .dpadBtn.empty {
      visibility: hidden;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <button id="btnNew" class="btn">Start New Game</button>
    <button id="btnQuit" class="btn" disabled>Quit Game</button>

    <div class="selectWrap" title="Maze size">
      <select id="mazeSize" class="select" aria-label="Maze size">
        <option value="small">Small</option>
        <option value="medium">Medium</option>
        <option value="large">Large</option>
      </select>
    </div>

    <label id="visitedWrap" class="checkWrap" title="Leave a small dot behind on each cell you leave">
      <input id="visitedDots" type="checkbox" />
      <span class="checkLabel">Visited dots</span>
    </label>

    <div id="status" class="status">Loading fonts…</div>
    <canvas id="timerCanvas" class="timerCanvas" aria-label="Timer"></canvas>
  </div>

  <div id="wrap" class="wrap">
    <div id="gameArea" class="gameArea">
      <canvas id="c"></canvas>

      <div id="dpad" class="dpad" aria-label="D-pad">
        <button class="dpadBtn empty" tabindex="-1" aria-hidden="true"></button>
        <button class="dpadBtn" data-dir="up" aria-label="Up">▲</button>
        <button class="dpadBtn empty" tabindex="-1" aria-hidden="true"></button>

        <button class="dpadBtn" data-dir="left" aria-label="Left">◀</button>
        <button class="dpadBtn empty" tabindex="-1" aria-hidden="true"></button>
        <button class="dpadBtn" data-dir="right" aria-label="Right">▶</button>

        <button class="dpadBtn empty" tabindex="-1" aria-hidden="true"></button>
        <button class="dpadBtn" data-dir="down" aria-label="Down">▼</button>
        <button class="dpadBtn empty" tabindex="-1" aria-hidden="true"></button>
      </div>

      <div id="overlay" class="overlay" role="dialog" aria-modal="true">
        <div class="modal">
          <h2>Quit current game?</h2>
          <p>The timer will stop. If you quit, your current progress will be lost.</p>
          <div class="row">
            <button id="btnCancelQuit" class="btn">Cancel</button>
            <button id="btnConfirmQuit" class="btn">Quit</button>
          </div>
        </div>
      </div>
    </div>

    <footer class="footer" aria-label="Disclaimer">
      <div class="footerRow">
        <div class="footerLeft">
          <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct, complete, or suitable for any purpose. You are responsible for verifying results.
        </div>
        <div class="footerRight">
          <a href="./index.html">Back to index</a>
        </div>
      </div>
    </footer>
  </div>

<script>
(() => {
  "use strict";

  const VISITED_DOT_RGBA = "rgba(0,0,0,0.24)";
  const DEAD_CELL_RGBA   = "rgba(0,0,0,0.18)";

  /* ============================================================
     DEVICE-AWARE SETTINGS
     ============================================================ */
  function isCoarsePointer() {
    try { return window.matchMedia && window.matchMedia("(pointer: coarse)").matches; }
    catch { return false; }
  }
  function isSmallViewport() {
    return Math.min(window.innerWidth || 9999, window.innerHeight || 9999) <= 820;
  }
  function isMobileLike() { return isCoarsePointer() || isSmallViewport(); }

  const MOBILE_TUNING = {
    forceMazeSize: "small",
    glyphSize: 12,
    wallThickness: 3,
    passageInset: 1,
    speed: 200,
    keyMoveSpeed: 140,

    // Smaller collision microstep (prevents skipping narrow openings).
    maxMoveStepPx: 1.4,

    // Reserve space so maze is never under the D-pad.
    reserveBottomPx: 190,
  };

  const MAZE_SIZE_PRESETS = {
    small:  { cols: 19, rows: 13, cellSize: 34, wallThickness: 6, glyphSize: 18 },
    medium: { cols: 27, rows: 19, cellSize: 28, wallThickness: 5, glyphSize: 16 },
    large:  { cols: 35, rows: 25, cellSize: 32, wallThickness: 3, glyphSize: 18 },
  };

  const LS_KEYS = {
    mazeSize: "tp_maze_size_v1",
    visitedDots: "tp_maze_visiteddots_v1",
  };

  function safePresetName(v) {
    if (v === "small" || v === "medium" || v === "large") return v;
    return "small";
  }

  const CFG = {
    mazeCols: 19,
    mazeRows: 13,
    cellSize: 34,

    wallThickness: 6,
    passageInset: 2,

    glyphSize: 18,
    tokenCount: 6,
    speed: 220,

    glyphFontFamily: `"TP-Cartouche-Font", system-ui, sans-serif`,

    timerLargePx: 34,
    timerSmallPx: 12,
    timerPad: 8,
    timerBorder: 2,
    timerCorner: 12,
    timerGap: 1,

    keyMoveSpeed: 220,

    // Movement collision microstep (smaller = safer).
    maxMoveStepPx: 2.8,
  };

  function applyMazeSizePreset(presetName) {
    const name = safePresetName(presetName);
    const p = MAZE_SIZE_PRESETS[name];
    CFG.mazeCols = p.cols;
    CFG.mazeRows = p.rows;
    CFG.cellSize = p.cellSize;
    CFG.wallThickness = p.wallThickness;
    CFG.glyphSize = p.glyphSize;
    return name;
  }

  function applyMobileOverridesIfNeeded() {
    if (!isMobileLike()) return;
    CFG.wallThickness = MOBILE_TUNING.wallThickness;
    CFG.glyphSize = MOBILE_TUNING.glyphSize;
    CFG.passageInset = MOBILE_TUNING.passageInset;
    CFG.speed = MOBILE_TUNING.speed;
    CFG.keyMoveSpeed = MOBILE_TUNING.keyMoveSpeed;
    CFG.maxMoveStepPx = MOBILE_TUNING.maxMoveStepPx;
  }

  function enforceMobileMazeSizeUI(mazeSizeSel) {
    if (!isMobileLike()) return;
    mazeSizeSel.value = "small";
    mazeSizeSel.disabled = true;
    Array.from(mazeSizeSel.options).forEach(opt => { opt.disabled = (opt.value !== "small"); });
  }

  /* =========================
     Cartouche essentials
     ========================= */
  const CARTOUCHE_FONT_FAMILY = "TP-Cartouche-Font";

  const WORD_TO_UCSUR_CP = {
    "nanpa": 0xF193D, "esun": 0xF190B, "e": 0xF1909, "nasa": 0xF193E,
    "ni": 0xF1941, "nena": 0xF1940, "o": 0xF1944, "kulupu": 0xF191F,

    "ijo": 0xF190C, "wan": 0xF1973, "tu": 0xF196E, "seli": 0xF1957, "awen": 0xF1908,
    "luka": 0xF192D, "utala": 0xF1971, "mun": 0xF193A, "pipi": 0xF1951, "jo": 0xF1913,

    "en": 0xF190A,
    "ona": 0xF1946,
    "kolon": 0xF199D
  };

  const TOKEN_GLYPH_WORDS = [
    "ijo","wan","tu","seli","awen","luka","utala","mun","pipi","jo",
    "ona","nasa","esun","kulupu","ni","nena","o","e","nanpa","en"
  ];

  function tokenWordToCodepoint(w) {
    const cp = WORD_TO_UCSUR_CP[String(w).toLowerCase()];
    return (typeof cp === "number") ? cp : null;
  }

  function getSmallCodepointsSet() {
    return new Set([
      0xF193D, // nanpa
      0xF1940, // nena
      0xF1941, // ni
      0xF193E, // nasa
      0xF1909, // e
      0xF190B, // esun
      0xF190A, // en
    ]);
  }
  const SMALL_SET = getSmallCodepointsSet();

  const DIGIT_TO_TOKEN = {
    "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
    "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
  };

  const TOKEN_TO_DIGIT_WORD = {
    "NI": "ijo", "WE": "wan", "TE": "tu", "SE": "seli", "NA": "awen",
    "LE": "luka", "NU": "utala", "ME": "mun", "PE": "pipi", "JE": "jo",
  };

  const OPCHAR_TO_TOKEN = { ".": "NONE", "-": "NO", "/": "NONO", "+": "NONONO" };
  const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));
  const TOKEN_PREFIXES = [ "KEKEKE", "KEKE", "KE", "NONONO", "NONO", "NE", "NO" ];

  function normalizeLooseSeparators(raw) {
    if (raw == null) return "";
    let s = String(raw);
    const isNeg = s.startsWith("-");
    const head = isNeg ? "-" : "";
    const rest = isNeg ? s.slice(1) : s;
    let r = rest.replace(/\s+/g, " ");
    r = r.replace(/-+/g, "-");
    return (head + r).trim();
  }

  function numberStrToNanpaCaps(s, { thousandsChar = "," } = {}) {
    if (s == null) throw new Error("s must be a string, not null");
    let raw = normalizeLooseSeparators(String(s));
    if (!raw) throw new Error("Empty value cannot be encoded");

    function encodeSingleNumberSegment(segment, includeInitialNe) {
      let seg = String(segment).trim();
      if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

      const out = [];
      if (includeInitialNe) out.push("NE");

      function pushNene() {
        if (out.length > 0 && out[out.length - 1] === "NENE") return;
        out.push("NENE");
      }

      if (seg.startsWith("-")) {
        out.push("NO");
        seg = seg.slice(1).trim();
      }

      if ((seg.match(/\./g) || []).length > 1) {
        throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
      }

      let intPart = seg;
      let fracPart = "";
      let hasDecimal = false;
      if (seg.includes(".")) {
        [intPart, fracPart] = seg.split(".", 2);
        hasDecimal = true;
      }

      let ip = String(intPart ?? "").trim();
      if (ip === "") ip = "0";

      const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
      for (const g of groups) {
        if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
      }

      for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

      if (hasDecimal) {
        out.push(OPCHAR_TO_TOKEN["."]);
        for (const ch of fracPart) {
          if (ch === "_" ) continue;
          if (ch === " " || ch === "-") { pushNene(); continue; }
          if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
          if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
          throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
        }
      }

      out.push("N");
      return out.join("");
    }

    return encodeSingleNumberSegment(raw, true);
  }

  function tokenizeNanpaCaps(caps) {
    const s = String(caps).trim().toUpperCase();
    if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
    if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

    const tokens = [];
    let i = 0;
    const n = s.length;

    while (i < n - 1) {
      let matched = null;
      for (const pref of TOKEN_PREFIXES) {
        if (s.startsWith(pref, i)) { matched = pref; break; }
      }
      if (matched != null) { tokens.push(matched); i += matched.length; continue; }

      if (i + 2 <= n - 1) {
        const two = s.slice(i, i + 2);
        if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
      }
      throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
    }

    tokens.push("N");
    return tokens;
  }

  function nanpaCapsTokensToTpWords(tokens) {
    const out = [];
    for (let i = 0; i < tokens.length; i++) {
      const t = tokens[i];

      if (t === "NE") {
        if (out.length === 0) out.push("nanpa", "en");
        else out.push("nena", "en");
        continue;
      }

      if (DIGIT_TOKENS.has(t)) {
        const digitWord = TOKEN_TO_DIGIT_WORD[t];
        if (t === "NI" || t === "NA" || t === "NU") out.push("nena", digitWord);
        else out.push(digitWord, "en");
        continue;
      }

      if (t === "NO") { out.push("nena", "o"); continue; }
      if (t === "KE") { out.push("kulupu", "en"); continue; }
      if (t === "N")  { out.push("nanpa"); continue; }

      throw new Error(`Unsupported token "${t}" in time cartouche`);
    }
    return out;
  }

  function tpWordsToUcsurCodepoints(words) {
    const cps = [];
    for (const w of words) {
      const key = String(w).toLowerCase();
      const cp = WORD_TO_UCSUR_CP[key];
      if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
      cps.push(cp);
    }
    return cps;
  }

  function decimalToUcsurCodepoints(decimalStr) {
    const raw0 = String(decimalStr ?? "").trim();
    if (!raw0) return [];
    const caps = numberStrToNanpaCaps(raw0, { thousandsChar: "," });
    const tokens = tokenizeNanpaCaps(caps);
    const tpWords = nanpaCapsTokensToTpWords(tokens);
    return tpWordsToUcsurCodepoints(tpWords);
  }

  function drawRoundedRect(ctx, x, y, w, h, r) {
    const radius = Math.min(r, w / 2, h / 2);
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + w, y, x + w, y + h, radius);
    ctx.arcTo(x + w, y + h, x, y + h, radius);
    ctx.arcTo(x, y + h, x, y, radius);
    ctx.arcTo(x, y, x + w, y, radius);
    ctx.closePath();
  }

  function applyCartoucheStrokeStyle(ctx, borderPx) {
    ctx.lineWidth = borderPx;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.strokeStyle = "#111";
  }

  function renderMixedCartoucheToCanvas(canvas, glyphs, largePx, smallPx, smallCodepoints, options = {}) {
    const pad = options.padding ?? 18;
    const border = options.border ?? 2;
    const corner = options.cornerRadius ?? 16;
    const letterGap = options.letterGap ?? 0;

    const ctx = canvas.getContext("2d");
    ctx.textBaseline = "alphabetic";

    const runs = [];
    let totalWidth = 0;
    let maxAscent = 0;
    let maxDescent = 0;

    for (const g of glyphs) {
      const ch = (typeof g === "number") ? String.fromCodePoint(g) : String(g);
      const isSmall = (typeof g === "number") && smallCodepoints.has(g);
      const px = isSmall ? smallPx : largePx;

      ctx.font = `${px}px "${CARTOUCHE_FONT_FAMILY}"`;
      const m = ctx.measureText(ch);

      const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

      const left = m.actualBoundingBoxLeft ?? 0;
      const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
      const tightW = Math.ceil(left + right);

      runs.push({ ch, px, tightW, left, ascent, descent });

      totalWidth += tightW + letterGap;
      if (ascent > maxAscent) maxAscent = ascent;
      if (descent > maxDescent) maxDescent = descent;
    }
    if (runs.length > 0) totalWidth -= letterGap;

    const textHeight = Math.ceil(maxAscent + maxDescent);
    const cartW = Math.ceil(totalWidth + pad * 2);
    const cartH = Math.ceil(textHeight + pad * 2);

    canvas.width = cartW + border * 2;
    canvas.height = cartH + border * 2;

    const ctx2 = canvas.getContext("2d");
    ctx2.textBaseline = "alphabetic";
    ctx2.clearRect(0, 0, canvas.width, canvas.height);

    drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
    applyCartoucheStrokeStyle(ctx2, border);
    ctx2.stroke();

    const baselineY = border + pad + maxAscent;
    let x = border + pad;

    ctx2.fillStyle = "#111";
    for (const r of runs) {
      ctx2.font = `${r.px}px "${CARTOUCHE_FONT_FAMILY}"`;
      const drawX = x + (r.left ?? 0);
      ctx2.fillText(r.ch, drawX, baselineY);
      x += r.tightW + letterGap;
    }
  }

  function buildTimeCartoucheGlyphs(totalSeconds) {
    const mm = Math.floor(totalSeconds / 60);
    const ss = totalSeconds % 60;

    const mm2 = String(mm).padStart(2, "0");
    const ss2 = String(ss).padStart(2, "0");

    const cpNanpa = WORD_TO_UCSUR_CP["nanpa"];
    const cpEn    = WORD_TO_UCSUR_CP["en"];

    function digitInner(dChar) {
      const cps = decimalToUcsurCodepoints(String(dChar));
      if (cps.length < 3) return [];
      return cps.slice(2, cps.length - 1);
    }

    const inner = [];
    for (const ch of mm2) inner.push(...digitInner(ch));
    inner.push(WORD_TO_UCSUR_CP["kolon"]);
    for (const ch of ss2) inner.push(...digitInner(ch));

    return [cpNanpa, cpEn, ...inner, cpNanpa];
  }

  async function ensureFontsLoaded() {
    if (!document.fonts || !document.fonts.load || !document.fonts.ready) return;
    await document.fonts.load(`24px "PatrickHand"`, "Time");
    const sampleChar = String.fromCodePoint(0xF190B);
    await document.fonts.load(`24px "${CARTOUCHE_FONT_FAMILY}"`, sampleChar);
    await document.fonts.ready;
  }

  /* =========================
     DOM / CANVAS
     ========================= */
  const wrap = document.getElementById("wrap");
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  const btnNew = document.getElementById("btnNew");
  const btnQuit = document.getElementById("btnQuit");
  const overlay = document.getElementById("overlay");
  const btnCancelQuit = document.getElementById("btnCancelQuit");
  const btnConfirmQuit = document.getElementById("btnConfirmQuit");
  const statusEl = document.getElementById("status");

  const timerCanvas = document.getElementById("timerCanvas");
  const timerCtx = timerCanvas.getContext("2d");
  const timerOffscreen = document.createElement("canvas");
  const finishOffscreen = document.createElement("canvas");

  const mazeSizeSel = document.getElementById("mazeSize");
  const visitedWrap = document.getElementById("visitedWrap");
  const visitedDotsChk = document.getElementById("visitedDots");
  const dpadEl = document.getElementById("dpad");

  /* =========================
     GAME STATE
     ========================= */
  const GameState = { idle: "idle", running: "running", finished: "finished", quitting: "quitting" };
  let state = GameState.idle;

  function syncMazeSizeUiLock() {
    if (isMobileLike()) { enforceMobileMazeSizeUI(mazeSizeSel); return; }
    mazeSizeSel.disabled = (state === GameState.running || state === GameState.quitting);
  }

  function resizeCanvasToDisplaySize() {
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, Math.floor(rect.width * dpr));
    const h = Math.max(1, Math.floor(rect.height * dpr));
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
    }
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  window.addEventListener("resize", () => {
    if (isMobileLike()) {
      applyMazeSizePreset("small");
      applyMobileOverridesIfNeeded();
      enforceMobileMazeSizeUI(mazeSizeSel);
    }
    resizeCanvasToDisplaySize();
    layout();
    renderTopTimerCartouche(timerSeconds);
    draw();
  });

  function renderTopTimerCartouche(totalSeconds) {
    const targetCssW = 170;
    const targetCssH = 36;
    const dpr = window.devicePixelRatio || 1;

    timerCanvas.style.width = `${targetCssW}px`;
    timerCanvas.style.height = `${targetCssH}px`;
    timerCanvas.width = Math.ceil(targetCssW * dpr);
    timerCanvas.height = Math.ceil(targetCssH * dpr);

    timerCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    timerCtx.clearRect(0, 0, targetCssW, targetCssH);

    const glyphs = buildTimeCartoucheGlyphs(totalSeconds);

    renderMixedCartoucheToCanvas(
      timerOffscreen,
      glyphs,
      CFG.timerLargePx,
      CFG.timerSmallPx,
      SMALL_SET,
      { padding: CFG.timerPad, border: CFG.timerBorder, cornerRadius: CFG.timerCorner, letterGap: CFG.timerGap }
    );

    const scale = Math.min(targetCssW / timerOffscreen.width, targetCssH / timerOffscreen.height);
    const drawW = Math.floor(timerOffscreen.width * scale);
    const drawH = Math.floor(timerOffscreen.height * scale);

    const x = Math.floor(targetCssW - drawW);
    const y = Math.floor((targetCssH - drawH) / 2);

    timerCtx.drawImage(timerOffscreen, x, y, drawW, drawH);
  }

  let timerSeconds = 0;
  let timerHandle = null;

  const pointer = { x: 0, y: 0, down: false, id: null };

  let viewport = { w: 0, h: 0 };

  // side panels + maze center region
  let side = { x: 0, y: 0, w: 200, h: 0 };
  let collect = { x: 0, y: 0, w: 200, h: 0 };
  let mazeRect = { x: 0, y: 0, w: 0, h: 0 };

  let maze = null;
  let startCell = null;
  let endCell = null;
  let wallRects = [];

  let tokens = [];
  let activeTokenIndex = -1;
  let dragOffset = { dx: 0, dy: 0 };
  let lastFrameTs = performance.now();

  const DPAD_BTN = 52, DPAD_GAP = 8, DPAD_PAD = 10;
  const DPAD_W = DPAD_BTN*3 + DPAD_GAP*2 + DPAD_PAD*2;
  const DPAD_H = DPAD_BTN*3 + DPAD_GAP*2 + DPAD_PAD*2;

  const runtime = { cell: CFG.cellSize, wall: CFG.wallThickness, tokenSize: CFG.glyphSize };

  let visitedDotsEnabled = false;
  let visitedCells = new Set();
  let seenCells = new Set();
  let deadCells = new Set();
  let trunkCells = new Set();

  function setVisitedControlsEnabled(enabled) {
    visitedDotsChk.disabled = !enabled;
    visitedWrap.classList.toggle("disabled", !enabled);
  }

  function clearVisitedCells() {
    visitedCells.clear();
    seenCells.clear();
    deadCells.clear();
  }

  function cellKey(cx, cy) { return `${cx},${cy}`; }
  function clampInt(v, min, max) { return Math.max(min, Math.min(max, v)); }

  function tokenCellFromPosition(x, y) {
    const cell = runtime.cell;
    const cx = clampInt(Math.floor((x - mazeRect.x) / cell), 0, CFG.mazeCols - 1);
    const cy = clampInt(Math.floor((y - mazeRect.y) / cell), 0, CFG.mazeRows - 1);
    return { cx, cy };
  }

  function markCellVisited(cx, cy) { visitedCells.add(cellKey(cx, cy)); }
  function markCellSeen(cx, cy) { seenCells.add(cellKey(cx, cy)); }

  function neighborsOf(cx, cy) {
    if (!maze) return [];
    const c = maze.cells[cy][cx];
    const out = [];
    if (!c.n && cy > 0) out.push({ cx, cy: cy - 1 });
    if (!c.e && cx < maze.cols - 1) out.push({ cx: cx + 1, cy });
    if (!c.s && cy < maze.rows - 1) out.push({ cx, cy: cy + 1 });
    if (!c.w && cx > 0) out.push({ cx: cx - 1, cy });
    return out;
  }
  function degreeOf(cx, cy) { return neighborsOf(cx, cy).length; }

  function computeTrunkPathSet(start, end) {
    const startK = cellKey(start.cx, start.cy);
    const endK = cellKey(end.cx, end.cy);

    const q = [start];
    const parent = new Map();
    parent.set(startK, null);

    while (q.length) {
      const cur = q.shift();
      const curK = cellKey(cur.cx, cur.cy);
      if (curK === endK) break;

      for (const nb of neighborsOf(cur.cx, cur.cy)) {
        const nbK = cellKey(nb.cx, nb.cy);
        if (!parent.has(nbK)) {
          parent.set(nbK, curK);
          q.push(nb);
        }
      }
    }

    const trunk = new Set();
    if (!parent.has(endK)) return trunk;

    let k = endK;
    while (k != null) {
      trunk.add(k);
      k = parent.get(k) ?? null;
    }
    return trunk;
  }

  function componentBehindEdge(start, blocked) {
    const startK = cellKey(start.cx, start.cy);
    const blockedK = cellKey(blocked.cx, blocked.cy);

    const q = [start];
    const seenLocal = new Set([startK]);
    const keys = [startK];

    while (q.length) {
      const cur = q.shift();
      for (const nb of neighborsOf(cur.cx, cur.cy)) {
        const nbK = cellKey(nb.cx, nb.cy);
        if (cellKey(cur.cx, cur.cy) === startK && nbK === blockedK) continue;
        if (!seenLocal.has(nbK)) {
          seenLocal.add(nbK);
          keys.push(nbK);
          q.push(nb);
        }
      }
    }
    return keys;
  }

  function markComponentDead(componentKeys) {
    for (const k of componentKeys) if (!trunkCells.has(k)) deadCells.add(k);
  }

  function tryMarkDeadSubtreeOnForkReturn(prevCell, curCell) {
    if (!visitedDotsEnabled) return;
    if (!maze) return;
    if (degreeOf(curCell.cx, curCell.cy) < 3) return;

    const compKeysAll = componentBehindEdge(prevCell, curCell);
    const compKeys = compKeysAll.filter(k => !trunkCells.has(k));
    if (compKeys.length === 0) return;

    let alreadyDead = true;
    for (const k of compKeys) { if (!deadCells.has(k)) { alreadyDead = false; break; } }
    if (alreadyDead) return;

    for (const k of compKeys) if (!seenCells.has(k)) return;
    markComponentDead(compKeys);
  }

  /* =========================
     INPUT SOURCES: keyboard + D-pad
     ========================= */
  const keysDown = new Set();
  function isTypingContext(el) {
    if (!el) return false;
    const tag = String(el.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || tag === "select" || el.isContentEditable;
  }

  window.addEventListener("keydown", (e) => {
    if (isTypingContext(document.activeElement)) return;
    if (state !== GameState.running) return;
    if (state === GameState.quitting) return;

    const k = e.key;
    if (k === "ArrowUp" || k === "ArrowDown" || k === "ArrowLeft" || k === "ArrowRight" ||
        k === "w" || k === "a" || k === "s" || k === "d" ||
        k === "W" || k === "A" || k === "S" || k === "D") {
      e.preventDefault();
      keysDown.add(k);
    }
    if (k === "Shift") keysDown.add("Shift");
  }, { passive: false });

  window.addEventListener("keyup", (e) => {
    keysDown.delete(e.key);
    if (e.key === "Shift") keysDown.delete("Shift");
  });

  const dpadState = { up: false, down: false, left: false, right: false };

  function setDpad(dir, isDown) {
    if (!(dir in dpadState)) return;
    dpadState[dir] = isDown;
    const btn = dpadEl && dpadEl.querySelector(`.dpadBtn[data-dir="${dir}"]`);
    if (btn) btn.classList.toggle("pressed", !!isDown);
  }

  function clearDpadAll() {
    setDpad("up", false);
    setDpad("down", false);
    setDpad("left", false);
    setDpad("right", false);
  }

  function bindDpad() {
    if (!dpadEl) return;
    if (!isCoarsePointer()) return;

    const stopAll = (e) => { e.preventDefault(); e.stopPropagation(); };

    dpadEl.addEventListener("pointerdown", stopAll, { passive: false });
    dpadEl.addEventListener("pointermove", stopAll, { passive: false });
    dpadEl.addEventListener("pointerup", stopAll, { passive: false });
    dpadEl.addEventListener("pointercancel", stopAll, { passive: false });

    const buttons = dpadEl.querySelectorAll(".dpadBtn[data-dir]");
    buttons.forEach((btn) => {
      btn.addEventListener("pointerdown", (e) => {
        if (state !== GameState.running) return;
        stopAll(e);
        btn.setPointerCapture(e.pointerId);
        setDpad(btn.dataset.dir, true);
      }, { passive: false });

      btn.addEventListener("pointerup", (e) => { stopAll(e); setDpad(btn.dataset.dir, false); }, { passive: false });
      btn.addEventListener("pointercancel", (e) => { stopAll(e); setDpad(btn.dataset.dir, false); }, { passive: false });
      btn.addEventListener("pointerleave", () => { setDpad(btn.dataset.dir, false); });
    });
  }

  function keyboardVector() {
    let dx = 0, dy = 0;

    const left  = keysDown.has("ArrowLeft")  || keysDown.has("a") || keysDown.has("A");
    const right = keysDown.has("ArrowRight") || keysDown.has("d") || keysDown.has("D");
    const up    = keysDown.has("ArrowUp")    || keysDown.has("w") || keysDown.has("W");
    const down  = keysDown.has("ArrowDown")  || keysDown.has("s") || keysDown.has("S");

    if (left  || dpadState.left)  dx -= 1;
    if (right || dpadState.right) dx += 1;
    if (up    || dpadState.up)    dy -= 1;
    if (down  || dpadState.down)  dy += 1;

    const len = Math.hypot(dx, dy) || 1;
    return { ux: dx / len, uy: dy / len, active: (dx !== 0 || dy !== 0) };
  }

  /* =========================
     MAZE GENERATION
     ========================= */
  function makeMaze(cols, rows) {
    const cells = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => ({ n: true, e: true, s: true, w: true, visited: false }))
    );

    function neighbors(cx, cy) {
      const out = [];
      if (cy > 0) out.push({ dir: "n", x: cx, y: cy - 1 });
      if (cx < cols - 1) out.push({ dir: "e", x: cx + 1, y: cy });
      if (cy < rows - 1) out.push({ dir: "s", x: cx, y: cy + 1 });
      if (cx > 0) out.push({ dir: "w", x: cx - 1, y: cy });
      return out;
    }

    function carveBetween(ax, ay, bx, by, dir) {
      const a = cells[ay][ax];
      const b = cells[by][bx];
      if (dir === "n") { a.n = false; b.s = false; }
      if (dir === "e") { a.e = false; b.w = false; }
      if (dir === "s") { a.s = false; b.n = false; }
      if (dir === "w") { a.w = false; b.e = false; }
    }

    const stack = [];
    let cx = Math.floor(Math.random() * cols);
    let cy = Math.floor(Math.random() * rows);

    cells[cy][cx].visited = true;
    stack.push({ x: cx, y: cy });

    while (stack.length) {
      const cur = stack[stack.length - 1];
      const ns = neighbors(cur.x, cur.y).filter(n => !cells[n.y][n.x].visited);
      if (ns.length === 0) { stack.pop(); continue; }
      const pick = ns[Math.floor(Math.random() * ns.length)];
      carveBetween(cur.x, cur.y, pick.x, pick.y, pick.dir);
      cells[pick.y][pick.x].visited = true;
      stack.push({ x: pick.x, y: pick.y });
    }

    for (let y = 0; y < rows; y++) for (let x = 0; x < cols; x++) cells[y][x].visited = false;
    return { cols, rows, cells };
  }

  function bfsHasPath(mz, sx, sy, ex, ey) {
    const { cols, rows, cells } = mz;
    const seen = Array.from({ length: rows }, () => Array(cols).fill(false));
    const q = [{ x: sx, y: sy }];
    seen[sy][sx] = true;

    while (q.length) {
      const cur = q.shift();
      if (cur.x === ex && cur.y === ey) return true;

      const c = cells[cur.y][cur.x];
      if (!c.n && cur.y > 0 && !seen[cur.y - 1][cur.x]) { seen[cur.y - 1][cur.x] = true; q.push({ x: cur.x, y: cur.y - 1 }); }
      if (!c.e && cur.x < cols - 1 && !seen[cur.y][cur.x + 1]) { seen[cur.y][cur.x + 1] = true; q.push({ x: cur.x + 1, y: cur.y }); }
      if (!c.s && cur.y < rows - 1 && !seen[cur.y + 1][cur.x]) { seen[cur.y + 1][cur.x] = true; q.push({ x: cur.x, y: cur.y + 1 }); }
      if (!c.w && cur.x > 0 && !seen[cur.y][cur.x - 1]) { seen[cur.y][cur.x - 1] = true; q.push({ x: cur.x - 1, y: cur.y }); }
    }
    return false;
  }

  function generateSolvableMaze() {
    for (let attempt = 0; attempt < 50; attempt++) {
      const mz = makeMaze(CFG.mazeCols, CFG.mazeRows);
      const sy = Math.floor(Math.random() * CFG.mazeRows);
      const ey = Math.floor(Math.random() * CFG.mazeRows);
      const sx = 0;
      const ex = CFG.mazeCols - 1;

      mz.cells[sy][sx].w = false;
      mz.cells[ey][ex].e = false;

      if (bfsHasPath(mz, sx, sy, ex, ey)) {
        maze = mz;
        startCell = { cx: sx, cy: sy };
        endCell = { cx: ex, cy: ey };
        buildWallRects();
        trunkCells = computeTrunkPathSet(startCell, endCell);
        return;
      }
    }

    maze = makeMaze(CFG.mazeCols, CFG.mazeRows);
    startCell = { cx: 0, cy: Math.floor(CFG.mazeRows / 2) };
    endCell = { cx: CFG.mazeCols - 1, cy: Math.floor(CFG.mazeRows / 2) };
    maze.cells[startCell.cy][startCell.cx].w = false;
    maze.cells[endCell.cy][endCell.cx].e = false;
    buildWallRects();
    trunkCells = computeTrunkPathSet(startCell, endCell);
  }

  /* =========================
     LAYOUT + WALL RECTS
     ========================= */
  function getCssVarPx(name, fallback) {
    const v = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    const n = Number(String(v).replace("px","").trim());
    return Number.isFinite(n) && n > 0 ? n : fallback;
  }

  function layout() {
    const rect = canvas.getBoundingClientRect();
    viewport.w = rect.width;
    viewport.h = rect.height;

    const cssSide = getCssVarPx("--side-w", 200);
    const maxPanel = Math.floor(viewport.w * 0.26);
    const panelW = Math.max(110, Math.min(cssSide, maxPanel));

    side = { x: 0, y: 0, w: panelW, h: viewport.h };
    collect = { x: Math.max(panelW, viewport.w - panelW), y: 0, w: panelW, h: viewport.h };

    const pad = 14;
    const bottomReserve = isMobileLike() ? MOBILE_TUNING.reserveBottomPx : 0;

    const availW = Math.max(50, viewport.w - side.w - collect.w - pad * 2);
    const availH = Math.max(50, viewport.h - pad * 2 - bottomReserve);

        const fitCell = Math.floor(Math.min(availW / CFG.mazeCols, availH / CFG.mazeRows));

    // Allow smaller cells on phones; the token size will be derived to fit.
    runtime.cell = Math.max(10, Math.min(CFG.cellSize, fitCell));

    // Scale wall thickness down if the cell is small.
    runtime.wall = Math.min(CFG.wallThickness, Math.max(1, Math.floor(runtime.cell * 0.22)));

    // Compute a token size that MUST fit inside the corridor:
    // corridor ~= cell - 2*wall, and we also keep passageInset + a small margin.
    const maxTok = runtime.cell - 2*runtime.wall - 2*CFG.passageInset - 2;

    // Clamp token size so it stays usable but never larger than the corridor.
    runtime.tokenSize = Math.max(6, Math.min(CFG.glyphSize, maxTok));

    // Apply runtime token size to all tokens so collision uses the correct size.
    for (const tok of tokens) tok.size = runtime.tokenSize;


    mazeRect.w = runtime.cell * CFG.mazeCols;
    mazeRect.h = runtime.cell * CFG.mazeRows;

    mazeRect.x = side.w + Math.floor((viewport.w - side.w - collect.w - mazeRect.w) / 2);

    const centerRegionH = viewport.h - bottomReserve;
    mazeRect.y = Math.floor((centerRegionH - mazeRect.h) / 2);

    positionTokensInSidebar();
    positionDoneTokensInCollector();
    buildWallRects();

    placeDpadInCollector();
  }

  function placeDpadInCollector() {
    if (!dpadEl) return;
    if (!isCoarsePointer()) return;

    const topPad = 14;
    const headerH = 26;
    const tokenRowsReserve = 2 * 56;
    const y0 = topPad + headerH + tokenRowsReserve + 16;

    const padW = DPAD_W;
    const padH = DPAD_H;

    let x = Math.floor(collect.x + (collect.w - padW) / 2);
    let y = Math.floor(Math.min(viewport.h - padH - 16, y0));

    // Clamp fully on-screen
    x = clampInt(x, 8, Math.max(8, viewport.w - padW - 8));
    y = clampInt(y, 8, Math.max(8, viewport.h - padH - 8));


    dpadEl.style.left = `${x}px`;
    dpadEl.style.top = `${y}px`;
  }

  function cellToRect(cx, cy) {
    const cell = runtime.cell;
    return { x: mazeRect.x + cx * cell, y: mazeRect.y + cy * cell, w: cell, h: cell };
  }

  function buildWallRects() {
    wallRects = [];
    if (!maze) return;

    const t = runtime.wall;


    for (let y = 0; y < maze.rows; y++) {
      for (let x = 0; x < maze.cols; x++) {
        const c = maze.cells[y][x];
        const r = cellToRect(x, y);

        if (c.n) wallRects.push({ x: r.x, y: r.y, w: r.w, h: t });
        if (c.w) wallRects.push({ x: r.x, y: r.y, w: t, h: r.h });

        if (x === maze.cols - 1 && c.e) wallRects.push({ x: r.x + r.w - t, y: r.y, w: t, h: r.h });
        if (y === maze.rows - 1 && c.s) wallRects.push({ x: r.x, y: r.y + r.h - t, w: r.w, h: t });
      }
    }
  }

  /* =========================
     TOKENS
     ========================= */
  function pickRandomTokenGlyphs(n) {
    const pool = TOKEN_GLYPH_WORDS
      .map(w => ({ word: w, cp: tokenWordToCodepoint(w) }))
      .filter(x => x.cp != null);

    if (pool.length < n) throw new Error(`Token glyph pool too small. Need ${n}, have ${pool.length}.`);

    for (let i = pool.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [pool[i], pool[j]] = [pool[j], pool[i]];
    }
    return pool.slice(0, n);
  }

  function createTokens() {
    const picks = pickRandomTokenGlyphs(CFG.tokenCount);
    tokens = picks.map((p) => ({
      word: p.word,
      cp: p.cp,
      x: 0, y: 0,
      size: CFG.glyphSize,
      done: false,
      inMaze: false,
      lastCell: null,
    }));

    activeTokenIndex = -1;
    positionTokensInSidebar();
    positionDoneTokensInCollector();
  }

  function positionTokensInSidebar() {
    const slotH = 56, topPad = 18, leftPad = 18;
    let slot = 0;
    for (const tok of tokens) {
      if (tok.done) continue;
      if (tok.inMaze) continue;
      tok.x = leftPad + tok.size / 2;
      tok.y = topPad + slot * slotH + tok.size / 2;
      slot++;
    }
  }

  function positionDoneTokensInCollector() {
    const slotH = 56, topPad = 18, leftPad = 18;
    let slot = 0;
    for (const tok of tokens) {
      if (!tok.done) continue;
      tok.x = collect.x + leftPad + tok.size / 2;
      tok.y = topPad + slot * slotH + tok.size / 2;
      slot++;
    }
  }

  function hitToken(tok, px, py) {
    const s = tok.size;
    return (px >= tok.x - s/2 && px <= tok.x + s/2 && py >= tok.y - s/2 && py <= tok.y + s/2);
  }

  function anyTokenInMaze() {
    return tokens.some(t => t.inMaze && !t.done);
  }

  function firstUndoneTokenIndex() {
    for (let i = 0; i < tokens.length; i++) if (!tokens[i].done) return i;
    return -1;
  }

  function placeActiveTokenAtMazeStart(idx) {
    if (!maze || idx < 0 || idx >= tokens.length) return;
    const tok = tokens[idx];
    if (tok.done) return;

    // Ensure all other non-done tokens are outside
    for (let i = 0; i < tokens.length; i++) {
      if (i === idx) continue;
      const t = tokens[i];
      if (t.done) continue;
      t.inMaze = false;
      t.lastCell = null;
    }

    const sr = cellToRect(startCell.cx, startCell.cy);
    tok.inMaze = true;
    tok.x = mazeRect.x + runtime.wall + CFG.passageInset + tok.size/2 + 1;
    tok.y = sr.y + sr.h / 2;
    tok.lastCell = tokenCellFromPosition(tok.x, tok.y);

    activeTokenIndex = idx;

    if (visitedDotsEnabled) {
      const c = tok.lastCell;
      markCellSeen(c.cx, c.cy);
    }

    // Ensure position is valid
    keepInMazeBounds(tok);
  }

  /* =========================
     TIMER + UI
     ========================= */
  function setStatus(msg) { statusEl.textContent = msg; }

  function startTimer() {
    stopTimer();
    timerHandle = setInterval(() => {
      timerSeconds++;
      renderTopTimerCartouche(timerSeconds);
    }, 1000);
  }

  function stopTimer() {
    if (timerHandle) clearInterval(timerHandle);
    timerHandle = null;
  }

  function resetUIForIdle() {
    timerSeconds = 0;
    renderTopTimerCartouche(timerSeconds);
    btnQuit.disabled = true;
    syncMazeSizeUiLock();
    clearDpadAll();
  }

  function showQuitModal() {
    state = GameState.quitting;
    stopTimer();
    syncMazeSizeUiLock();
    overlay.classList.add("show");
    wrap.classList.add("mazeHidden");
    clearDpadAll();
  }

  function hideQuitModal(resume) {
    overlay.classList.remove("show");
    wrap.classList.remove("mazeHidden");
    if (resume && state === GameState.quitting) {
      state = GameState.running;
      syncMazeSizeUiLock();
      startTimer();
    } else {
      syncMazeSizeUiLock();
    }
  }

  /* =========================
     COLLISION + MOVEMENT
     ========================= */
  function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
    return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
  }

  function collidesWithWalls(x, y, size) {
    const left = x - size/2;
    const top = y - size/2;
    for (const wr of wallRects) {
      if (rectsOverlap(left, top, size, size, wr.x, wr.y, wr.w, wr.h)) return true;
    }
    return false;
  }

  function moveTokenWithCollision(tok, dx, dy) {
    const maxStep = CFG.maxMoveStepPx;
    const steps = Math.max(1, Math.ceil(Math.max(Math.abs(dx), Math.abs(dy)) / maxStep));
    const sx = dx / steps;
    const sy = dy / steps;

    for (let i = 0; i < steps; i++) {
      if (sx !== 0) {
        const nx = tok.x + sx;
        if (!collidesWithWalls(nx, tok.y, tok.size)) tok.x = nx;
      }
      if (sy !== 0) {
        const ny = tok.y + sy;
        if (!collidesWithWalls(tok.x, ny, tok.size)) tok.y = ny;
      }
    }
  }

  function checkTokenExit(tok) {
    return (tok.x - tok.size/2 > mazeRect.x + mazeRect.w + 2);
  }

  function keepInMazeBounds(tok) {
    const minX = mazeRect.x + tok.size/2;
    const maxX = mazeRect.x + mazeRect.w + tok.size/2 + 10;
    const minY = mazeRect.y + tok.size/2;
    const maxY = mazeRect.y + mazeRect.h - tok.size/2;

    if (tok.x < minX) tok.x = minX;
    if (tok.y < minY) tok.y = minY;
    if (tok.y > maxY) tok.y = maxY;
    if (tok.x > maxX) tok.x = maxX;
  }

  /* =========================
     DRAWING
     ========================= */
  function drawPanelBackground() {
    ctx.fillStyle = "#F3DFC0";
    ctx.fillRect(0, 0, viewport.w, viewport.h);

    ctx.fillStyle = "rgba(255,255,255,0.28)";
    ctx.fillRect(side.x, side.y, side.w, side.h);

    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.fillRect(collect.x, collect.y, collect.w, collect.h);

    ctx.fillStyle = "rgba(0,0,0,0.12)";
    ctx.fillRect(side.w, 0, 1, viewport.h);
    ctx.fillRect(collect.x, 0, 1, viewport.h);

    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.font = `14px "PatrickHand", system-ui, sans-serif`;
    ctx.textAlign = "left";
    ctx.textBaseline = "top";
    ctx.fillText("START", 12, 10);
    ctx.fillText("DONE", collect.x + 12, 10);
  }

  function drawDeadCellsOverlay() {
    if (!visitedDotsEnabled) return;
    if (deadCells.size === 0) return;

    ctx.fillStyle = DEAD_CELL_RGBA;

    for (const key of deadCells) {
      if (trunkCells.has(key)) continue;
      const parts = key.split(",");
      const cx = Number(parts[0]);
      const cy = Number(parts[1]);
      if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;

      const rr = cellToRect(cx, cy);
      const inset = Math.min(2, rr.w * 0.08);
      ctx.fillRect(rr.x + inset, rr.y + inset, rr.w - inset * 2, rr.h - inset * 2);
    }
  }

  function drawVisitedDots() {
    if (!visitedDotsEnabled) return;
    if (visitedCells.size === 0) return;

    const cell = runtime.cell;
    const r = Math.max(1.5, Math.min(4, cell * 0.12));

    ctx.fillStyle = VISITED_DOT_RGBA;
    for (const key of visitedCells) {
      const parts = key.split(",");
      const cx = Number(parts[0]);
      const cy = Number(parts[1]);
      if (!Number.isFinite(cx) || !Number.isFinite(cy)) continue;

      const rr = cellToRect(cx, cy);
      const dotX = rr.x + rr.w / 2;
      const dotY = rr.y + rr.h / 2;

      ctx.beginPath();
      ctx.arc(dotX, dotY, r, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawMaze() {
    if (!maze) return;

    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.fillRect(mazeRect.x, mazeRect.y, mazeRect.w, mazeRect.h);

    drawDeadCellsOverlay();

    ctx.fillStyle = "#111";
    for (const w of wallRects) ctx.fillRect(w.x, w.y, w.w, w.h);

    drawVisitedDots();

    const cell = runtime.cell;
    const sr = cellToRect(startCell.cx, startCell.cy);
    ctx.fillStyle = "rgba(17,17,17,0.10)";
    ctx.fillRect(mazeRect.x - 6, sr.y + 2, 6, cell - 4);

    const er = cellToRect(endCell.cx, endCell.cy);
    ctx.fillRect(mazeRect.x + mazeRect.w, er.y + 2, 6, cell - 4);
  }

  function drawTokens() {
    ctx.textAlign = "left";
    ctx.textBaseline = "middle";
    ctx.font = `${Math.max(12, CFG.glyphSize)}px "${CARTOUCHE_FONT_FAMILY}"`;

    for (const tok of tokens) {
      if (!tok || tok.cp == null) continue;

      const ch = String.fromCodePoint(tok.cp);

      if (!tok.inMaze) {
        ctx.fillStyle = "rgba(0,0,0,0.06)";
        ctx.fillRect(tok.x - tok.size/2 - 8, tok.y - tok.size/2 - 8, tok.size + 16, tok.size + 16);
      }

      const metrics = ctx.measureText(ch);
      const x = tok.x - metrics.width / 2;

      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 1;
      ctx.strokeText(ch, x, tok.y);

      ctx.fillStyle = "#000";
      ctx.fillText(ch, x, tok.y);
    }
  }

  function drawFinishOverlay() {
    if (state !== GameState.finished) return;
    if (!mazeRect || mazeRect.w <= 0 || mazeRect.h <= 0) return;

    const glyphs = buildTimeCartoucheGlyphs(timerSeconds);

    const largePx = 64;
    const smallPx = 22;

    renderMixedCartoucheToCanvas(
      finishOffscreen,
      glyphs,
      largePx,
      smallPx,
      SMALL_SET,
      { padding: 18, border: 3, cornerRadius: 18, letterGap: 1 }
    );

    const maxW = mazeRect.w * 0.82;
    const maxH = mazeRect.h * 0.28;
    const scale = Math.min(maxW / finishOffscreen.width, maxH / finishOffscreen.height, 1);

    const drawW = Math.floor(finishOffscreen.width * scale);
    const drawH = Math.floor(finishOffscreen.height * scale);

    const x = Math.floor(mazeRect.x + (mazeRect.w - drawW) / 2);
    const y = Math.floor(mazeRect.y + (mazeRect.h - drawH) / 2);

    // Optional: keep a subtle dim behind everything for readability
    // ctx.fillStyle = "rgba(0,0,0,0.18)";
    // ctx.fillRect(mazeRect.x, mazeRect.y, mazeRect.w, mazeRect.h);

    // NEW: solid rounded panel behind the cartouche
    const pad = 14;
    const panelX = x - pad;
    const panelY = y - pad;
    const panelW = drawW + pad * 2;
    const panelH = drawH + pad * 2;

    // Fill
    ctx.fillStyle = "#F3DFC0"; // matches page background; change if you want white
    drawRoundedRect(ctx, panelX, panelY, panelW, panelH, 18);
    ctx.fill();

    // Border
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0,0.28)";
    ctx.stroke();

    // Draw the cartouche on top
    ctx.drawImage(finishOffscreen, x, y, drawW, drawH);
  }


  function draw() {
    resizeCanvasToDisplaySize();
    viewport.w = canvas.getBoundingClientRect().width;
    viewport.h = canvas.getBoundingClientRect().height;

    drawPanelBackground();
    if (state !== GameState.idle) drawMaze();
    drawTokens();

    // NEW: show a big final-time cartouche in the middle when finished
    drawFinishOverlay();
  }

  /* =========================
     GAME FLOW
     ========================= */
  function startNewGame() {
    state = GameState.running;
    syncMazeSizeUiLock();
    btnQuit.disabled = false;

    setVisitedControlsEnabled(false);

    timerSeconds = 0;
    renderTopTimerCartouche(timerSeconds);

    clearVisitedCells();

    generateSolvableMaze();
    createTokens();
    layout();

    // NEW: Automatically place the first glyph at the start, ready to move.
    const firstIdx = firstUndoneTokenIndex();
    if (firstIdx >= 0) placeActiveTokenAtMazeStart(firstIdx);

    setStatus("Use Arrow keys/WASD, or the D-pad on mobile. (Pointer-drag still works.)");
    startTimer();
  }

  function finishGame() {
    state = GameState.finished;
    stopTimer();
    syncMazeSizeUiLock();
    btnQuit.disabled = true;
    setVisitedControlsEnabled(true);

    const mm = Math.floor(timerSeconds / 60);
    const ss = timerSeconds % 60;
    const timeStr = `${mm}:${String(ss).padStart(2, "0")}`;
    setStatus(`Finished. Final time: ${timeStr}. Click “Start New Game” to play again.`);
    clearDpadAll();
  }

  function quitGameConfirmed() {
    hideQuitModal(false);
    state = GameState.idle;
    stopTimer();
    syncMazeSizeUiLock();
    timerSeconds = 0;
    renderTopTimerCartouche(timerSeconds);
    btnQuit.disabled = true;
    clearDpadAll();

    setVisitedControlsEnabled(true);

    maze = null;
    wallRects = [];
    tokens = [];
    activeTokenIndex = -1;

    clearVisitedCells();
    trunkCells = new Set();

    setStatus("Game quit. Click “Start New Game” to play again.");
    draw();
  }

  // NEW: when one glyph exits, the maze changes and the next glyph is auto-placed inside the new maze.
  function nextMazeAndAutoPlaceNextToken() {
    generateSolvableMaze();

    // reset non-done tokens to "not in maze"
    for (const tok of tokens) {
      if (!tok.done) tok.inMaze = false;
      tok.lastCell = null;
    }
    activeTokenIndex = -1;

    clearVisitedCells();
    positionTokensInSidebar();
    positionDoneTokensInCollector();
    buildWallRects();
    placeDpadInCollector();

    const nextIdx = firstUndoneTokenIndex();
    if (nextIdx >= 0) {
      placeActiveTokenAtMazeStart(nextIdx);
      setStatus("Next glyph placed at the start. Use Arrow keys/WASD or the D-pad.");
    }
    clearDpadAll();
  }

  /* =========================
     INPUT (Pointer Events)
     ========================= */
  function canvasPointFromEvent(e) {
    const r = canvas.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function onPointerDown(e) {
    e.preventDefault();
    if (state === GameState.quitting) return;
    if (state === GameState.idle) return;

    canvas.setPointerCapture(e.pointerId);

    pointer.down = true;
    pointer.id = e.pointerId;
    const p = canvasPointFromEvent(e);
    pointer.x = p.x;
    pointer.y = p.y;

    // With auto-placement, we generally do not need sidebar dragging,
    // but keep it available only if NO token is currently in the maze.
    const locked = anyTokenInMaze();
    if (!locked && state === GameState.running) {
      for (let i = 0; i < tokens.length; i++) {
        const tok = tokens[i];
        if (tok.done) continue;

        if (!tok.inMaze && tok.x < side.w && hitToken(tok, pointer.x, pointer.y)) {
          activeTokenIndex = i;
          dragOffset.dx = tok.x - pointer.x;
          dragOffset.dy = tok.y - pointer.y;
          setStatus("Drag into the entrance. Once inside, use Arrow keys/WASD or the D-pad.");
          return;
        }
      }
    }
  }

  function onPointerMove(e) {
    e.preventDefault();
    if (state === GameState.quitting) return;
    if (state === GameState.idle) return;
    if (state !== GameState.running) return;

    const p = canvasPointFromEvent(e);
    pointer.x = p.x;
    pointer.y = p.y;

    if (activeTokenIndex >= 0) {
      const tok = tokens[activeTokenIndex];

      if (!tok.done && !tok.inMaze && pointer.down) {
        tok.x = pointer.x + dragOffset.dx;
        tok.y = pointer.y + dragOffset.dy;

        // clamp to left area only
        const minX = tok.size/2 + 6;
        const maxXBeforeMaze = (mazeRect.x - tok.size/2 - 1);
        const minY = tok.size/2 + 6;
        const maxY = viewport.h - tok.size/2 - 6;
        tok.x = Math.max(minX, Math.min(maxXBeforeMaze, tok.x));
        tok.y = Math.max(minY, Math.min(maxY, tok.y));

        const reachesEntranceLine = (tok.x + tok.size/2 >= mazeRect.x - 1);
        if (reachesEntranceLine) {
          placeActiveTokenAtMazeStart(activeTokenIndex);
          setStatus("Inside maze: use Arrow keys/WASD or the D-pad.");
        }
      }

      if (!tok.done && tok.inMaze) keepInMazeBounds(tok);
    }
  }

  function onPointerUp(e) {
    if (pointer.id === e.pointerId) {
      pointer.down = false;
      pointer.id = null;
    }
  }

  const peOpts = { passive: false };
  canvas.addEventListener("pointerdown", onPointerDown, peOpts);
  canvas.addEventListener("pointermove", onPointerMove, peOpts);
  canvas.addEventListener("pointerup", onPointerUp, peOpts);
  canvas.addEventListener("pointercancel", onPointerUp, peOpts);

  /* =========================
     MAIN LOOP
     ========================= */
  function tick(ts) {
    const dt = Math.min(0.05, (ts - lastFrameTs) / 1000);
    lastFrameTs = ts;

    if (state === GameState.running) {
      if (activeTokenIndex >= 0) {
        const tok = tokens[activeTokenIndex];
        if (tok && !tok.done && tok.inMaze) {

          const pointerOnGlyph = pointer.down && hitToken(tok, pointer.x, pointer.y);
          if (pointer.down && !pointerOnGlyph) {
            const dx = pointer.x - tok.x;
            const dy = pointer.y - tok.y;
            const len = Math.hypot(dx, dy) || 1;
            const ux = dx / len;
            const uy = dy / len;

            const step = CFG.speed * dt;
            moveTokenWithCollision(tok, ux * step, uy * step);
            keepInMazeBounds(tok);
          }

          const kv = keyboardVector();
          if (kv.active) {
            const boost = (keysDown.has("Shift") ? 1.6 : 1.0);
            const step = CFG.keyMoveSpeed * boost * dt;
            moveTokenWithCollision(tok, kv.ux * step, kv.uy * step);
            keepInMazeBounds(tok);
          }

          if (visitedDotsEnabled) {
            const cur = tokenCellFromPosition(tok.x, tok.y);
            if (!tok.lastCell) {
              tok.lastCell = cur;
              markCellSeen(cur.cx, cur.cy);
            } else if (cur.cx !== tok.lastCell.cx || cur.cy !== tok.lastCell.cy) {
              markCellVisited(tok.lastCell.cx, tok.lastCell.cy);
              markCellSeen(cur.cx, cur.cy);
              tryMarkDeadSubtreeOnForkReturn(tok.lastCell, cur);
              tok.lastCell = cur;
            }
          }

          if (checkTokenExit(tok)) {
            if (visitedDotsEnabled) {
              const last = tok.lastCell || tokenCellFromPosition(tok.x, tok.y);
              markCellVisited(last.cx, last.cy);
              markCellSeen(last.cx, last.cy);
            }

            tok.done = true;
            tok.inMaze = false;
            tok.lastCell = null;
            activeTokenIndex = -1;

            positionDoneTokensInCollector();

            const remaining = tokens.filter(t => !t.done).length;
            if (remaining === 0) finishGame();
            else nextMazeAndAutoPlaceNextToken();
          }
        }
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  /* =========================
     BUTTONS
     ========================= */
  btnNew.addEventListener("click", () => { hideQuitModal(false); startNewGame(); });
  btnQuit.addEventListener("click", () => { if (state === GameState.running) showQuitModal(); });
  btnCancelQuit.addEventListener("click", () => hideQuitModal(true));
  btnConfirmQuit.addEventListener("click", () => quitGameConfirmed());

  overlay.addEventListener("pointerdown", (e) => e.stopPropagation());
  overlay.addEventListener("pointermove", (e) => e.stopPropagation());
  overlay.addEventListener("pointerup", (e) => e.stopPropagation());

  /* ============================================================
     Maze size selection wiring + localStorage
     ============================================================ */
  function getSavedMazeSize() {
    try { return safePresetName(localStorage.getItem(LS_KEYS.mazeSize) || "small"); }
    catch { return "small"; }
  }
  function saveMazeSize(v) {
    try { localStorage.setItem(LS_KEYS.mazeSize, safePresetName(v)); } catch {}
  }
  function applyMazeSizeFromUI() {
    if (isMobileLike()) { enforceMobileMazeSizeUI(mazeSizeSel); return; }

    const chosen = safePresetName(mazeSizeSel.value);
    const applied = applyMazeSizePreset(chosen);
    saveMazeSize(applied);

    if (state === GameState.running) {
      mazeSizeSel.value = getSavedMazeSize();
      return;
    }

    applyMobileOverridesIfNeeded();
    layout();
    draw();
  }

  /* ============================================================
     Visited dots option wiring + localStorage
     ============================================================ */
  function getSavedVisitedDots() {
    try { return (localStorage.getItem(LS_KEYS.visitedDots) === "1"); }
    catch { return false; }
  }
  function saveVisitedDots(enabled) {
    try { localStorage.setItem(LS_KEYS.visitedDots, enabled ? "1" : "0"); } catch {}
  }
  function applyVisitedDotsFromUI() {
    if (state === GameState.running) {
      visitedDotsChk.checked = visitedDotsEnabled;
      return;
    }
    visitedDotsEnabled = !!visitedDotsChk.checked;
    saveVisitedDots(visitedDotsEnabled);
    clearVisitedCells();
    draw();
  }

  /* =========================
     INIT
     ========================= */
  function init() {
    resizeCanvasToDisplaySize();
    layout();
    timerSeconds = 0;
    renderTopTimerCartouche(timerSeconds);
    btnQuit.disabled = true;
    setStatus("Click “Start New Game”.");
    draw();
    requestAnimationFrame(tick);
  }

  window.addEventListener("load", async () => {
    if (isMobileLike()) {
      applyMazeSizePreset("small");
      applyMobileOverridesIfNeeded();
      enforceMobileMazeSizeUI(mazeSizeSel);
      saveMazeSize("small");
    } else {
      const savedSize = getSavedMazeSize();
      mazeSizeSel.value = savedSize;
      applyMazeSizePreset(savedSize);
    }

    syncMazeSizeUiLock();
    mazeSizeSel.addEventListener("change", applyMazeSizeFromUI);

    visitedDotsEnabled = getSavedVisitedDots();
    visitedDotsChk.checked = visitedDotsEnabled;
    visitedDotsChk.addEventListener("change", applyVisitedDotsFromUI);
    setVisitedControlsEnabled(true);

    bindDpad();

    try { await ensureFontsLoaded(); } catch {}

    renderTopTimerCartouche(0);
    init();
  });
})();
</script>
</body>
</html>
