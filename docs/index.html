<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toki Pona → Cartouche Calculator</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;     /* CHANGED: unify background color */
      --muted: #57606a;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg); /* CHANGED */
    }

    .card {
      background: var(--bg); /* CHANGED */
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .row { display: flex; gap: var(--gap); flex-wrap: wrap; align-items: flex-end; }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input[type="text"], textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg); /* CHANGED */
      font: inherit;
    }

    textarea { min-height: 84px; resize: vertical; }

    .col { flex: 1 1 320px; }

    button {
      border: 1px solid var(--border);
      background: var(--bg); /* CHANGED */
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover {
      background: var(--bg); /* CHANGED: keep same background */
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    .out { margin-top: 12px; }

    .out h3 { margin: 18px 0 8px; font-size: 14px; }

    canvas {
      display: block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: var(--bg); /* CHANGED */
    }

    .small { font-size: 12px; color: var(--muted); }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr; /* always one column */
      gap: 14px;
    }

    .hidden {
      display: none !important;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src: url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.otf") format("opentype");
      font-display: swap;
    }

    /* Digit reference table */
    /* Keep the "nanpa-linja-n proper name" column from stretching */
    .digitTable {
      table-layout: fixed; /* enables predictable column widths */
    }

    .digitTable th:nth-child(2),
    .digitTable td:nth-child(2) {
      width: 320px;          /* adjust to taste */
      max-width: 320px;
      white-space: normal;
      overflow-wrap: anywhere;

    }


    .digitTable th,
    .digitTable td {
      border: 1px solid var(--border);
      padding: 8px;
      vertical-align: middle;
    }

    .digitTable th {
      text-align: left;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }

    .digitTable td {
      font-size: 13px;
    }

    .digitCanvas {
      display: block;
      /* canvas width/height is set by your renderer; this just prevents layout weirdness */
      max-width: 100%;
    }

  </style>

</head>

<body>
  <div class="card">

    <!-- NEW: link to main branch README -->
    <div class="small" style="margin-bottom:10px;">
      <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
        nanpa-linja-n main documentation
      </a>
    </div>

    <div class="small" style="margin-bottom:10px;">
      <a class="repoLink" href="./calculator.html" target="_blank" rel="noopener noreferrer">
        nanpa-linja-n cartouche calculator
      </a>
    </div>

    <h1 style="margin:0 0 6px;font-size:18px;">Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer</h1>
    

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> The “nanpa-linja-n proper name” shown here is an encoding label for numbers only.
      It is intended as a proper-name style identifier and does not propose or add any new Toki Pona lexicon.
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
    </div>

    <div class="help" style="margin-top:10px;">Inputs are treated as text to preserve formatting (e.g., trailing zeros).</div>

    <div class="row" style="margin-top:14px;">
      <div class="col">
        <label for="decimalInput">Decimal value</label>
        <input id="decimalInput" type="text" class="mono" value="28.95" maxlength="500" />
        <div class="help">
          Example formats: <span class="mono">0.00</span>, <span class="mono">.75</span>, <span class="mono">-12.340</span>, <span class="mono">9+3/4</span>, <span class="mono">64.5M</span>.
          nanpa-linja-n encoder decides how to represent these.
        </div>
      </div>

      <div style="flex: 0 0 auto;">
        <button id="btnEncode">Encode & Render</button>
      </div>
    </div>

    <div class="out">
      <h3>nanpa-linja-n proper name for decimal value</h3>
      <textarea id="latinOut" class="mono" readonly></textarea>
      <div class="help">This is the Latin string you generate from the decimal input (nanpa-linja-n custom encoding). Spaces here will NOT affect glyph mapping.</div>

      <h3>nanpa-linja-n unique number code</h3>
      <textarea id="numberCodeOut" class="mono" readonly></textarea>
      <div class="help">Derived from the nanpa-linja-n proper name: remove letters <span class="mono">n</span> and <span class="mono">e</span>, uppercase everything else.</div>


      <div id="hexSection" class="hidden">
        <h3>Code points (hex)</h3>
        <textarea id="codepointsOut" class="mono" readonly></textarea>
        <div class="help">
          Space-separated hex code points (e.g., <span class="mono">F190B F1944 ...</span>) that nasin nanpa font uses.
        </div>
      </div>


      <h3>Toki Pona words (for code points)</h3>
      <textarea id="tpWordsOut" class="mono" readonly></textarea>
      <div class="help">
        One Toki Pona word per code point, in the same order as the code points output.
      </div>

      <!-- CHANGED: small above large (swap order) -->
      <div class="grid2" style="margin-top:14px;">
        <div>
          <h3>sitelen pona cartouche (small)</h3>
          <canvas id="canvasSmall"></canvas>
          <div class="help">Rendered with your font at a smaller size.</div>
        </div>
        <div>
          <h3>ditelen pona cartouche (large)</h3>
          <canvas id="canvasLarge"></canvas>
          <div class="help">Rendered with your font at a large size.</div>
        </div>
      </div>

      <h3 style="margin-top:20px;">Reverse tool: Toki Pona words → glyphs</h3>

      <div id="fromCodesSection" class="hidden">
        <div class="row">
          <div class="col">
            <label for="codepointsIn">Paste code points (hex, space-separated)</label>
            <input id="codepointsIn" type="text" class="mono" placeholder="F190B F1944 F193D" maxlength="3500"/>
            <div class="help">
              Accepts <span class="mono">F190B</span> or <span class="mono">U+F190B</span>.
              Input is restricted to the Toki Pona UCSUR block (<span class="mono">F1900</span>–<span class="mono">F1988</span>).
            </div>
          </div>
          <div style="flex: 0 0 auto;">
            <button id="btnFromCodes">Render From Code Points</button>
          </div>
        </div>
      </div>


      <!-- NEW: words input WORD_TO_UCSUR_CP map -->
      <div class="row" style="margin-top:10px;">
        <div class="col">
          <label for="tpWordsIn">Enter Toki Pona words (space-separated)</label>
          <input id="tpWordsIn" type="text" class="mono" placeholder="nanpa esun o nanpa" maxlength="2500"/>
          <div class="help">
            Only valid Toki Pona words are allowed (case-insensitive) or a nanpa-linja-n proper name for a decimal value.
          </div>
        </div>
        <div style="flex: 0 0 auto;">
          <button id="btnFromWords">Render From Toki Pona Words</button>
        </div>
      </div>

      <h3 style="margin-top:20px;">Digit reference: 0–9</h3>
      <div class="help">Digit, its nanpa-linja-n proper name, its nanpa-linja-n unique number code, and a tiny mixed-font cartouche.</div>

      <table class="digitTable" id="digitTable">
        <thead>
          <tr>
            <th style="width:80px;">Digit</th>
            <th>nanpa-linja-n proper name</th>
            <th>nanpa-linja-n unique number code</th>
            <th style="width:220px;">sitelen pona cartouche</th>
          </tr>
        </thead>
        <tbody id="digitTableBody">
          <!-- rows generated by JS -->
        </tbody>
      </table>

      <div class="help">#~n</div>
    </div>
  </div>

  <script>
    "use strict";


    


    /* ============================================================
       Vulgar fraction input support (e.g., 9¾, ¾, ⅜, etc.)
       Normalizes to forms your existing parser already supports:
         "¾"   -> "3/4"
         "9¾"  -> "9+3/4"
         "-9¾" -> "-9+-3/4"   (so it means -(9 + 3/4))
       Also converts fraction slash "⁄" (U+2044) to "/".
       ============================================================ */

    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]], // optional: "0/3"
    ]);


    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      // Normalize fraction slash "⁄" to "/"
      s = s.replace(/\u2044/g, "/");

      // Fast exit if no vulgar fraction char present
      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return s;

      // Only support a SINGLE vulgar fraction character, and it must be last
      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
      }
      // Disallow any '-' not at the very start (your rule)
      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      // Case: just "¾"
      if (!prefixRaw) return `${num}/${den}`;

      // Handle leading negative sign: "-9¾" -> "-9+3/4", "-¾" -> "-3/4"
      const isNeg = prefixRaw.startsWith("-");
      const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

      if (!prefix) {
        // "-¾"
        return `-${num}/${den}`;
      }

      // Allow optional space: "9 ¾" already collapses via trim logic
      const normalized = isNeg
        ? `-${prefix}+${num}/${den}`
        : `${prefix}+${num}/${den}`;

      // Final safety: enforce "only one '-' and only at start"
      if (normalized.slice(1).includes("-")) {
        throw new Error("Normalization produced an invalid negative sign placement.");
      }

      return normalized;
    }

    /* ============================================================
       MAPPING: Latin "glyph-string" chars -> font code points
       ============================================================ */

    const FONT_FAMILY = "TP-Cartouche-Font";

    // Placeholder mapping remains, but the main pipeline does NOT depend on it.
    const LATIN_CHAR_TO_CODEPOINT = {
      "0": 0xF1901,
      "1": 0xF1901,
      "2": 0xF1901,
      "3": 0xF1901,
      "4": 0xF1901,
      "5": 0xF190B,
      "6": 0xF1901,
      "7": 0xF1901,
      "8": 0xF1901,
      "9": 0xF1901,
      ".": 0xF1901,
      "-": 0xF1901,
    };

    const CODEPOINT_TO_LATIN_CHAR = new Map(
      Object.entries(LATIN_CHAR_TO_CODEPOINT).map(([ch, cp]) => [cp, ch])
    );

    // --- SMALL glyph set mirrors your Python SMALL_UNC_CHARS_CODES ---
    function getSmallCodepointsSet() {
      return new Set([
        0xF193D, // NANPA
        0xF1940, // NENA
        0xF1941, // NI
        0xF193E, // NASA
        0xF1909, // E
        0xF190B, // ESUN
      ]);
    }

    /* ============================================================
       RESTRICT allowed input code points to your defined TP UCSUR range
       UNC_CODES_TO_WORDS_MAP shows F1900 .. F1988 inclusive.
       ============================================================ */

    const TP_UCSUR_MIN = 0xF1900;
    const TP_UCSUR_MAX = 0xF1988;

    function isAllowedTpUcsurCodepoint(cp) {
      return Number.isInteger(cp) && cp >= TP_UCSUR_MIN && cp <= TP_UCSUR_MAX;
    }

    function assertAllAllowedTpUcsur(codepoints) {
      for (const cp of codepoints) {
        if (!isAllowedTpUcsurCodepoint(cp)) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(
            `Disallowed code point U+${hex}. Allowed range is U+${TP_UCSUR_MIN.toString(16).toUpperCase()}..U+${TP_UCSUR_MAX.toString(16).toUpperCase()}.`
          );
        }
      }
    }

    /* ============================================================
       PYTHON-ALGORITHM PORT (core pieces)
       ============================================================ */

    const DIGIT_TO_TOKEN = {
      "0": "NI",
      "1": "WE",
      "2": "TE",
      "3": "SE",
      "4": "NA",
      "5": "LE",
      "6": "NU",
      "7": "ME",
      "8": "PE",
      "9": "JE",
    };

    const TOKEN_TO_DIGIT_WORD = {
      "NI": "ijo",
      "WE": "wan",
      "TE": "tu",
      "SE": "sijelo",
      "NA": "ante",
      "LE": "luka",
      "NU": "utala",
      "ME": "mun",
      "PE": "pipi",
      "JE": "jo",
    };

    const OPCHAR_TO_TOKEN = {
      ".": "NONE",
      "-": "NO",
      "/": "NONO",
      "+": "NONONO",
    };

    const MAGCHAR_TO_TOKEN = {
      "T": "KE",
      "M": "KEKE",
      "W": "KEKEKE",
    };

    const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));

    const TOKEN_PREFIXES = [
      "KEKEKE",
      "KEKE",
      "KE",
      "NONONO",
      "NONO",
      "NE",
      "NO",
    ];

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar=",") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      const groupedFrac = groups.join(sepChar);
      return `${left}${decimalChar}${groupedFrac}${suffix}`;
    }

    function latinNameToNumberCode(latinName) {
      const s = String(latinName ?? "");
      // Remove spaces, then remove n/N and e/E, then uppercase the rest.
      const noSpaces = s.replace(/\s+/g, "");
      const withoutNE = noSpaces.replace(/[nNeE]/g, "");
      return "#~" + withoutNE.toUpperCase();
    }

    function normalizeLooseSeparators(raw) {
      // Collapses runs of spaces and runs of hyphens (after the leading minus, if any).
      // Leading '-' is preserved as a minus sign.
      if (raw == null) return "";
      let s = String(raw);

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      // Collapse whitespace runs and hyphen runs
      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    function numberStrToNanpaCaps(
      s,
      {
        thousandsChar = ",",
        groupFractionTriplets = false,
        fractionGroupSize = 3,
      } = {}
    ) {
      if (s == null) throw new Error("s must be a string, not null");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, thousandsChar);
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        // Helper: collapse consecutive separators into one NENE
        function pushNene() {
          if (out.length > 0 && out[out.length - 1] === "NENE") return;
          out.push("NENE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount = (last === "T") ? 1 : (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        // NEW: if integer part contains spaces or internal hyphens, treat them as separators => NENE
        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          // Trim leading/trailing separators inside the integer part
          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) {
              out.push(DIGIT_TO_TOKEN[ch]);
              continue;
            }
            if (ch === " " || ch === "-") {
              pushNene();
              continue;
            }
            // If you want comma to act as separator under loose-sep mode:
            if (thousandsChar && ch === thousandsChar) {
              pushNene();
              continue;
            }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          // Existing comma-group logic unchanged
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];

          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) {
              throw new Error(`Invalid integer group "${g}" in "${s}"`);
            }
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NEKE");
            for (const d of groups[idx]) out.push(DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            for (let i = 0; i < trailingZeroGroups; i++) out.push("KE");
          }
        }

        if (hasDecimal) {
          out.push(OPCHAR_TO_TOKEN["."]);

          // NEW: spaces/hyphens in fraction part become separators => NENE
          for (const ch of fracPart) {
            if (ch === "_" ) continue;

            if (ch === " " || ch === "-") {
              pushNene();
              continue;
            }

            if (thousandsChar && ch === thousandsChar) {
              pushNene();
              continue;
            }

            if (/\d/.test(ch)) {
              out.push(DIGIT_TO_TOKEN[ch]);
              continue;
            }

            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          for (let i = 0; i < magnitudeSuffixKeCount; i++) out.push("KE");
        }

        out.push("N");
        return out.join("");
      }


      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
      }

      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);
        return numCaps + "NONO" + denCaps;
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const n = s.length;

      while (i < n - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) {
          tokens.push(matched);
          i += matched.length;
          continue;
        }

        if (i + 2 <= n - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) {
            tokens.push(two);
            i += 2;
            continue;
          }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    function nanpaCapsTokensToTpWords(tokens) {
      if (!tokens || tokens.length === 0) return [];

      const out = [];

      const E_WORD = "esun";
      const E_WORD_FOR_NE_AFTER_START = "e";
      const N_WORD = "nasa";
      const N_WORD_DECIMAL_POINT = "ni";
      const N_WORD_FRACTION = "nena";
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) {
            out.push("nanpa", E_WORD);
            afterStartingNe = true;
          } else {
            out.push(N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
          }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD);
          continue;
        }

        if (t === "NO") {
          if (afterStartingNe) {
            out.push(N_WORD, "o");
            afterStartingNe = false;
          } else {
            let nWordToUse = N_WORD_DECIMAL_POINT;
            const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
            const prev = (i - 1 > 0) ? tokens[i - 1] : null;
            if (prev === "NO" || nxt === "NO") nWordToUse = N_WORD_FRACTION;
            out.push(nWordToUse, "o");
            afterStartingNe = false;
          }
          continue;
        }

        if (t === "NONO") { out.push("nena","o","nena","o"); afterStartingNe=false; continue; }
        if (t === "NONONO") { out.push("nasa","o","nasa","o","nasa","o"); afterStartingNe=false; continue; }

        if (t === "KE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }


    // Replace your existing WORD_TO_UCSUR_CP with this full UCSUR block mapping.
    const WORD_TO_UCSUR_CP = {
      //words used by decimal value cartouche
      "nanpa": 0xF193D,
      "esun":  0xF190B,
      "e":     0xF1909,
      "nasa":  0xF193E,
      "ni":    0xF1941,
      "nena":  0xF1940,
      "o":     0xF1944,
      "kulupu":0xF191F,

      //digits to first letter mappings
      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "sijelo":0xF195B,
      "ante":  0xF1906,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913,



      // F1900..F1977 (core)
      "a": 0xF1900,
      "akesi": 0xF1901,
      "ala": 0xF1902,
      "alasa": 0xF1903,
      "ale": 0xF1904,
      // Optional alias (common spelling variant):
      "ali": 0xF1904,

      "anpa": 0xF1905,
      //"ante": 0xF1906,
      "anu": 0xF1907,
      "awen": 0xF1908,
      //"e": 0xF1909,
      "en": 0xF190A,
      //"esun": 0xF190B,
      //"ijo": 0xF190C,
      "ike": 0xF190D,
      "ilo": 0xF190E,
      "insa": 0xF190F,
      "jaki": 0xF1910,
      "jan": 0xF1911,
      "jelo": 0xF1912,
      //"jo": 0xF1913,
      "kala": 0xF1914,
      "kalama": 0xF1915,
      "kama": 0xF1916,
      "kasi": 0xF1917,
      "ken": 0xF1918,
      "kepeken": 0xF1919,
      "kili": 0xF191A,
      "kiwen": 0xF191B,
      "ko": 0xF191C,
      "kon": 0xF191D,
      "kule": 0xF191E,
      //"kulupu": 0xF191F,
      "kute": 0xF1920,
      "la": 0xF1921,
      "lape": 0xF1922,
      "laso": 0xF1923,
      "lawa": 0xF1924,
      "len": 0xF1925,
      "lete": 0xF1926,
      "li": 0xF1927,
      "lili": 0xF1928,
      "linja": 0xF1929,
      "lipu": 0xF192A,
      "loje": 0xF192B,
      "lon": 0xF192C,
      //"luka": 0xF192D,
      "lukin": 0xF192E,
      "lupa": 0xF192F,
      "ma": 0xF1930,
      "mama": 0xF1931,
      "mani": 0xF1932,
      "meli": 0xF1933,
      "mi": 0xF1934,
      "mije": 0xF1935,
      "moku": 0xF1936,
      "moli": 0xF1937,
      "monsi": 0xF1938,
      "mu": 0xF1939,
      //"mun": 0xF193A,
      "musi": 0xF193B,
      "mute": 0xF193C,
      //"nanpa": 0xF193D,
      //"nasa": 0xF193E,
      "nasin": 0xF193F,
      //"nena": 0xF1940,
      //"ni": 0xF1941,
      "nimi": 0xF1942,
      "noka": 0xF1943,
      //"o": 0xF1944,
      "olin": 0xF1945,
      "ona": 0xF1946,
      "open": 0xF1947,
      "pakala": 0xF1948,
      "pali": 0xF1949,
      "palisa": 0xF194A,
      "pan": 0xF194B,
      "pana": 0xF194C,
      "pi": 0xF194D,
      "pilin": 0xF194E,
      "pimeja": 0xF194F,
      "pini": 0xF1950,
      //"pipi": 0xF1951,
      "poka": 0xF1952,
      "poki": 0xF1953,
      "pona": 0xF1954,
      "pu": 0xF1955,
      "sama": 0xF1956,
      "seli": 0xF1957,
      "selo": 0xF1958,
      "seme": 0xF1959,
      "sewi": 0xF195A,
      //"sijelo": 0xF195B,
      "sike": 0xF195C,
      "sin": 0xF195D,
      "sina": 0xF195E,
      "sinpin": 0xF195F,
      "sitelen": 0xF1960,
      "sona": 0xF1961,
      "soweli": 0xF1962,
      "suli": 0xF1963,
      "suno": 0xF1964,
      "supa": 0xF1965,
      "suwi": 0xF1966,
      "tan": 0xF1967,
      "taso": 0xF1968,
      "tawa": 0xF1969,
      "telo": 0xF196A,
      "tenpo": 0xF196B,
      "toki": 0xF196C,
      "tomo": 0xF196D,
      //"tu": 0xF196E,
      "unpa": 0xF196F,
      "uta": 0xF1970,
      //"utala": 0xF1971,
      "walo": 0xF1972,
      //"wan": 0xF1973,
      "waso": 0xF1974,
      "wawa": 0xF1975,
      "weka": 0xF1976,
      "wile": 0xF1977,

      // F1978..F1988 (additional UCSUR assignments commonly associated with ku)
      "namako": 0xF1978,
      "kin": 0xF1979,
      "oko": 0xF197A,
      "kipisi": 0xF197B,
      "leko": 0xF197C,
      "monsuta": 0xF197D,
      "tonsi": 0xF197E,
      "jasima": 0xF197F,
      "kijetesantakalu": 0xF1980,
      "soko": 0xF1981,
      "meso": 0xF1982,
      "epiku": 0xF1983,
      "kokosila": 0xF1984,
      "lanpan": 0xF1985,
      "n": 0xF1986,
      "misikeke": 0xF1987,
      "ku": 0xF1988,
    };




/* =========================
   2) JS: ADD these helpers near WORD_TO_UCSUR_CP (right after it is declared is ideal)
   ========================= */

    // Build reverse map: code point -> word
    const UCSUR_CP_TO_WORD = new Map(
    Object.entries(WORD_TO_UCSUR_CP).map(([w, cp]) => [cp, w])
    );

    // Convert code points to words (best-effort; throws if unknown)
    function ucsurCodepointsToTpWords(codepoints) {
      const words = [];
      for (const cp of codepoints) {
        const w = UCSUR_CP_TO_WORD.get(cp);
        if (!w) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(`No Toki Pona word mapping for code point U+${hex}`);
        }
        words.push(w);
      }
      return words;
    }

    function tpWordsToText(words) {
      return (words ?? []).join(" ");
    }

      // Parse user-entered words (space-separated), validate against WORD_TO_UCSUR_CP, return codepoints
    function parseTpWordsToCodepoints(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return [];

      // Split on whitespace
      const parts = raw.split(/\s+/).filter(Boolean);

      const cps = [];
      for (const p of parts) {
        const w = p.toLowerCase();

        // validate strictly: only words in mapping
        const cp = WORD_TO_UCSUR_CP[w];
        if (cp == null) {
          throw new Error(`Invalid Toki Pona word "${p}". Only mapped words are allowed.`);
        }

        cps.push(cp);
      }

      // Defensive: ensure in your allowed block
      assertAllAllowedTpUcsur(cps);

      return cps;
    }

    function tpWordsToUcsurCodepoints(words) {
      const cps = [];
      for (const w of words) {
        const key = String(w).toLowerCase();
        const cp = WORD_TO_UCSUR_CP[key];
        if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
        cps.push(cp);
      }
      return cps;
    }

    function decimalToUcsurCodepoints(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return [];

      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens);
      const cps = tpWordsToUcsurCodepoints(tpWords);

      // Defensive: ensure we never emit code points outside your defined block.
      assertAllAllowedTpUcsur(cps);

      return cps;
    }

    function splitCartoucheCapsLetters(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      let outStr = "";
      let i = 0;
      const end = s0.length - 1;

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);
        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { outStr += "neno "; i += 4; continue; }
        if (pair === "NE" && nextPair === "NE") { outStr += "n "; outStr += "ene "; i += 4; continue; }
        if (pair === "NO" && nextPair === "NE" && i > 0) { outStr += "n "; outStr += "one "; i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          outStr += "n ";
          outStr += "o";
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          outStr += "no".repeat(countNo);
          if ((i + 2 * countNo) < end) outStr += " ";
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          outStr += "n ";
          outStr += "e";
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          outStr += "ke".repeat(countKe);
          if ((i + 2 * countKe) < end) outStr += " ";
          i += 2 + 2 * countKe;
          continue;
        }

        outStr += pair.toLowerCase();
        i += 2;
      }

      outStr = outStr.trim();
      outStr += "n";
      return outStr;
    }

    function encodeDecimalToLatin(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return "";
      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });
      return splitCartoucheCapsLetters(caps);
    }

    // Validate whether a (possibly messy) string could be a nanpa-linja-n proper name.
    // Rule: we ignore whitespace entirely, then require that the remaining characters
    // correspond to a valid nanpa-caps string (tokenizable by tokenizeNanpaCaps).
    function isValidNanpaLinjanProperName(raw) {
      // 1) Normalize: lowercase, strip ALL whitespace
      const s = String(raw ?? "")
        .toLowerCase()
        .replace(/\s+/g, "");

      if (!s) return false;

      // 2) Must be letters only after whitespace is removed
      if (!/^[a-z]+$/.test(s)) return false;

      // 3) Proper names always end with the final terminator 'n' (lowercase)
      if (!s.endsWith("n")) return false;

      // 4) Remove final terminator; remaining length must be even (two-letter chunks)
      const core = s.slice(0, -1);
      if (core.length < 2 || (core.length % 2) !== 0) return false;

      // 5) Reconstruct caps and validate using your existing tokenizer
      //    (core is effectively the caps body lowercased; add final 'N' terminator)
      const caps = core.toUpperCase() + "N";

      // Fast sanity checks (optional but cheap)
      if (!caps.startsWith("NE")) return false;

      try {
        tokenizeNanpaCaps(caps); // throws if invalid
        return true;
      } catch {
        return false;
      }
    }


    // Like splitCartoucheCapsLetters(), but inserts spaces ONLY around delimiters
    // (ene / one / o... / eke... / initial neno). Digit runs stay contiguous.
    // Also: final terminator 'n' is always attached to the last chunk.
    function splitCartoucheCapsLettersSpaced(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      const parts = [];
      let current = "";
      let i = 0;
      const end = s0.length - 1; // exclude final 'N'

      function flushCurrent() {
        if (current) {
          parts.push(current);
          current = "";
        }
      }

      // Attach a delimiter-leading "n" to the immediately preceding chunk (no extra spaces).
      function attachDelimiterN() {
        if (current) {
          current += "n";
          flushCurrent();
          return;
        }
        if (parts.length === 0) {
          parts.push("n"); // should be rare, but keeps behavior defined
          return;
        }
        parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      }

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);

        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        // Initial "NE NO" at start -> "neno" as its own chunk
        if (pair === "NE" && nextPair === "NO" && i === 0) {
          flushCurrent();
          parts.push("neno");
          i += 4;
          continue;
        }

        // "NE NE" -> attach 'n' to previous, then add "ene"
        if (pair === "NE" && nextPair === "NE") {
          flushCurrent();
          attachDelimiterN();
          parts.push("ene");
          i += 4;
          continue;
        }

        // "NO NE" (i>0) -> attach 'n' to previous, then add "one"
        if (pair === "NO" && nextPair === "NE" && i > 0) {
          flushCurrent();
          attachDelimiterN();
          parts.push("one");
          i += 4;
          continue;
        }

        // "NO NO..." (i>0) -> attach 'n' to previous, then add "o"+"no"*count
        if (pair === "NO" && nextPair === "NO" && i > 0) {
          flushCurrent();
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") {
            countNo += 1;
            j += 2;
          }
          attachDelimiterN();
          parts.push("o" + "no".repeat(countNo));
          i += 2 + 2 * countNo;
          continue;
        }

        // "NE KE..." -> attach 'n' to previous, then add "e"+"ke"*count (eke, ekeke, ...)
        if (pair === "NE" && nextPair === "KE") {
          flushCurrent();
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") {
            countKe += 1;
            j += 2;
          }
          attachDelimiterN();
          parts.push("e" + "ke".repeat(countKe));
          i += 2 + 2 * countKe;
          continue;
        }

        // Default: keep contiguous (digits/pairs not split)
        current += pair.toLowerCase();
        i += 2;
      }

      flushCurrent();

      // Final terminator 'n' always attached to the last chunk (no separate space)
      if (parts.length === 0) return "n";
      parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";

      return parts.join(" ").replace(/\s+/g, " ").trim();
    }




    function nanpaLinjanProperNameToUcsurCodepoints(nameStr) {
      // Remove whitespace, lowercase, must end with 'n'
      const s = String(nameStr ?? "").toLowerCase().replace(/\s+/g, "");
      if (!s || !s.endsWith("n")) throw new Error("Not a nanpa-linja-n proper name (missing final 'n').");

      // Convert proper-name core to nanpa-caps (re-add final terminator as 'N')
      const core = s.slice(0, -1);
      const caps = core.toUpperCase() + "N";

      // Validate and convert caps -> tokens -> TP words -> UCSUR codepoints
      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens);
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }


    function codepointsToHexString(codepoints) {
      return codepoints.map(cp => cp.toString(16).toUpperCase().padStart(4, "0")).join(" ");
    }

    function parseHexCodepoints(input) {
      const raw = input.trim();
      if (!raw) return [];
      const parts = raw.split(/\s+/).map(s => s.replace(/^U\+/i, ""));
      const cps = parts.map(p => {
        const cp = parseInt(p, 16);
        if (!Number.isFinite(cp)) throw new Error(`Invalid hex code point: "${p}"`);
        return cp;
      });

      // NEW: restriction to your defined Toki Pona UCSUR range
      assertAllAllowedTpUcsur(cps);

      return cps;
    }

    /* =======================
       Cartouche rendering
       ======================= */

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function renderMixedCartoucheToCanvas(canvas, codepoints, largePx, smallPx, smallCodepoints, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        const px = smallCodepoints.has(cp) ? smallPx : largePx;

        ctx.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";

      for (const g of glyphRuns) {
        ctx2.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }

      return { cartW, cartH, textW: totalWidth, textH: textHeight, maxAscent, maxDescent };
    }

    function renderUniformCartoucheFromCodepoints(canvas, codepoints, fontPx, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);

        ctx.font = `${fontPx}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(fontPx * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(fontPx * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, left, tightW });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";
      ctx2.font = `${fontPx}px "${FONT_FAMILY}"`;

      for (const g of glyphRuns) {
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }
    }

    async function ensureFontLoaded() {
      const sampleCp = 0xF190B; // ESUN
      const sampleChar = String.fromCodePoint(sampleCp);
      const fontSpec = `24px "${FONT_FAMILY}"`;

      function fallbackLikely(sampleText) {
        const c = document.createElement("canvas");
        const ctx = c.getContext("2d");
        ctx.font = `48px "${FONT_FAMILY}", monospace`;
        const w1 = ctx.measureText(sampleText).width;
        ctx.font = `48px monospace`;
        const w2 = ctx.measureText(sampleText).width;
        return w1 === w2;
      }

      if (!document.fonts || !document.fonts.load || !document.fonts.check) {
        console.warn("[font] CSS Font Loading API not available; cannot reliably validate load.");
        return;
      }

      try {
        await document.fonts.load(fontSpec, sampleChar);
        await document.fonts.ready;

        const ok = document.fonts.check(fontSpec, sampleChar);
        if (!ok) {
          console.warn(`[font] NOT CONFIRMED: ${fontSpec}`);
          console.warn("[font] If opening via file://, use Live Server / http://localhost to avoid font load restrictions.");
        }

        if (fallbackLikely(sampleChar)) {
          console.warn("[font] fallback likely (width matches monospace). Font may not have the glyph, or did not load.");
        }
      } catch (e) {
        console.error("[font] load threw error:", e);
      }
    }

    /* =======================
       UI wiring
       ======================= */

    const LETTER_SPACING_GAP = 4;

    const LARGE_FONT_SIZE = 72;
    const SMALL_FONT_SIZE = 20;

    const LARGE_TINY_FONT_SIZE = 40;
    const SMALL_TINY_FONT_SIZE = 10;

    const elDecimal = document.getElementById("decimalInput");
    const elLatinOut = document.getElementById("latinOut");
    const elCodepointsOut = document.getElementById("codepointsOut");
    const elNumberCodeOut = document.getElementById("numberCodeOut");


    // NOTE: variables keep same IDs; order on page is swapped via HTML above
    const canvasLarge = document.getElementById("canvasLarge");
    const canvasSmall = document.getElementById("canvasSmall");

    const elCodesIn = document.getElementById("codepointsIn");

    /* =========================
   3) JS: Wire up new output textarea + new input + new button
   Put these with your other element lookups and handlers.
   ========================= */

    // ADD this element lookup with the others:
    const elTpWordsOut = document.getElementById("tpWordsOut");

    // ADD this lookup (new input):
    const elTpWordsIn = document.getElementById("tpWordsIn");

    const MAX_DECIMAL_INPUT_CHARS = 500;
    const MAX_HEX_CODE_INPUT_CHARS = 3500;
    const MAX_TOKI_PONA_WORD_INPUT_CHARS = 2500;

    function enforceMaxLen(el, maxLen = MAX_DECIMAL_INPUT_CHARS) {
      if (!el) return;
      const s = String(el.value ?? "");
      if (s.length > maxLen) el.value = s.slice(0, maxLen);
    }

    // Enforce at load time (in case of prefilled values)
    enforceMaxLen(elDecimal,  MAX_DECIMAL_INPUT_CHARS);
    enforceMaxLen(elCodesIn,  MAX_HEX_CODE_INPUT_CHARS);
    enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

    // Enforce while typing/pasting
    if (elDecimal) {
      elDecimal.addEventListener("input", () => enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS));
    }
    if (elCodesIn) {
      elCodesIn.addEventListener("input", () => enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS));
    }
    if (elTpWordsIn) {
      elTpWordsIn.addEventListener("input", () => enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS));
    }


    const elDigitTableBody = document.getElementById("digitTableBody");

    function buildDigitReferenceTable() {
      if (!elDigitTableBody) return;

      // Clear existing rows (safe if called multiple times)
      elDigitTableBody.innerHTML = "";

      const smallSet = getSmallCodepointsSet();

      // Tiny cartouche sizing (mixed fonts)
      const TINY_LARGE_PX = 22;
      const TINY_SMALL_PX = 8;

      for (let d = 0; d <= 9; d++) {
        const digitStr = String(d);

        // nanpa-linja-n name (Latin output)
        const latinName = encodeDecimalToLatin(digitStr);

        // Code points for cartouche rendering
        const cps = decimalToUcsurCodepoints(digitStr);

        // nanpa-linja-n unique name
        const unique_number_code = latinNameToNumberCode(latinName);

        // Build row
        const tr = document.createElement("tr");

        const tdDigit = document.createElement("td");
        tdDigit.className = "mono";
        tdDigit.textContent = digitStr;

        const tdName = document.createElement("td");
        tdName.className = "mono";
        tdName.textContent = latinName;

        const tdUniqueNumberCode = document.createElement("td");
        tdUniqueNumberCode.className = "mono";
        tdUniqueNumberCode.textContent = unique_number_code;

        const tdCanvas = document.createElement("td");
        const canvas = document.createElement("canvas");
        canvas.className = "digitCanvas";
        tdCanvas.appendChild(canvas);

        tr.appendChild(tdDigit);
        tr.appendChild(tdName);
        tr.appendChild(tdUniqueNumberCode);
        tr.appendChild(tdCanvas);

        elDigitTableBody.appendChild(tr);

        // Render tiny mixed-font cartouche
        renderMixedCartoucheToCanvas(
          canvas,
          cps,
          TINY_LARGE_PX,
          TINY_SMALL_PX,
          smallSet,
          {
            padding: 8,
            border: 1,
            cornerRadius: 10,
            letterGap: 2,
          }
        );
      }
    }



    document.getElementById("btnEncode").addEventListener("click", async () => {
      try {
        await ensureFontLoaded();
        enforceMaxLen(elDecimal,  MAX_DECIMAL_INPUT_CHARS);

        const raw = normalizeVulgarFractionInput(elDecimal.value);
        const latin = encodeDecimalToLatin(raw);
        elLatinOut.value = latin;
        elNumberCodeOut.value = latinNameToNumberCode(latin);

        const cps = decimalToUcsurCodepoints(raw);
        elCodepointsOut.value = codepointsToHexString(cps);
        elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));


        const smallSet = getSmallCodepointsSet();

        // CHANGED: small canvas first, then large (mirrors your UI request)
        renderMixedCartoucheToCanvas(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          SMALL_TINY_FONT_SIZE,
          smallSet,
          { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
        );

        renderMixedCartoucheToCanvas(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          SMALL_FONT_SIZE,
          smallSet,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

      } catch (err) {
        alert(err?.message ?? String(err));
      }
    });

    document.getElementById("btnFromCodes").addEventListener("click", async () => {
      try {
        await ensureFontLoaded();
        enforceMaxLen(elCodesIn,  MAX_HEX_CODE_INPUT_CHARS);

        const cps = parseHexCodepoints(elCodesIn.value);

        // Show direct UCSUR glyphs in LatinOut (best-effort)
        elLatinOut.value = String.fromCodePoint(...cps);
        elCodepointsOut.value = codepointsToHexString(cps);
        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);
        elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));


        // Small then large (uniform)
        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

      } catch (err) {
        alert(err?.message ?? String(err));
      }
    });

    // NEW BUTTON: add this event listener near the others:
    document.getElementById("btnFromWords").addEventListener("click", async () => {
      try {
        await ensureFontLoaded();
        enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

        const rawInput = String(elTpWordsIn.value ?? "");

        // If the WHOLE input is a nanpa-linja-n proper name, treat it as such.
        if (isValidNanpaLinjanProperName(rawInput)) {
          const cps = nanpaLinjanProperNameToUcsurCodepoints(rawInput);

          // Canonicalize + pretty-print with spacing around delimiters
          const compact = rawInput.toLowerCase().replace(/\s+/g, "");
          const core = compact.slice(0, -1);
          const caps = core.toUpperCase() + "N";

          // Outputs (spaced, readable proper name)
          const prettyName = splitCartoucheCapsLettersSpaced(caps);

          elLatinOut.value = prettyName;
          elNumberCodeOut.value = latinNameToNumberCode(prettyName);


          elCodepointsOut.value = codepointsToHexString(cps);
          elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

          // Mixed-font render (small then large)
          const smallSet = getSmallCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            smallSet,
            { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            smallSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          return; // IMPORTANT: do not fall through
        }

        // Otherwise, process as Toki Pona words (existing behavior)
        const cps = parseTpWordsToCodepoints(elTpWordsIn.value);

        // Show outputs
        elCodepointsOut.value = codepointsToHexString(cps);
        elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        // Show direct UCSUR glyphs in LatinOut (best-effort)
        elLatinOut.value = String.fromCodePoint(...cps);
        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);

        // Render (uniform)
        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

      } catch (err) {
        alert(err?.message ?? String(err));
      }
    });

    /* =========================
   4) OPTIONAL: make word input “only valid words” as the user types
   (Add this if you want immediate validation feedback.)
   ========================= */

    function validateTpWordsInputLive() {
      const raw = String(elTpWordsIn?.value ?? "").trim();
      if (!raw) { elTpWordsIn.setCustomValidity(""); return; }

      const parts = raw.split(/\s+/).filter(Boolean);
      for (const p of parts) {
        if (WORD_TO_UCSUR_CP[p.toLowerCase()] == null) {
          elTpWordsIn.setCustomValidity(`Invalid word: ${p}`);
          return;
        }
      }
      elTpWordsIn.setCustomValidity("");
    }

    if (elTpWordsIn) {
      elTpWordsIn.addEventListener("input", validateTpWordsInputLive);
    }


    window.addEventListener("load", async () => {
      await ensureFontLoaded();

      // Build the digit reference table (needs font loaded for correct measurements)
      buildDigitReferenceTable();

      document.getElementById("btnEncode").click();
    });

  </script>
</body>
</html>
