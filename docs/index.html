<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toki Pona → Cartouche Calculator</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;     /* unify background color */
      --muted: #3f4750;  /* CHANGED: darker for better contrast */
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .row { display: flex; gap: var(--gap); flex-wrap: wrap; align-items: flex-end; }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input[type="text"], textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg);
      font: inherit;
    }

    textarea { min-height: 84px; resize: vertical; }

    .col { flex: 1 1 320px; }

    button {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover {
      background: var(--bg);
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    .out { margin-top: 12px; }

    .out h3 { margin: 18px 0 8px; font-size: 14px; }

    canvas {
      display: block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: var(--bg);
      max-width: 100%;
    }

    .small { font-size: 12px; color: var(--muted); }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .hidden {
      display: none !important;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src: url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.otf") format("opentype");
      font-display: swap;
    }

    /* Digit reference table */
    .digitTable {
      table-layout: fixed;
      width: 100%;
      border-collapse: collapse;
    }

    .digitTable th:nth-child(2),
    .digitTable td:nth-child(2) {
      width: 320px;
      max-width: 320px;
      white-space: normal;
      overflow-wrap: anywhere;
    }

    .digitTable th,
    .digitTable td {
      border: 1px solid var(--border);
      padding: 8px;
      vertical-align: middle;
    }

    .digitTable th {
      text-align: left;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }

    .digitTable td {
      font-size: 13px;
    }

    .digitCanvas {
      display: block;
      max-width: 100%;
    }

    /* =========================
       WCAG-oriented affordances
       ========================= */

    /* Strong focus indicators */
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    textarea:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    /* Skip link (keyboard navigation) */
    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    /* Visually hidden but still accessible to screen readers */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: -1px !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    /* Prevent user agent forced color adjustments from destroying contrast in HC modes */
    .no-forced-adjust {
      forced-color-adjust: none;
    }
  </style>

</head>

<body>
  <!-- Skip link for keyboard users -->
  <a href="#main" class="skipLink">Skip to content</a>

  <!-- Main landmark for assistive tech -->
  <main class="card" id="main" role="main" aria-labelledby="pageTitle">

    <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">Toki Pona nanpa-linja-n main documentation</h1>
    <div class="small" style="margin-bottom:10px;">
      <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
        nanpa-linja-n main documentation
      </a>
    </div>

    <h1 style="margin:0 0 6px;font-size:18px;">Toki Pona nanpa-linja-n cartouche calculator</h1>
    <div class="small" style="margin-bottom:10px;">
      <a class="repoLink" href="./calculator.html" target="_blank" rel="noopener noreferrer">
        nanpa-linja-n cartouche calculator
      </a>
    </div>

    <h1 style="margin:0 0 6px;font-size:18px;">Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer</h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> The “nanpa-linja-n proper name” shown here is an encoding label for numbers only.
      It is intended as a proper-name style identifier and does not propose or add any new Toki Pona lexicon.
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
    </div>

    <div class="help" style="margin-top:10px;">Inputs are treated as text to preserve formatting (e.g., trailing zeros).</div>

    <!-- Screen-reader live region for status/errors -->
    <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <div class="row" style="margin-top:14px;" role="group" aria-label="Decimal input and encode action">
      <div class="col">
        <label for="decimalInput">Enter decimal value (in en-US locale format)</label>
        <input
          id="decimalInput"
          type="text"
          class="mono"
          value="28.95"
          maxlength="500"
          inputmode="text"
          aria-describedby="decimalHelp"
          aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge digitTable"
        />
        <div id="decimalHelp" class="help">
          Example formats: <span class="mono">0.00</span>; <span class="mono">.75</span>; <span class="mono">-12,340</span>;  <span class="mono">2000</span>; <span class="mono">5,000</span>; <span class="mono">9¾</span>; <span class="mono">8+1/2</span>; <span class="mono">7/8</span>; <span class="mono">64.5M</span>; <span class="mono">432-555-0189</span>.
          nanpa-linja-n encoder decides how to represent these.
        </div>
      </div>

      <div style="flex: 0 0 auto;">
        <button id="btnEncode" type="button" aria-describedby="btnEncodeHelp">
          Encode &amp; Render
        </button>
        <div id="btnEncodeHelp" class="sr-only">
          Encodes the decimal input into a nanpa-linja-n proper name and renders the sitelen pona cartouches below.
        </div>
      </div>
    </div>

    <div class="out" role="region" aria-label="Outputs">
      <h3>nanpa-linja-n proper name for decimal value</h3>
      <textarea id="latinOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">This is the Latin string you generate from the decimal input (nanpa-linja-n custom encoding). Spaces are added for readability and will NOT affect glyph mapping.</div>

      <h3>nanpa-linja-n unique number code</h3>
      <textarea id="numberCodeOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">Derived from the nanpa-linja-n proper name: remove letters <span class="mono">n</span> and <span class="mono">e</span>, uppercase everything else.</div>

      <div id="hexSection" class="hidden">
        <h3>Code points (hex)</h3>
        <textarea id="codepointsOut" class="mono" readonly aria-readonly="true"></textarea>
        <div class="help">
          Space-separated hex code points (e.g., <span class="mono">F190B F1944 ...</span>) that nasin nanpa font uses.
        </div>
      </div>

      <h3>Toki Pona words (for code points)</h3>
      <textarea id="tpWordsOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        One Toki Pona word per code point, in the same order as the code points output.
      </div>

      <!-- Canvases are decorative; authoritative text is the words/outputs above -->
      <div class="grid2" style="margin-top:14px;" role="group" aria-label="Cartouche renderings">
        <div>
          <h3>sitelen pona cartouche (small)</h3>
          <canvas id="canvasSmall" aria-hidden="true"></canvas>
          <div class="help">Rendered with your font at a smaller size.</div>
          <div class="sr-only" id="canvasSmallDesc">
            Decorative cartouche rendering. Use the text outputs above for the accessible value.
          </div>
        </div>
        <div>
          <h3>sitelen pona cartouche (large)</h3>
          <canvas id="canvasLarge" aria-hidden="true"></canvas>
          <div class="help">Rendered with your font at a large size.</div>
          <div class="sr-only" id="canvasLargeDesc">
            Decorative cartouche rendering. Use the text outputs above for the accessible value.
          </div>
        </div>
      </div>

      <h3 style="margin-top:20px;">Reverse tool: Toki Pona words → glyphs</h3>

      <div id="fromCodesSection" class="hidden">
        <div class="row" role="group" aria-label="Render from code points">
          <div class="col">
            <label for="codepointsIn">Paste code points (hex, space-separated)</label>
            <input
              id="codepointsIn"
              type="text"
              class="mono"
              placeholder="F190B F1944 F193D"
              maxlength="3500"
              aria-describedby="codepointsHelp"
              aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge"
            />
            <div id="codepointsHelp" class="help">
              Accepts <span class="mono">F190B</span> or <span class="mono">U+F190B</span>.
              Input is restricted to the Toki Pona UCSUR block (<span class="mono">F1900</span>–<span class="mono">F1988</span>).
            </div>
          </div>
          <div style="flex: 0 0 auto;">
            <button id="btnFromCodes" type="button">Render From Code Points</button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;" role="group" aria-label="Render from Toki Pona words">
        <div class="col">
          <label for="tpWordsIn">Enter Toki Pona words (space-separated)</label>
          <input
            id="tpWordsIn"
            type="text"
            class="mono"
            placeholder="nanpa esun o nanpa"
            maxlength="2500"
            aria-describedby="tpWordsHelp"
            aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge"
            spellcheck="false"
            autocapitalize="none"
            autocomplete="off"
          />
          <div id="tpWordsHelp" class="help">
            Only valid Toki Pona words are allowed (case-insensitive) or a nanpa-linja-n proper name for a decimal value.
          </div>
        </div>
        <div style="flex: 0 0 auto;">
          <button id="btnFromWords" type="button">Render From Toki Pona Words</button>
        </div>
      </div>

      <h3 style="margin-top:20px;">Digit reference: 0–9</h3>
      <div class="help">Digit, its nanpa-linja-n proper name, its nanpa-linja-n unique number code, and a sitelen pona mixed-font cartouche.</div>

      <table class="digitTable" id="digitTable">
        <caption class="sr-only">
          Reference table for digits 0 through 9, including nanpa-linja-n labels and decorative cartouches.
        </caption>
        <thead>
          <tr>
            <th scope="col" style="width:80px;">Digit</th>
            <th scope="col">nanpa-linja-n proper name</th>
            <th scope="col">nanpa-linja-n unique number code</th>
            <th scope="col" style="width:220px;">sitelen pona cartouche</th>
          </tr>
        </thead>
        <tbody id="digitTableBody">
          <!-- rows generated by JS -->
        </tbody>
      </table>

      <div class="help">#~n</div>
    </div>
  </main>

  <script>
    "use strict";

    /* ============================================================
       Accessibility helpers
       ============================================================ */

    const elSrStatus = document.getElementById("srStatus");

    function announceStatus(msg) {
      if (!elSrStatus) return;
      elSrStatus.textContent = String(msg ?? "");
    }

    function showAlertAndAnnounce(msg) {
      const s = String(msg ?? "Unknown error");
      announceStatus(s);
      alert(s);
    }

    /* ============================================================
       Vulgar fraction input support (e.g., 9¾, ¾, ⅜, etc.)
       ============================================================ */

    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]],
    ]);

    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      s = s.replace(/\u2044/g, "/");

      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return s;

      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
      }
      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      if (!prefixRaw) return `${num}/${den}`;

      const isNeg = prefixRaw.startsWith("-");
      const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

      if (!prefix) {
        return `-${num}/${den}`;
      }

      const normalized = isNeg
        ? `-${prefix}+${num}/${den}`
        : `${prefix}+${num}/${den}`;

      if (normalized.slice(1).includes("-")) {
        throw new Error("Normalization produced an invalid negative sign placement.");
      }

      return normalized;
    }

    /* ============================================================
       MAPPING: Latin "glyph-string" chars -> font code points
       ============================================================ */

    const FONT_FAMILY = "TP-Cartouche-Font";

    const LATIN_CHAR_TO_CODEPOINT = {
      "0": 0xF1901,
      "1": 0xF1901,
      "2": 0xF1901,
      "3": 0xF1901,
      "4": 0xF1901,
      "5": 0xF190B,
      "6": 0xF1901,
      "7": 0xF1901,
      "8": 0xF1901,
      "9": 0xF1901,
      ".": 0xF1901,
      "-": 0xF1901,
    };

    const CODEPOINT_TO_LATIN_CHAR = new Map(
      Object.entries(LATIN_CHAR_TO_CODEPOINT).map(([ch, cp]) => [cp, ch])
    );

    function getSmallCodepointsSet() {
      return new Set([
        0xF193D, // NANPA
        0xF1940, // NENA
        0xF1941, // NI
        0xF193E, // NASA
        0xF1909, // E
        0xF190B, // ESUN
      ]);
    }

    const TP_UCSUR_MIN = 0xF1900;
    const TP_UCSUR_MAX = 0xF1988;

    function isAllowedTpUcsurCodepoint(cp) {
      return Number.isInteger(cp) && cp >= TP_UCSUR_MIN && cp <= TP_UCSUR_MAX;
    }

    function assertAllAllowedTpUcsur(codepoints) {
      for (const cp of codepoints) {
        if (!isAllowedTpUcsurCodepoint(cp)) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(
            `Disallowed code point U+${hex}. Allowed range is U+${TP_UCSUR_MIN.toString(16).toUpperCase()}..U+${TP_UCSUR_MAX.toString(16).toUpperCase()}.`
          );
        }
      }
    }

    /* ============================================================
       PYTHON-ALGORITHM PORT (core pieces)
       ============================================================ */

    const DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    const TOKEN_TO_DIGIT_WORD = {
      "NI": "ijo", "WE": "wan", "TE": "tu", "SE": "sijelo", "NA": "ante",
      "LE": "luka", "NU": "utala", "ME": "mun", "PE": "pipi", "JE": "jo",
    };

    const OPCHAR_TO_TOKEN = { ".": "NONE", "-": "NO", "/": "NONO", "+": "NONONO" };
    const MAGCHAR_TO_TOKEN = { "T": "KE", "M": "KEKE", "W": "KEKEKE" };
    const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));

    const TOKEN_PREFIXES = [ "KEKEKE", "KEKE", "KE", "NONONO", "NONO", "NE", "NO" ];

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar=",") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      const groupedFrac = groups.join(sepChar);
      return `${left}${decimalChar}${groupedFrac}${suffix}`;
    }

    function latinNameToNumberCode(latinName) {
      const s = String(latinName ?? "");
      const noSpaces = s.replace(/\s+/g, "");
      const withoutNE = noSpaces.replace(/[nNeE]/g, "");
      return "#~" + withoutNE.toUpperCase();
    }

    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    function numberStrToNanpaCaps(
      s,
      { thousandsChar = ",", groupFractionTriplets = false, fractionGroupSize = 3 } = {}
    ) {
      if (s == null) throw new Error("s must be a string, not null");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, thousandsChar);
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          if (out.length > 0 && out[out.length - 1] === "NENE") return;
          out.push("NENE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount = (last === "T") ? 1 : (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NEKE");
            for (const d of groups[idx]) out.push(DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            for (let i = 0; i < trailingZeroGroups; i++) out.push("KE");
          }
        }

        if (hasDecimal) {
          out.push(OPCHAR_TO_TOKEN["."]);
          for (const ch of fracPart) {
            if (ch === "_" ) continue;
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          for (let i = 0; i < magnitudeSuffixKeCount; i++) out.push("KE");
        }

        out.push("N");
        return out.join("");
      }

      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
      }

      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);
        return numCaps + "NONO" + denCaps;
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const n = s.length;

      while (i < n - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= n - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    function nanpaCapsTokensToTpWords(tokens) {
      if (!tokens || tokens.length === 0) return [];

      const out = [];

      const E_WORD = "esun";
      const E_WORD_FOR_NE_AFTER_START = "e";
      const N_WORD = "nasa";
      const N_WORD_DECIMAL_POINT = "ni";
      const N_WORD_FRACTION = "nena";
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) { out.push("nanpa", E_WORD); afterStartingNe = true; }
          else { out.push(N_WORD, E_WORD_FOR_NE_AFTER_START); afterStartingNe = false; }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD);
          continue;
        }

        if (t === "NO") {
          if (afterStartingNe) {
            out.push(N_WORD, "o");
            afterStartingNe = false;
          } else {
            let nWordToUse = N_WORD_DECIMAL_POINT;
            const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
            const prev = (i - 1 > 0) ? tokens[i - 1] : null;
            if (prev === "NO" || nxt === "NO") nWordToUse = N_WORD_FRACTION;
            out.push(nWordToUse, "o");
            afterStartingNe = false;
          }
          continue;
        }

        if (t === "NONO") { out.push("nena","o","nena","o"); afterStartingNe=false; continue; }
        if (t === "NONONO") { out.push("nasa","o","nasa","o","nasa","o"); afterStartingNe=false; continue; }

        if (t === "KE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }

    const WORD_TO_UCSUR_CP = {
      "nanpa": 0xF193D,
      "esun":  0xF190B,
      "e":     0xF1909,
      "nasa":  0xF193E,
      "ni":    0xF1941,
      "nena":  0xF1940,
      "o":     0xF1944,
      "kulupu":0xF191F,

      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "sijelo":0xF195B,
      "ante":  0xF1906,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913,

      "a": 0xF1900,
      "akesi": 0xF1901,
      "ala": 0xF1902,
      "alasa": 0xF1903,
      "ale": 0xF1904,
      "ali": 0xF1904,
      "anpa": 0xF1905,
      "anu": 0xF1907,
      "awen": 0xF1908,
      "en": 0xF190A,
      "ike": 0xF190D,
      "ilo": 0xF190E,
      "insa": 0xF190F,
      "jaki": 0xF1910,
      "jan": 0xF1911,
      "jelo": 0xF1912,
      "kala": 0xF1914,
      "kalama": 0xF1915,
      "kama": 0xF1916,
      "kasi": 0xF1917,
      "ken": 0xF1918,
      "kepeken": 0xF1919,
      "kili": 0xF191A,
      "kiwen": 0xF191B,
      "ko": 0xF191C,
      "kon": 0xF191D,
      "kule": 0xF191E,
      "kute": 0xF1920,
      "la": 0xF1921,
      "lape": 0xF1922,
      "laso": 0xF1923,
      "lawa": 0xF1924,
      "len": 0xF1925,
      "lete": 0xF1926,
      "li": 0xF1927,
      "lili": 0xF1928,
      "linja": 0xF1929,
      "lipu": 0xF192A,
      "loje": 0xF192B,
      "lon": 0xF192C,
      "lukin": 0xF192E,
      "lupa": 0xF192F,
      "ma": 0xF1930,
      "mama": 0xF1931,
      "mani": 0xF1932,
      "meli": 0xF1933,
      "mi": 0xF1934,
      "mije": 0xF1935,
      "moku": 0xF1936,
      "moli": 0xF1937,
      "monsi": 0xF1938,
      "mu": 0xF1939,
      "musi": 0xF193B,
      "mute": 0xF193C,
      "nasin": 0xF193F,
      "nimi": 0xF1942,
      "noka": 0xF1943,
      "olin": 0xF1945,
      "ona": 0xF1946,
      "open": 0xF1947,
      "pakala": 0xF1948,
      "pali": 0xF1949,
      "palisa": 0xF194A,
      "pan": 0xF194B,
      "pana": 0xF194C,
      "pi": 0xF194D,
      "pilin": 0xF194E,
      "pimeja": 0xF194F,
      "pini": 0xF1950,
      "poka": 0xF1952,
      "poki": 0xF1953,
      "pona": 0xF1954,
      "pu": 0xF1955,
      "sama": 0xF1956,
      "seli": 0xF1957,
      "selo": 0xF1958,
      "seme": 0xF1959,
      "sewi": 0xF195A,
      "sike": 0xF195C,
      "sin": 0xF195D,
      "sina": 0xF195E,
      "sinpin": 0xF195F,
      "sitelen": 0xF1960,
      "sona": 0xF1961,
      "soweli": 0xF1962,
      "suli": 0xF1963,
      "suno": 0xF1964,
      "supa": 0xF1965,
      "suwi": 0xF1966,
      "tan": 0xF1967,
      "taso": 0xF1968,
      "tawa": 0xF1969,
      "telo": 0xF196A,
      "tenpo": 0xF196B,
      "toki": 0xF196C,
      "tomo": 0xF196D,
      "unpa": 0xF196F,
      "uta": 0xF1970,
      "walo": 0xF1972,
      "waso": 0xF1974,
      "wawa": 0xF1975,
      "weka": 0xF1976,
      "wile": 0xF1977,
      "namako": 0xF1978,
      "kin": 0xF1979,
      "oko": 0xF197A,
      "kipisi": 0xF197B,
      "leko": 0xF197C,
      "monsuta": 0xF197D,
      "tonsi": 0xF197E,
      "jasima": 0xF197F,
      "kijetesantakalu": 0xF1980,
      "soko": 0xF1981,
      "meso": 0xF1982,
      "epiku": 0xF1983,
      "kokosila": 0xF1984,
      "lanpan": 0xF1985,
      "n": 0xF1986,
      "misikeke": 0xF1987,
      "ku": 0xF1988,
    };

    const UCSUR_CP_TO_WORD = new Map(
      Object.entries(WORD_TO_UCSUR_CP).map(([w, cp]) => [cp, w])
    );

    function ucsurCodepointsToTpWords(codepoints) {
      const words = [];
      for (const cp of codepoints) {
        const w = UCSUR_CP_TO_WORD.get(cp);
        if (!w) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(`No Toki Pona word mapping for code point U+${hex}`);
        }
        words.push(w);
      }
      return words;
    }

    function tpWordsToText(words) {
      return (words ?? []).join(" ");
    }

    function parseTpWordsToCodepoints(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return [];

      const parts = raw.split(/\s+/).filter(Boolean);

      const cps = [];
      for (const p of parts) {
        const w = p.toLowerCase();
        const cp = WORD_TO_UCSUR_CP[w];
        if (cp == null) {
          throw new Error(`Invalid Toki Pona word "${p}". Only mapped words are allowed.`);
        }
        cps.push(cp);
      }

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function tpWordsToUcsurCodepoints(words) {
      const cps = [];
      for (const w of words) {
        const key = String(w).toLowerCase();
        const cp = WORD_TO_UCSUR_CP[key];
        if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
        cps.push(cp);
      }
      return cps;
    }

    function decimalToUcsurCodepoints(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return [];

      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens);
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function splitCartoucheCapsLetters(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      let outStr = "";
      let i = 0;
      const end = s0.length - 1;

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);
        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { outStr += "neno "; i += 4; continue; }
        if (pair === "NE" && nextPair === "NE") { outStr += "n "; outStr += "ene "; i += 4; continue; }
        if (pair === "NO" && nextPair === "NE" && i > 0) { outStr += "n "; outStr += "one "; i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          outStr += "n ";
          outStr += "o";
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          outStr += "no".repeat(countNo);
          if ((i + 2 * countNo) < end) outStr += " ";
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          outStr += "n ";
          outStr += "e";
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          outStr += "ke".repeat(countKe);
          if ((i + 2 * countKe) < end) outStr += " ";
          i += 2 + 2 * countKe;
          continue;
        }

        outStr += pair.toLowerCase();
        i += 2;
      }

      outStr = outStr.replace(/\s+n(?=\s|$)/g, "n");
      outStr = outStr.trim();
      outStr += "n";
      return outStr;
    }

    function encodeDecimalToLatin(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return "";
      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });
      return splitCartoucheCapsLetters(caps);
    }

    function isValidNanpaLinjanProperName(raw) {
      const s = String(raw ?? "").toLowerCase().replace(/\s+/g, "");
      if (!s) return false;
      if (!/^[a-z]+$/.test(s)) return false;
      if (!s.endsWith("n")) return false;

      const core = s.slice(0, -1);
      if (core.length < 2 || (core.length % 2) !== 0) return false;

      const caps = core.toUpperCase() + "N";
      if (!caps.startsWith("NE")) return false;

      try { tokenizeNanpaCaps(caps); return true; }
      catch { return false; }
    }

    function splitCartoucheCapsLettersSpaced(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      const parts = [];
      let current = "";
      let i = 0;
      const end = s0.length - 1;

      function flushCurrent() {
        if (current) { parts.push(current); current = ""; }
      }

      function attachDelimiterN() {
        if (current) { current += "n"; flushCurrent(); return; }
        if (parts.length === 0) { parts.push("n"); return; }
        parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      }

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);

        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { flushCurrent(); parts.push("neno"); i += 4; continue; }

        if (pair === "NE" && nextPair === "NE") { flushCurrent(); attachDelimiterN(); parts.push("ene"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NE" && i > 0) { flushCurrent(); attachDelimiterN(); parts.push("one"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          flushCurrent();
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          attachDelimiterN();
          parts.push("o" + "no".repeat(countNo));
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          flushCurrent();
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          attachDelimiterN();
          parts.push("e" + "ke".repeat(countKe));
          i += 2 + 2 * countKe;
          continue;
        }

        current += pair.toLowerCase();
        i += 2;
      }

      flushCurrent();

      if (parts.length === 0) return "n";
      parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";

      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function nanpaLinjanProperNameToUcsurCodepoints(nameStr) {
      const s = String(nameStr ?? "").toLowerCase().replace(/\s+/g, "");
      if (!s || !s.endsWith("n")) throw new Error("Not a nanpa-linja-n proper name (missing final 'n').");

      const core = s.slice(0, -1);
      const caps = core.toUpperCase() + "N";

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens);
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function codepointsToHexString(codepoints) {
      return codepoints.map(cp => cp.toString(16).toUpperCase().padStart(4, "0")).join(" ");
    }

    function parseHexCodepoints(input) {
      const raw = input.trim();
      if (!raw) return [];
      const parts = raw.split(/\s+/).map(s => s.replace(/^U\+/i, ""));
      const cps = parts.map(p => {
        const cp = parseInt(p, 16);
        if (!Number.isFinite(cp)) throw new Error(`Invalid hex code point: "${p}"`);
        return cp;
      });

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    /* =======================
       Cartouche rendering
       ======================= */

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function renderMixedCartoucheToCanvas(canvas, codepoints, largePx, smallPx, smallCodepoints, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        const px = smallCodepoints.has(cp) ? smallPx : largePx;

        ctx.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";

      for (const g of glyphRuns) {
        ctx2.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }

      return { cartW, cartH, textW: totalWidth, textH: textHeight, maxAscent, maxDescent };
    }

    function renderUniformCartoucheFromCodepoints(canvas, codepoints, fontPx, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);

        ctx.font = `${fontPx}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(fontPx * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(fontPx * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, left, tightW });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";
      ctx2.font = `${fontPx}px "${FONT_FAMILY}"`;

      for (const g of glyphRuns) {
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }
    }

    async function ensureFontLoaded() {
      const sampleCp = 0xF190B;
      const sampleChar = String.fromCodePoint(sampleCp);
      const fontSpec = `24px "${FONT_FAMILY}"`;

      function fallbackLikely(sampleText) {
        const c = document.createElement("canvas");
        const ctx = c.getContext("2d");
        ctx.font = `48px "${FONT_FAMILY}", monospace`;
        const w1 = ctx.measureText(sampleText).width;
        ctx.font = `48px monospace`;
        const w2 = ctx.measureText(sampleText).width;
        return w1 === w2;
      }

      if (!document.fonts || !document.fonts.load || !document.fonts.check) {
        console.warn("[font] CSS Font Loading API not available; cannot reliably validate load.");
        return;
      }

      try {
        await document.fonts.load(fontSpec, sampleChar);
        await document.fonts.ready;

        const ok = document.fonts.check(fontSpec, sampleChar);
        if (!ok) {
          console.warn(`[font] NOT CONFIRMED: ${fontSpec}`);
          console.warn("[font] If opening via file://, use Live Server / http://localhost to avoid font load restrictions.");
        }

        if (fallbackLikely(sampleChar)) {
          console.warn("[font] fallback likely (width matches monospace). Font may not have the glyph, or did not load.");
        }
      } catch (e) {
        console.error("[font] load threw error:", e);
      }
    }

    /* =======================
       UI wiring
       ======================= */

    const LETTER_SPACING_GAP = 4;

    const LARGE_FONT_SIZE = 72;
    const SMALL_FONT_SIZE = 20;

    const LARGE_TINY_FONT_SIZE = 40;
    const SMALL_TINY_FONT_SIZE = 10;

    const elDecimal = document.getElementById("decimalInput");
    const elLatinOut = document.getElementById("latinOut");
    const elCodepointsOut = document.getElementById("codepointsOut");
    const elNumberCodeOut = document.getElementById("numberCodeOut");

    const canvasLarge = document.getElementById("canvasLarge");
    const canvasSmall = document.getElementById("canvasSmall");

    const elCodesIn = document.getElementById("codepointsIn");

    const elTpWordsOut = document.getElementById("tpWordsOut");
    const elTpWordsIn = document.getElementById("tpWordsIn");

    const MAX_DECIMAL_INPUT_CHARS = 500;
    const MAX_HEX_CODE_INPUT_CHARS = 3500;
    const MAX_TOKI_PONA_WORD_INPUT_CHARS = 2500;

    function enforceMaxLen(el, maxLen = MAX_DECIMAL_INPUT_CHARS) {
      if (!el) return;
      const s = String(el.value ?? "");
      if (s.length > maxLen) el.value = s.slice(0, maxLen);
    }

    enforceMaxLen(elDecimal,  MAX_DECIMAL_INPUT_CHARS);
    enforceMaxLen(elCodesIn,  MAX_HEX_CODE_INPUT_CHARS);
    enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

    if (elDecimal) elDecimal.addEventListener("input", () => enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS));
    if (elCodesIn) elCodesIn.addEventListener("input", () => enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS));
    if (elTpWordsIn) elTpWordsIn.addEventListener("input", () => enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS));

    const elDigitTableBody = document.getElementById("digitTableBody");

    function buildDigitReferenceTable() {
      if (!elDigitTableBody) return;
      elDigitTableBody.innerHTML = "";

      const smallSet = getSmallCodepointsSet();
      const TINY_LARGE_PX = 22;
      const TINY_SMALL_PX = 8;

      for (let d = 0; d <= 9; d++) {
        const digitStr = String(d);
        const latinName = encodeDecimalToLatin(digitStr);
        const cps = decimalToUcsurCodepoints(digitStr);
        const unique_number_code = latinNameToNumberCode(latinName);

        const tr = document.createElement("tr");

        const tdDigit = document.createElement("td");
        tdDigit.className = "mono";
        tdDigit.textContent = digitStr;

        const tdName = document.createElement("td");
        tdName.className = "mono";
        tdName.textContent = latinName;

        const tdUniqueNumberCode = document.createElement("td");
        tdUniqueNumberCode.className = "mono";
        tdUniqueNumberCode.textContent = unique_number_code;

        const tdCanvas = document.createElement("td");
        const canvas = document.createElement("canvas");
        canvas.className = "digitCanvas";
        canvas.setAttribute("aria-hidden", "true");
        tdCanvas.appendChild(canvas);

        tr.appendChild(tdDigit);
        tr.appendChild(tdName);
        tr.appendChild(tdUniqueNumberCode);
        tr.appendChild(tdCanvas);

        elDigitTableBody.appendChild(tr);

        renderMixedCartoucheToCanvas(
          canvas,
          cps,
          TINY_LARGE_PX,
          TINY_SMALL_PX,
          smallSet,
          { padding: 8, border: 1, cornerRadius: 10, letterGap: 2 }
        );
      }
    }

    async function runEncodeFromDecimal() {
      await ensureFontLoaded();
      enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS);

      const raw = normalizeVulgarFractionInput(elDecimal.value);
      const latin = encodeDecimalToLatin(raw);

      elLatinOut.value = latin;
      elNumberCodeOut.value = latinNameToNumberCode(latin);

      const cps = decimalToUcsurCodepoints(raw);

      if (elCodepointsOut) elCodepointsOut.value = codepointsToHexString(cps);
      if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

      const smallSet = getSmallCodepointsSet();

      renderMixedCartoucheToCanvas(
        canvasSmall,
        cps,
        LARGE_TINY_FONT_SIZE,
        SMALL_TINY_FONT_SIZE,
        smallSet,
        { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
      );

      renderMixedCartoucheToCanvas(
        canvasLarge,
        cps,
        LARGE_FONT_SIZE,
        SMALL_FONT_SIZE,
        smallSet,
        { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
      );

      announceStatus(`Rendered value ${raw}.`);
    }

    document.getElementById("btnEncode").addEventListener("click", async () => {
      try {
        await runEncodeFromDecimal();
      } catch (err) {
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    document.getElementById("btnFromCodes")?.addEventListener("click", async () => {
      try {
        await ensureFontLoaded();
        enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS);

        const cps = parseHexCodepoints(elCodesIn.value);

        elLatinOut.value = String.fromCodePoint(...cps);
        if (elCodepointsOut) elCodepointsOut.value = codepointsToHexString(cps);
        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);
        if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

        announceStatus("Rendered from code points.");
      } catch (err) {
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    document.getElementById("btnFromWords").addEventListener("click", async () => {
      try {
        await ensureFontLoaded();
        enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

        const rawInput = String(elTpWordsIn.value ?? "");

        if (isValidNanpaLinjanProperName(rawInput)) {
          const cps = nanpaLinjanProperNameToUcsurCodepoints(rawInput);

          const compact = rawInput.toLowerCase().replace(/\s+/g, "");
          const core = compact.slice(0, -1);
          const caps = core.toUpperCase() + "N";

          const prettyName = splitCartoucheCapsLettersSpaced(caps);

          elLatinOut.value = prettyName;
          elNumberCodeOut.value = latinNameToNumberCode(prettyName);

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexString(cps);
          if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

          const smallSet = getSmallCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            smallSet,
            { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            smallSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Rendered from nanpa-linja-n proper name.");
          return;
        }

        const cps = parseTpWordsToCodepoints(elTpWordsIn.value);

        if (elCodepointsOut) elCodepointsOut.value = codepointsToHexString(cps);
        if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        elLatinOut.value = String.fromCodePoint(...cps);
        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);

        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          { padding: 18, border: 2, cornerRadius: 16, letterGap: LETTER_SPACING_GAP }
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

        announceStatus("Rendered from Toki Pona words.");
      } catch (err) {
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    function validateTpWordsInputLive() {
      const raw = String(elTpWordsIn?.value ?? "").trim();
      if (!raw) { elTpWordsIn.setCustomValidity(""); return; }

      // If it is a valid nanpa-linja-n proper name, treat as valid
      if (isValidNanpaLinjanProperName(raw)) {
        elTpWordsIn.setCustomValidity("");
        return;
      }

      const parts = raw.split(/\s+/).filter(Boolean);
      for (const p of parts) {
        if (WORD_TO_UCSUR_CP[p.toLowerCase()] == null) {
          elTpWordsIn.setCustomValidity(`Invalid word: ${p}`);
          return;
        }
      }
      elTpWordsIn.setCustomValidity("");
    }

    if (elTpWordsIn) elTpWordsIn.addEventListener("input", validateTpWordsInputLive);

    /* Keyboard support: Enter triggers encode when focused in decimal input */
    if (elDecimal) {
      elDecimal.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          document.getElementById("btnEncode").click();
        }
      });
    }

    window.addEventListener("load", async () => {
      try {
        await ensureFontLoaded();
        buildDigitReferenceTable();
        await runEncodeFromDecimal();
      } catch (err) {
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });
  </script>
</body>
</html>
