<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>nanpa-linja-n Cartouche Calculator — ilo nanpa pi poki nimi</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;
      --muted: #3f4750;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .small { font-size: 13px; color: var(--muted); }
    .help  { font-size: 13px; color: var(--muted); margin-top: 6px; line-height: 1.35; }
    .mono  { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    /* NEW: Toki Pona line helper */
    .tpLine {
      display: block;
      margin-top: 2px;
      font-size: 10pt;
      color: var(--muted);
    }

    .calc {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
      margin-top: 14px;
    }

    .displayBox {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0;
      background: var(--bg);
    }

    .displayRow {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      align-items: center;
      padding: 12px;
    }

    canvas {
      display: block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: var(--bg);
      max-width: 100%;
    }

    .displayMeta {
      display: flex;
      justify-content: space-between;
      gap: 10px;
      align-items: baseline;
      flex-wrap: wrap;
    }

    .keys {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }

    .btn {
      border: 1px solid var(--border);
      background: var(--bg);
      border-radius: 10px;
      padding: 10px;
      cursor: pointer;
      user-select: none;

      min-height: 96px;

      display: grid;
      grid-template-rows: 1fr auto;
      align-items: center;
      justify-items: center;

      box-sizing: border-box;
    }

    .btn:active { transform: translateY(1px); }
    .btnWide { grid-column: span 2; }

    .btnLabel {
      font-size: 12px;
      color: var(--muted);
      margin-top: 6px;
    }

    .btnCanvas {
      width: auto;
      height: auto;
      max-width: 100%;
      display: block;
    }

    .btn:focus-visible,
    a:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    /* Visually hidden but still accessible to screen readers */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: -1px !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src: 
        /* Web-hosted files (order matters) */
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-v4.otf")   format("opentype"); 
      font-display: swap;
    }

    /* =========================
       NEW: Cartouche display mode chooser (subtle)
       ========================= */
    .displayChooser {
      margin: 10px 0 6px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg);
    }

    .displayChooser legend {
      font-size: 12px;
      color: var(--muted);
      padding: 0 6px;
      font-weight: 700;
    }

    .displayOpt {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-right: 14px;
      font-size: 13px;
      color: #111;
      cursor: pointer;
      user-select: none;
    }

    .displayOpt input {
      transform: translateY(1px);
    }
  </style>
</head>

<body>
  <a href="#calculator" class="skipLink">Skip to calculator — o tawa ilo nanpa</a>

  <main class="card" id="calculator" role="main">
    <h1 style="margin:0 0 6px;font-size:18px;">
      Toki Pona nanpa-linja-n cartouche calculator
      <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
    </h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> The “nanpa-linja-n proper name” generated here is a number-encoding label only.
      It is intended as a proper-name style identifier and does not propose or add any new Toki Pona lexicon.
      <span class="tpLine">
        sona: nimi “nanpa-linja-n proper name” li nimi pi pana nanpa taso.
        ona li sama nimi pi jan (nimi pi nimi) taso; ona li pana ala e nimi sin pi toki pona.
      </span>
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <span class="tpLine">
        sona: ilo ni li lon nasin “as is”. mi pana ala e wawa pi pona.
        sina o lukin e ni: sitelen li pona anu seme.
      </span>
    </div>

    <div class="calc">

      <div class="displayBox" role="group" aria-label="Calculator display">
        <div class="displayRow">
          <!-- Decorative canvas -->
          <canvas id="displayCanvas" aria-hidden="true"></canvas>

          <!-- Visible: value + pending, now bilingual -->
          <div class="displayMeta" aria-hidden="true">
            <div class="small">
              Input: <span id="displayTextVisible" class="mono"></span>
              <span class="tpLine">pana: <span id="displayTextVisibleTp" class="mono"></span></span>
            </div>
            <div class="small">
              Pending: <span id="pendingTextVisible" class="mono"></span>
              <span class="tpLine">pali awen: <span id="pendingTextVisibleTp" class="mono"></span></span>
            </div>
          </div>

          <!-- Screen reader-only: description + live region + authoritative text -->
          <p id="displayA11yDesc" class="help sr-only">
            The cartouche display is decorative. The accessible text value is provided via a live region.
          </p>

          <div id="displayLive" class="mono sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

          <!-- Screen reader-only: original DOM fields retained for AT -->
          <div class="displayMeta sr-only" aria-hidden="false">
            <div class="small">Input: <span id="displayText" class="mono"></span></div>
            <div class="small">Pending: <span id="pendingText" class="mono"></span></div>
          </div>

          <div class="help" aria-label="nanpa-linja-n proper name">
            <strong>nanpa-linja-n proper name:</strong>
            <span id="properNameText"></span>
          </div>

        </div>
      </div>

      <div class="keys" id="keys" role="group" aria-label="Calculator keypad"></div>

      <!-- NEW: Cartouche display mode selector (below keypad) -->
      <fieldset class="displayChooser" aria-label="Cartouche display mode">
        <legend>Cartouche display</legend>

        <label class="displayOpt">
          <input type="radio" name="cartoucheDisplay" value="traditional" checked>
          <span>Traditional</span>
        </label>

        <label class="displayOpt">
          <input type="radio" name="cartoucheDisplay" value="uniform">
          <span>Uniform</span>
        </label>
      </fieldset>

      <div class="help">&nbsp;</div>
      <div class="help"><img src="./images/From_Decimal_Number_To_Cartouche.png" width="569" /></div>
      <div class="help">&nbsp;</div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona Multiline text → sitelen pona glyphs → png image file download
        <span class="tpLine">o lukin e ilo ni: sitelen toki pona mute-linja tawa sitelen pona</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a id="textToSitelenLink" class="repoLink" href="./text-to-sitelen.html" target="_blank" rel="noopener noreferrer">
          Multiline text → sitelen pona glyphs → png image file download
        </a>
        <span class="tpLine">o lukin e ilo ni: sitelen toki pona mute-linja tawa sitelen pona</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer
        <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="./renderer.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n decimal number encoder + cartouche renderer
        </a>
        <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n maze game
        <span class="tpLine">o lukin e musi pi nasin pi nanpa-linja-n lon toki pona</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="./maze-toki.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n maze game
        </a>
        <span class="tpLine">musi pi nasin pi nanpa-linja-n lon toki pona</span>
      </div>
      
      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona 15 puzzle game
        <span class="tpLine">o lukin e musi pi leko tawa nanpa Newelen pi toki pona</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="./15-puzzle-toki.html" target="_blank" rel="noopener noreferrer">
          15 puzzle game
        </a>
        <span class="tpLine">musi pi leko tawa nanpa Newelen pi toki pona</span>
      </div>
      
      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona sitelen pona fonts
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n/tree/main/docs/fonts" target="_blank" rel="noopener noreferrer">
          sitelen pona nanpa-linja-n fonts
        </a>
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n main documentation
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n main documentation
        </a>
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </div>

      <div class="help">#~n</div>
    </div>
  </main>

  <script>
    "use strict";

    /* ============================================================
       NEW: Cartouche display mode (Traditional vs Uniform)
       - Query param: ?cartoucheDisplay=traditional|uniform
       - Persists: localStorage
       ============================================================ */

    const CARTOUCHE_DISPLAY_STORAGE_KEY = "cartoucheDisplayMode";
    const CARTOUCHE_DISPLAY_QUERY_KEY = "cartoucheDisplay";

    const WORD_FOR_NEGATIVE_SIGN = "ona" //"o" // could use ona

    function getCartoucheDisplayMode() {
      const el = document.querySelector('input[name="cartoucheDisplay"]:checked');
      return (el && (el.value === "uniform" || el.value === "traditional")) ? el.value : "traditional";
    }

    function setCartoucheDisplayMode(mode) {
      const v = (mode === "uniform") ? "uniform" : "traditional";
      const target = document.querySelector(`input[name="cartoucheDisplay"][value="${v}"]`);
      if (target) target.checked = true;
      try { localStorage.setItem(CARTOUCHE_DISPLAY_STORAGE_KEY, v); } catch {}
    }

    function loadCartoucheDisplayModeFromStorage() {
      try {
        const v = localStorage.getItem(CARTOUCHE_DISPLAY_STORAGE_KEY);
        if (v === "uniform" || v === "traditional") setCartoucheDisplayMode(v);
      } catch {}
    }

    function loadCartoucheDisplayModeFromQueryParam() {
      try {
        const qs = new URLSearchParams(window.location.search);
        const v = (qs.get(CARTOUCHE_DISPLAY_QUERY_KEY) || "").toLowerCase();
        if (v === "uniform" || v === "traditional") {
          setCartoucheDisplayMode(v);
          return true;
        }
      } catch {}
      return false;
    }

    function updateCrossLinksWithCartoucheDisplay() {
      const mode = getCartoucheDisplayMode();
      document.querySelectorAll('a.repoLink[href]').forEach(a => {
        const href = String(a.getAttribute("href") || "");

        // Do not rewrite absolute/external links
        if (/^https?:\/\//i.test(href)) return;

        try {
          const url = new URL(href, window.location.href);
          const p = new URLSearchParams(url.search);
          p.set(CARTOUCHE_DISPLAY_QUERY_KEY, mode);
          url.search = p.toString();

          const outHref =
            url.pathname +
            (url.search ? ("?" + url.searchParams.toString()) : "") +
            (url.hash || "");

          a.setAttribute("href", outHref);
        } catch {}
      });
    }

    function wireCartoucheDisplayRadios() {
      const radios = document.querySelectorAll('input[name="cartoucheDisplay"]');
      radios.forEach(r => {
        r.addEventListener("change", () => {
          setCartoucheDisplayMode(getCartoucheDisplayMode());
          updateCrossLinksWithCartoucheDisplay();

          // Re-render everything that depends on wording.
          buildKeypad();
          renderDisplay();
          rerenderWideZeroKey();
        });
      });
    }

    const OP_BUTTON_WORDS = {
      add: "en",
      sub: "lape",
      mul: "lete",
      div: "kipisi",
      eq:  "sama",
      clr: "kijetesantakalu",
      bk:  "monsi",
      dot: "o",
      sign:"ona" //ike
    };

    const WORD_TO_UCSUR_CP = {
      "nanpa": 0xF193D, "esun": 0xF190B, "e": 0xF1909, "nasa": 0xF193E,
      "ni": 0xF1941, "nena": 0xF1940, "o": 0xF1944, "kulupu": 0xF191F,

      "ijo": 0xF190C, "wan": 0xF1973, "tu": 0xF196E, "sijelo": 0xF195B, "ante": 0xF1906,
      "luka": 0xF192D, "utala": 0xF1971, "mun": 0xF193A, "pipi": 0xF1951, "jo": 0xF1913,

      "pana": 0xF194C, "weka": 0xF1976, "mute": 0xF193C, "kipisi": 0xF197B,
      "pona": 0xF1954, "ala": 0xF1902, "monsi": 0xF1938, "ike": 0xF190D,

      "en":   0xF190A,
      "lape": 0xF1922,
      "sama": 0xF1956,
      "kijetesantakalu": 0xF1980,
      "lete": 0xF1926,
      "awen": 0xF1908,
      "seli": 0xF1957,
      "ona": 0xF1946,
    };

    const FONT_FAMILY = "TP-Cartouche-Font";

    function getSmallCodepointsSet() {
      return new Set([
        0xF193D, // nanpa
        0xF1940, // nena
        0xF1941, // ni
        0xF193E, // nasa
        0xF1909, // e
        0xF190B, // esun
        0xF190A, // en  (added for uniform mode)
      ]);
    }

    const TP_UCSUR_MIN = 0xF1900;
    const TP_UCSUR_MAX = 0xF1988;

    function isAllowedTpUcsurCodepoint(cp) {
      return Number.isInteger(cp) && cp >= TP_UCSUR_MIN && cp <= TP_UCSUR_MAX;
    }

    function assertAllAllowedTpUcsur(codepoints) {
      for (const cp of codepoints) {
        if (!isAllowedTpUcsurCodepoint(cp)) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(
            `Disallowed code point U+${hex}. Allowed range is U+${TP_UCSUR_MIN.toString(16).toUpperCase()}..U+${TP_UCSUR_MAX.toString(16).toUpperCase()}.`
          );
        }
      }
    }

    const DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    const TOKEN_TO_DIGIT_WORD = {
      "NI": "ijo", "WE": "wan", "TE": "tu", "SE": "seli", "NA": "awen",
      "LE": "luka", "NU": "utala", "ME": "mun", "PE": "pipi", "JE": "jo",
    };

    const OPCHAR_TO_TOKEN = { ".": "NONE", "-": "NO", "/": "NONO", "+": "NONONO" };
    const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));
    const TOKEN_PREFIXES = [ "KEKEKE", "KEKE", "KE", "NONONO", "NONO", "NE", "NO" ];

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    function numberStrToNanpaCaps(
      s,
      {
        thousandsChar = ",",
        groupFractionTriplets = false,
        fractionGroupSize = 3,
      } = {}
    ) {
      if (s == null) throw new Error("s must be a string, not null");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      function groupFractionDigitsOnly(str, decimalChar=".", groupSize=3, sepChar=",") {
        const idx = str.indexOf(decimalChar);
        if (idx < 0) return str;

        const left = str.slice(0, idx);
        const right = str.slice(idx + 1);

        let i = 0;
        while (i < right.length && /[0-9]/.test(right[i])) i++;
        const fracDigits = right.slice(0, i);
        const suffix = right.slice(i);

        if (fracDigits.length <= groupSize) return str;
        if (sepChar && fracDigits.includes(sepChar)) return str;

        const groups = [];
        for (let j = 0; j < fracDigits.length; j += groupSize) {
          groups.push(fracDigits.slice(j, j + groupSize));
        }
        return `${left}${decimalChar}${groups.join(sepChar)}${suffix}`;
      }

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, thousandsChar);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          if (out.length > 0 && out[out.length - 1] === "NENE") return;
          out.push("NENE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        // Calculator path: we expect commas in integer if grouping is desired.
        // Still validate the groups.
        const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
        for (const g of groups) {
          if (g === "" || !/^\d+$/.test(g)) {
            throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }
        }

        // trailing ",000" compression
        let trailingZeroGroups = 0;
        for (let k = groups.length - 1; k >= 1; k--) {
          const g = groups[k];
          if (g.length === 3 && g === "000") trailingZeroGroups += 1;
          else break;
        }

        for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

        const nGroups = groups.length;
        const lastNonTrailingIdx = nGroups - trailingZeroGroups;

        for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
          out.push("NEKE");
          for (const d of groups[idx]) out.push(DIGIT_TO_TOKEN[d]);
        }

        if (trailingZeroGroups > 0) {
          out.push("NE");
          for (let i = 0; i < trailingZeroGroups; i++) out.push("KE");
        }

        if (hasDecimal) {
          out.push(OPCHAR_TO_TOKEN["."]);

          for (const ch of fracPart) {
            if (ch === "_" ) continue;
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        out.push("N");
        return out.join("");
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const n = s.length;

      while (i < n - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= n - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }
        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }



    /* Display nanpa-linja-n proper name */

    function titleCaseNanpaProperNameForDisplay(nameStr) {
      const s = String(nameStr ?? "").trim();
      if (!s) return s;
      return s
        .split(/\s+/)
        .filter(Boolean)
        .map(w => {
          const lower = w.toLowerCase();
          if (lower.length === 1) return lower.toUpperCase();
          return lower[0].toUpperCase() + lower.slice(1);
        })
        .join(" ");
    }

    function splitCartoucheCapsLettersSpaced(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      const parts = [];
      let current = "";
      let i = 0;
      const end = s0.length - 1;

      function flushCurrent() {
        if (current) { parts.push(current); current = ""; }
      }

      function attachDelimiterN() {
        if (current) { current += "n"; flushCurrent(); return; }
        if (parts.length === 0) { parts.push("n"); return; }
        parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      }

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);

        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { flushCurrent(); parts.push("neno"); i += 4; continue; }
        if (pair === "NE" && nextPair === "NE") { flushCurrent(); attachDelimiterN(); parts.push("ene"); i += 4; continue; }
        if (pair === "NO" && nextPair === "NE" && i > 0) { flushCurrent(); attachDelimiterN(); parts.push("one"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          flushCurrent();
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          attachDelimiterN();
          parts.push("o" + "no".repeat(countNo));
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          flushCurrent();
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          attachDelimiterN();
          parts.push("e" + "ke".repeat(countKe));
          i += 2 + 2 * countKe;
          continue;
        }

        current += pair.toLowerCase();
        i += 2;
      }

      flushCurrent();
      if (parts.length === 0) return "n";
      parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function encodeDecimalToProperNameDisplay(rawValueStr) {
      const raw0 = String(rawValueStr ?? "").trim();

      // Nothing meaningful to show in these states:
      if (!raw0 || raw0 === "Error") return "";
      if (raw0 === "-" || raw0 === "." || raw0 === "-.") return "";

      // Match your cartouche encoding path (grouping etc.)
      const rawForEncode = formatForCartoucheEncoding(raw0, ",");

      const caps = looksLikeNanpaCaps(rawForEncode)
        ? rawForEncode.toUpperCase()
        : numberStrToNanpaCaps(rawForEncode, {
            thousandsChar: ",",
            groupFractionTriplets: true,
            fractionGroupSize: 3,
          });

      const prettyRaw = splitCartoucheCapsLettersSpaced(caps);
      return titleCaseNanpaProperNameForDisplay(prettyRaw);
    }




    /* ============================================================
       UPDATED: TP-word rendering with Traditional vs Uniform modes
       - Uniform affects ALL occurrences of:
         - esun -> en
         - nasa -> nena
         - e -> en
       - Only "nanpa" at start and end remains "nanpa".
       ============================================================ */
    function nanpaCapsTokensToTpWords(tokens, { mode = "traditional" } = {}) {
      const uniform = (mode === "uniform");
      const out = [];

      const E_WORD = uniform ? "en" : "esun";
      const E_WORD_FOR_NE_AFTER_START = uniform ? "en" : "e";
      const N_WORD = uniform ? "nena" : "nasa";
      const N_WORD_DECIMAL_POINT = uniform ? "nena" : "ni";
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) {
            out.push("nanpa", E_WORD);
            afterStartingNe = true;
          } else {
            out.push(N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
          }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD);
          continue;
        }

        if (t === "NO") {
          if (afterStartingNe) out.push(N_WORD, WORD_FOR_NEGATIVE_SIGN);
          else out.push(N_WORD_DECIMAL_POINT, "o");
          afterStartingNe = false;
          continue;
        }

        if (t === "KE")   { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe = false; continue; }
        if (t === "KEKE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START, "kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe = false; continue; }
        if (t === "KEKEKE") {
          out.push(
            "kulupu", E_WORD_FOR_NE_AFTER_START,
            "kulupu", E_WORD_FOR_NE_AFTER_START,
            "kulupu", E_WORD_FOR_NE_AFTER_START
          );
          afterStartingNe = false;
          continue;
        }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe = false; continue; }

        throw new Error(`Unsupported token "${t}" in calculator mode`);
      }

      return out;
    }

    function tpWordsToUcsurCodepoints(words) {
      const cps = [];
      for (const w of words) {
        const key = String(w).toLowerCase();
        const cp = WORD_TO_UCSUR_CP[key];
        if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
        cps.push(cp);
      }
      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function decimalToUcsurCodepoints(decimalStr) {
      const raw0 = String(decimalStr ?? "").trim();
      if (!raw0) return [];

      const rawForEncode = formatForCartoucheEncoding(raw0, ",");

      const caps = looksLikeNanpaCaps(rawForEncode)
        ? rawForEncode.toUpperCase()
        : numberStrToNanpaCaps(rawForEncode, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function renderMixedCartoucheToCanvas(canvas, codepoints, largePx, smallPx, smallCodepoints, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        const px = smallCodepoints.has(cp) ? smallPx : largePx;

        ctx.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";

      for (const g of glyphRuns) {
        ctx2.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }
    }

    function renderMixedCartoucheToCanvasFixedWidthCentered(
      canvas,
      codepoints,
      largePx,
      smallPx,
      smallCodepoints,
      targetOuterWidthPx,
      options = {}
    ) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const dpr = window.devicePixelRatio || 1;

      const ctxMeasure = canvas.getContext("2d");
      ctxMeasure.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        const px = smallCodepoints.has(cp) ? smallPx : largePx;

        ctxMeasure.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctxMeasure.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);

      const targetOuterW = Math.max(0, Math.floor(targetOuterWidthPx));
      const targetCartW = Math.max(0, targetOuterW - border * 2);

      const minCartW = Math.ceil(totalWidth + pad * 2);
      const cartW = Math.max(targetCartW, minCartW);

      const cartH = Math.ceil(textHeight + pad * 2);

      const outerW = cartW + border * 2;
      const outerH = cartH + border * 2;

      canvas.style.width = `${outerW}px`;
      canvas.style.height = `${outerH}px`;
      canvas.width = Math.ceil(outerW * dpr);
      canvas.height = Math.ceil(outerH * dpr);

      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.textBaseline = "alphabetic";
      ctx.clearRect(0, 0, outerW, outerH);

      drawRoundedRect(ctx, border, border, cartW, cartH, corner);
      ctx.lineWidth = border;
      ctx.strokeStyle = "#111";
      ctx.stroke();

      const baselineY = border + pad + maxAscent;

      const innerLeft = border + pad;
      const innerRight = border + cartW - pad;
      const innerAvail = Math.max(0, innerRight - innerLeft);

      const shift = Math.max(0, Math.floor((innerAvail - totalWidth) / 2));
      let x = innerLeft + shift;

      ctx.fillStyle = "#111";
      for (const g of glyphRuns) {
        ctx.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }
    }

    function renderMixedCartoucheToCanvasFixedWidthRightAligned(
      canvas,
      codepoints,
      largePx,
      smallPx,
      smallCodepoints,
      targetOuterWidthPx,
      options = {}
    ) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const dpr = window.devicePixelRatio || 1;

      const ctxMeasure = canvas.getContext("2d");
      ctxMeasure.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        const px = smallCodepoints.has(cp) ? smallPx : largePx;

        ctxMeasure.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctxMeasure.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);

      const targetOuterW = Math.max(0, Math.floor(targetOuterWidthPx));
      const targetCartW = Math.max(0, targetOuterW - border * 2);

      const minCartW = Math.ceil(totalWidth + pad * 2);
      const cartW = Math.max(targetCartW, minCartW);

      const cartH = Math.ceil(textHeight + pad * 2);

      const outerW = cartW + border * 2;
      const outerH = cartH + border * 2;

      canvas.style.width = `${outerW}px`;
      canvas.style.height = `${outerH}px`;
      canvas.width = Math.ceil(outerW * dpr);
      canvas.height = Math.ceil(outerH * dpr);

      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.textBaseline = "alphabetic";
      ctx.clearRect(0, 0, outerW, outerH);

      drawRoundedRect(ctx, border, border, cartW, cartH, corner);
      ctx.lineWidth = border;
      ctx.strokeStyle = "#111";
      ctx.stroke();

      const baselineY = border + pad + maxAscent;

      const innerLeft = border + pad;
      const innerRight = border + cartW - pad;
      const innerAvail = Math.max(0, innerRight - innerLeft);

      const shift = Math.max(0, innerAvail - totalWidth);
      let x = innerLeft + shift;

      ctx.fillStyle = "#111";
      for (const g of glyphRuns) {
        ctx.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }
    }

    function renderGlyphsCentered(canvas, codepoints, fontPx) {
      const ctx = canvas.getContext("2d");
      const chars = codepoints.map(cp => String.fromCodePoint(cp)).join("");

      ctx.font = `${fontPx}px "${FONT_FAMILY}"`;
      const m = ctx.measureText(chars);

      const ascent = m.actualBoundingBoxAscent ?? Math.ceil(fontPx * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(fontPx * 0.2);
      const h = Math.ceil(ascent + descent);

      const w = Math.ceil(m.width + 10);

      canvas.width = Math.max(60, w);
      canvas.height = Math.max(48, h + 10);

      const ctx2 = canvas.getContext("2d");
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      ctx2.fillStyle = "#111";
      ctx2.textBaseline = "alphabetic";
      ctx2.font = `${fontPx}px "${FONT_FAMILY}"`;

      const x = Math.floor((canvas.width - m.width) / 2);
      const y = Math.floor((canvas.height + ascent - descent) / 2);

      ctx2.fillText(chars, x, y);
    }

    async function ensureFontLoaded() {
      const sampleCp = 0xF190B;
      const sampleChar = String.fromCodePoint(sampleCp);
      const fontSpec = `24px "${FONT_FAMILY}"`;

      if (!document.fonts || !document.fonts.load || !document.fonts.check) return;
      await document.fonts.load(fontSpec, sampleChar);
      await document.fonts.ready;
    }

    const displayCanvas = document.getElementById("displayCanvas");
    const elDisplayText = document.getElementById("displayText");
    const elPendingText = document.getElementById("pendingText");
    const elDisplayLive = document.getElementById("displayLive");

    // Visible help fields (bilingual)
    const elDisplayTextVisible = document.getElementById("displayTextVisible");
    const elPendingTextVisible = document.getElementById("pendingTextVisible");
    const elDisplayTextVisibleTp = document.getElementById("displayTextVisibleTp");
    const elPendingTextVisibleTp = document.getElementById("pendingTextVisibleTp");

    //display proper name
    const elProperNameText = document.getElementById("properNameText");

    const smallSet = getSmallCodepointsSet();

    const DISPLAY_LARGE_PX = 92;
    const DISPLAY_SMALL_PX = 26;
    const DISPLAY_PAD = 24;
    const DISPLAY_BORDER = 3;
    const DISPLAY_CORNER = 18;
    const DISPLAY_GAP = 4;

    const BTN_LARGE_PX = 28;
    const BTN_SMALL_PX = 10;
    const BTN_PAD = 10;
    const BTN_BORDER = 2;
    const BTN_CORNER = 14;
    const BTN_GAP = 2;

    let inputStr = "0";
    let acc = null;
    let pendingOp = null;
    let lastOp = null;
    let lastArg = null;

    const MAX_DECIMALS = 5;

    function isError() { return inputStr === "Error"; }

    function setError() {
      inputStr = "Error";
      renderDisplay();
    }

    function formatNumberForDisplay(raw, { groupSize = 3, intSep = ",", fracSep = "_" } = {}) {
      const s0 = String(raw ?? "");

      // Preserve calculator special/mid-entry states
      if (s0 === "" || s0 === "-" || s0 === "Error") return s0;

      const neg = s0.startsWith("-");
      const s = neg ? s0.slice(1) : s0;

      const dot = s.indexOf(".");
      const hasDot = dot >= 0;

      const intPartRaw = hasDot ? s.slice(0, dot) : s;
      const fracRaw = hasDot ? s.slice(dot + 1) : "";

      // Preserve "12." form (no fraction digits yet)
      const endsWithDot = hasDot && dot === s.length - 1;

      // Integer grouping (from right)
      const intPart = (intPartRaw === "" ? "0" : intPartRaw);
      const intGrouped = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, intSep);

      if (!hasDot) return (neg ? "-" : "") + intGrouped;
      if (endsWithDot) return (neg ? "-" : "") + intGrouped + ".";

      // Fraction grouping (from left, in groups of 3)
      let i = 0;
      while (i < fracRaw.length && /[0-9]/.test(fracRaw[i])) i++;
      const fracDigits = fracRaw.slice(0, i);
      const suffix = fracRaw.slice(i);

      if (fracDigits.length <= groupSize) {
        return (neg ? "-" : "") + intGrouped + "." + fracDigits + suffix;
      }

      const fracGrouped = fracDigits.replace(new RegExp(`(\\d{${groupSize}})(?=\\d)`, "g"), `$1${fracSep}`);
      return (neg ? "-" : "") + intGrouped + "." + fracGrouped + suffix;
    }

    function formatForCartoucheEncoding(raw, thousandsSep = ",") {
      const s0 = String(raw ?? "").trim();
      if (!s0) return s0;
      if (s0 === "Error") return s0;

      // If it is already nanpa-caps, do not touch it
      if (looksLikeNanpaCaps(s0)) return s0;

      // Preserve mid-entry states
      if (s0 === "-" || s0 === "." || s0 === "-.") return s0;

      const neg = s0.startsWith("-");
      const s = neg ? s0.slice(1) : s0;

      const dot = s.indexOf(".");
      const hasDot = dot >= 0;

      const intRaw = hasDot ? s.slice(0, dot) : s;
      const fracRaw = hasDot ? s.slice(dot + 1) : "";

      // Preserve trailing dot (e.g. "12.")
      const endsWithDot = hasDot && dot === s.length - 1;

      // If user already has thousands separators, keep them
      let intPart = intRaw === "" ? "0" : intRaw;
      if (!intPart.includes(thousandsSep)) {
        intPart = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, thousandsSep);
      }

      const out = (neg ? "-" : "") + intPart + (hasDot ? "." : "") + (endsWithDot ? "" : fracRaw);
      return out;
    }

    function normalizeInputString(s) {
      if (!s || s === "-") return s;

      const neg = s.startsWith("-");
      const core = neg ? s.slice(1) : s;

      if (core.includes(".")) {
        const [a, b] = core.split(".", 2);
        const a2 = a.replace(/^0+(?=\d)/, "") || "0";
        return (neg ? "-" : "") + a2 + "." + b;
      } else {
        const a2 = core.replace(/^0+(?=\d)/, "") || "0";
        return (neg ? "-" : "") + a2;
      }
    }

    function parseInputToNumber(s) {
      if (!s || s === "-" || s === "." || s === "-.") return 0;
      const n = Number(s);
      if (!Number.isFinite(n)) throw new Error("Invalid number");
      return n;
    }

    function formatNumberForInput(n) {
      if (!Number.isFinite(n)) return "Error";
      if (Object.is(n, -0)) n = 0;
      if (Number.isInteger(n)) return String(n);

      const fixed = n.toFixed(MAX_DECIMALS);
      const trimmed = fixed.replace(/(\.\d*?)0+$/, "$1").replace(/\.$/, "");
      if (trimmed === "-0") return "0";
      return trimmed;
    }

    function compute(a, op, b) {
      if (op === "+") return a + b;
      if (op === "-") return a - b;
      if (op === "*") return a * b;
      if (op === "/") {
        if (b === 0) return NaN;
        return a / b;
      }
      throw new Error("Unknown op");
    }

    function applyPendingIfReady(nextOpForRepeat = null) {
      if (pendingOp == null || acc == null) return;

      const b = parseInputToNumber(inputStr);
      const r = compute(acc, pendingOp, b);

      if (!Number.isFinite(r)) { setError(); return; }

      lastOp = nextOpForRepeat ?? pendingOp;
      lastArg = b;

      acc = r;
      inputStr = formatNumberForInput(r);
    }

    function pressDigit(d) {
      if (isError()) return;
      if (inputStr === "0") inputStr = d;
      else if (inputStr === "-0") inputStr = "-" + d;
      else inputStr += d;

      inputStr = normalizeInputString(inputStr);
      renderDisplay();
    }

    function pressDot() {
      if (isError()) return;
      if (!inputStr.includes(".")) {
        inputStr = inputStr + ".";
        renderDisplay();
      }
    }

    function pressSign() {
      if (isError()) return;
      if (inputStr.startsWith("-")) inputStr = inputStr.slice(1) || "0";
      else inputStr = (inputStr === "0") ? "0" : "-" + inputStr;
      renderDisplay();
    }

    function pressBackspace() {
      if (isError()) return;
      if (inputStr.length <= 1) { inputStr = "0"; renderDisplay(); return; }
      inputStr = inputStr.slice(0, -1);
      if (inputStr === "-" || inputStr === "-0") inputStr = "0";
      renderDisplay();
    }

    function pressClear() {
      inputStr = "0";
      acc = null;
      pendingOp = null;
      lastOp = null;
      lastArg = null;
      renderDisplay();
    }

    function pressOp(op) {
      if (isError()) return;

      if (pendingOp != null && acc != null) {
        applyPendingIfReady(pendingOp);
        if (isError()) return;
      } else {
        acc = parseInputToNumber(inputStr);
      }

      pendingOp = op;
      inputStr = "0";
      renderDisplay();
    }

    function pressEquals() {
      if (isError()) return;

      if (pendingOp != null && acc != null) {
        applyPendingIfReady(pendingOp);
        pendingOp = null;
        renderDisplay();
        return;
      }

      if (lastOp != null && lastArg != null) {
        const a = parseInputToNumber(inputStr);
        const r = compute(a, lastOp, lastArg);
        if (!Number.isFinite(r)) { setError(); return; }
        inputStr = formatNumberForInput(r);
        renderDisplay();
      }
    }

    function handleKeydown(e) {
      if (e.altKey || e.ctrlKey || e.metaKey) return;

      const k = e.key;

      if (k >= "0" && k <= "9") { e.preventDefault(); pressDigit(k); return; }

      if (k === "+") { e.preventDefault(); pressOp("+"); return; }
      if (k === "-") { e.preventDefault(); pressOp("-"); return; }
      if (k === "*") { e.preventDefault(); pressOp("*"); return; }
      if (k === "/") { e.preventDefault(); pressOp("/"); return; }

      if (k === ".") { e.preventDefault(); pressDot(); return; }

      if (k === "Enter" || k === "=") { e.preventDefault(); pressEquals(); return; }

      if (k === "Backspace") { e.preventDefault(); pressBackspace(); return; }
      if (k === "Escape") { e.preventDefault(); pressClear(); return; }

      if (k === "F9") { e.preventDefault(); pressSign(); return; }
    }

    window.addEventListener("keydown", handleKeydown);

    function wordOrWordsToArray(v) {
      if (Array.isArray(v)) return v;
      if (typeof v === "string") return [v];
      return [];
    }

    function opWordsToCodepoints(opKey) {
      const words = wordOrWordsToArray(OP_BUTTON_WORDS[opKey]);
      if (words.length === 0) throw new Error(`No words configured for operator "${opKey}"`);
      return tpWordsToUcsurCodepoints(words);
    }

    function renderDisplay() {
      // Display text under the cartouche: commas in integer, underscores in fraction triplets
      const displayValue = formatNumberForDisplay(inputStr, { intSep: ",", fracSep: "_" });

      elDisplayText.textContent = displayValue;

      const pendingDisplay = (pendingOp != null && acc != null)
        ? `${formatNumberForDisplay(formatNumberForInput(acc), { intSep: ",", fracSep: "_" })} ${pendingOp}`
        : "";

      elPendingText.textContent = pendingDisplay;

      // Visible (bilingual) — mirrors the display values
      if (elDisplayTextVisible) elDisplayTextVisible.textContent = displayValue;
      if (elPendingTextVisible) elPendingTextVisible.textContent = pendingDisplay;
      if (elDisplayTextVisibleTp) elDisplayTextVisibleTp.textContent = displayValue;
      if (elPendingTextVisibleTp) elPendingTextVisibleTp.textContent = pendingDisplay;

      const properName = encodeDecimalToProperNameDisplay(inputStr);
      if (elProperNameText) elProperNameText.textContent = properName;

      // Live region: bilingual
      if (elDisplayLive) {
        if (inputStr === "Error") {
          elDisplayLive.textContent = "Error. Press Clear to reset. pakala. o pilin e nena Clear la, sina kama sin.";
          if (elProperNameText) elProperNameText.textContent = "";
        } else {
          const pendingTextLive = (pendingOp != null && acc != null) ? pendingDisplay : "none";
          elDisplayLive.textContent =
            `Value: ${displayValue}. Pending operation: ${pendingTextLive}. ` +
            `nanpa: ${displayValue}. pali awen: ${pendingTextLive}.`;
        }
      }



      if (inputStr === "Error") {
        const ctx = displayCanvas.getContext("2d");
        displayCanvas.style.width = "520px";
        displayCanvas.style.height = "120px";
        displayCanvas.width = 520 * (window.devicePixelRatio || 1);
        displayCanvas.height = 120 * (window.devicePixelRatio || 1);

        const dpr = window.devicePixelRatio || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, 520, 120);
        ctx.fillStyle = "#111";
        ctx.font = `48px system-ui`;
        ctx.fillText("Error", 24, 76);
        return;
      }

      // Cartouche rendering (encoding behavior depends on display mode)
      const cps = decimalToUcsurCodepoints(inputStr);

      const keysEl = document.getElementById("keys");
      const targetW = keysEl ? keysEl.getBoundingClientRect().width : displayCanvas.getBoundingClientRect().width;

      renderMixedCartoucheToCanvasFixedWidthRightAligned(
        displayCanvas,
        cps,
        DISPLAY_LARGE_PX,
        DISPLAY_SMALL_PX,
        smallSet,
        targetW,
        { padding: DISPLAY_PAD, border: DISPLAY_BORDER, cornerRadius: DISPLAY_CORNER, letterGap: DISPLAY_GAP }
      );
    }

    function resolveReduceWidthPx(reduceWidthPx, btn) {
      if (reduceWidthPx == null) return 0;

      if (typeof reduceWidthPx === "number" && Number.isFinite(reduceWidthPx)) {
        return Math.max(0, reduceWidthPx);
      }

      if (typeof reduceWidthPx === "string") {
        const s = reduceWidthPx.trim();
        const m = s.match(/^(\d+(?:\.\d+)?)%$/);
        if (m) {
          const pct = parseFloat(m[1]);
          if (!Number.isFinite(pct)) return 0;
          const w = btn.getBoundingClientRect().width;
          return Math.max(0, (pct / 100) * w);
        }

        const n = Number(s);
        if (Number.isFinite(n)) return Math.max(0, n);
      }

      return 0;
    }

    function makeButton({ id, kind, labelText, ariaLabel, onPress, renderFn, wide=false, reduceWidthPx=0 }) {
      const btn = document.createElement("button");
      btn.className = "btn" + (wide ? " btnWide" : "");
      btn.type = "button";
      btn.setAttribute("data-id", id);

      // ariaLabel is now expected to be bilingual (English / Toki Pona)
      btn.setAttribute("aria-label", ariaLabel || labelText || id);

      const c = document.createElement("canvas");
      c.className = "btnCanvas";
      c.setAttribute("aria-hidden", "true");
      btn.appendChild(c);

      if (labelText) {
        const lab = document.createElement("div");
        lab.className = "btnLabel mono";
        lab.textContent = labelText;
        btn.appendChild(lab);
      }

      btn.addEventListener("click", onPress);

      renderFn(c, btn);

      requestAnimationFrame(() => {
        const rwPx = resolveReduceWidthPx(reduceWidthPx, btn);
        if (rwPx > 0) {
          const BASE_PAD = 10;
          btn.style.paddingLeft = `${BASE_PAD + rwPx}px`;
          btn.style.paddingRight = `${BASE_PAD + rwPx}px`;

          if (typeof renderFn === "function") {
            renderFn(c, btn);
          }
        }
      });

      return btn;
    }

    function renderDigitButtonCanvas(canvas, digitStr, targetOuterWidthPx = null) {
      const cps = decimalToUcsurCodepoints(digitStr);

      if (targetOuterWidthPx == null) {
        renderMixedCartoucheToCanvas(
          canvas,
          cps,
          BTN_LARGE_PX,
          BTN_SMALL_PX,
          smallSet,
          { padding: BTN_PAD, border: BTN_BORDER, cornerRadius: BTN_CORNER, letterGap: BTN_GAP }
        );
        return;
      }

      renderMixedCartoucheToCanvasFixedWidthCentered(
        canvas,
        cps,
        BTN_LARGE_PX,
        BTN_SMALL_PX,
        smallSet,
        targetOuterWidthPx,
        { padding: BTN_PAD, border: BTN_BORDER, cornerRadius: BTN_CORNER, letterGap: BTN_GAP }
      );
    }

    function renderOpButtonCanvas(canvas, opKey, fontPx=34) {
      const cps = opWordsToCodepoints(opKey);
      renderGlyphsCentered(canvas, cps, fontPx);
    }

    function buildKeypad() {
      const keys = document.getElementById("keys");
      keys.innerHTML = "";

      const add = (spec) => keys.appendChild(makeButton(spec));

      add({
        id: "clr", kind: "op", labelText: "C",
        ariaLabel: "Clear / o weka e ale",
        onPress: pressClear,
        renderFn: (c) => renderOpButtonCanvas(c, "clr", 34)
      });

      add({
        id: "bk", kind: "op", labelText: "⌫",
        ariaLabel: "Backspace / o weka e sitelen pini",
        onPress: pressBackspace,
        renderFn: (c) => renderOpButtonCanvas(c, "bk", 34)
      });

      add({
        id: "sign", kind: "op", labelText: "±",
        ariaLabel: "Toggle sign / o ante e sinpin (+/-)",
        onPress: pressSign,
        renderFn: (c) => renderOpButtonCanvas(c, "sign", 34)
      });

      add({
        id: "add", kind: "op", labelText: "+",
        ariaLabel: "Add / o pana",
        onPress: () => pressOp("+"),
        renderFn: (c) => renderOpButtonCanvas(c, "add", 34)
      });

      for (const d of ["7","8","9"]) {
        add({
          id: "d"+d, kind: "digit",
          labelText: d,
          ariaLabel: `Digit ${d} / nanpa ${d}`,
          onPress: () => pressDigit(d),
          renderFn: (c) => renderDigitButtonCanvas(c, d)
        });
      }

      add({
        id: "sub", kind: "op", labelText: "−",
        ariaLabel: "Subtract / o weka",
        onPress: () => pressOp("-"),
        renderFn: (c) => renderOpButtonCanvas(c, "sub", 34)
      });

      for (const d of ["4","5","6"]) {
        add({
          id: "d"+d, kind: "digit",
          labelText: d,
          ariaLabel: `Digit ${d} / nanpa ${d}`,
          onPress: () => pressDigit(d),
          renderFn: (c) => renderDigitButtonCanvas(c, d)
        });
      }

      add({
        id: "mul", kind: "op", labelText: "×",
        ariaLabel: "Multiply / o mute",
        onPress: () => pressOp("*"),
        renderFn: (c) => renderOpButtonCanvas(c, "mul", 34)
      });

      for (const d of ["1","2","3"]) {
        add({
          id: "d"+d, kind: "digit",
          labelText: d,
          ariaLabel: `Digit ${d} / nanpa ${d}`,
          onPress: () => pressDigit(d),
          renderFn: (c) => renderDigitButtonCanvas(c, d)
        });
      }

      add({
        id: "div", kind: "op", labelText: "÷",
        ariaLabel: "Divide / o kipisi",
        onPress: () => pressOp("/"),
        renderFn: (c) => renderOpButtonCanvas(c, "div", 34)
      });

      add({
        id: "d0", kind: "digit",
        labelText: "0",
        ariaLabel: "Digit 0 / nanpa 0",
        onPress: () => pressDigit("0"),
        reduceWidthPx: "14%",
        renderFn: (c) => {
          requestAnimationFrame(() => {
            const btn = c.closest("button");
            if (!btn) { renderDigitButtonCanvas(c, "0"); return; }

            const rect = btn.getBoundingClientRect();
            const cs = window.getComputedStyle(btn);
            const padL = parseFloat(cs.paddingLeft) || 0;
            const padR = parseFloat(cs.paddingRight) || 0;

            const innerW = Math.max(0, rect.width - padL - padR);
            renderDigitButtonCanvas(c, "0", innerW);
          });
        },
        wide: true
      });

      add({
        id: "dot", kind: "op", labelText: ".",
        ariaLabel: "Decimal point / poka pi nanpa lili",
        onPress: pressDot,
        renderFn: (c) => renderOpButtonCanvas(c, "dot", 34)
      });

      add({
        id: "eq", kind: "op", labelText: "=",
        ariaLabel: "Equals / sama",
        onPress: pressEquals,
        renderFn: (c) => renderOpButtonCanvas(c, "eq", 34)
      });
    }

    function rerenderWideZeroKey() {
      const c = document.querySelector('button[data-id="d0"] canvas.btnCanvas');
      if (!c) return;

      const btn = c.closest("button");
      if (!btn) return;

      const rect = btn.getBoundingClientRect();
      const cs = window.getComputedStyle(btn);
      const padL = parseFloat(cs.paddingLeft) || 0;
      const padR = parseFloat(cs.paddingRight) || 0;

      const innerW = Math.max(0, rect.width - padL - padR);
      renderDigitButtonCanvas(c, "0", innerW);
    }

    window.addEventListener("load", async () => {
      await ensureFontLoaded();

      // Query param takes precedence; otherwise fall back to localStorage.
      const setByQuery = loadCartoucheDisplayModeFromQueryParam();
      if (!setByQuery) loadCartoucheDisplayModeFromStorage();

      wireCartoucheDisplayRadios();
      updateCrossLinksWithCartoucheDisplay();

      buildKeypad();
      renderDisplay();
    });

    window.addEventListener("resize", () => {
      renderDisplay();
      rerenderWideZeroKey();
    });
  </script>
</body>
</html>
