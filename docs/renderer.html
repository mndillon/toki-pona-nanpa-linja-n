<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toki Pona → Cartouche Calculator — toki pona tawa poki nimi</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;     /* unify background color */
      --muted: #3f4750;  /* CHANGED: darker for better contrast */
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .row { display: flex; gap: var(--gap); flex-wrap: wrap; align-items: flex-end; }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input[type="text"], textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg);
      font: inherit;
    }

    textarea { min-height: 84px; resize: vertical; }

    .col { flex: 1 1 320px; }

    button {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover {
      background: var(--bg);
    }

    /* NEW: bilingual button layout */
    .btnBi {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      line-height: 1.15;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    /* NEW: Toki Pona line (10pt) */
    .tpLine {
      display: block;
      margin-top: 2px;
      font-size: 10pt;
      color: var(--muted);
      line-height: 1.25;
    }

    .out { margin-top: 12px; }

    .out h3 { margin: 18px 0 8px; font-size: 14px; }

    canvas {
      display: block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: var(--bg);
      max-width: 100%;
    }

    .small { font-size: 12px; color: var(--muted); }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .hidden {
      display: none !important;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src: url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.otf") format("opentype");
      font-display: swap;
    }

    /* Digit reference table */
    .digitTable {
      table-layout: auto;          /* natural column sizing */
      width: max-content;          /* allow table to be wider than viewport */
      min-width: 100%;             /* but don't shrink below container */
      border-collapse: collapse;
    }

    /* Keep the unique number code from overflowing into the cartouche column */
    .digitTable th:nth-child(3),
    .digitTable td:nth-child(3) {
      white-space: nowrap;   /* keep code on one line */
    }

    .tableWrap {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .digitTable th,
    .digitTable td {
      border: 1px solid var(--border);
      padding: 8px;
      vertical-align: middle;
    }

    .digitTable th {
      text-align: left;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }

    .digitTable td {
      font-size: 13px;
    }

    .digitCanvas {
      display: block;
      max-width: 100%;
    }

    /* =========================
       WCAG-oriented affordances
       ========================= */

    /* Strong focus indicators */
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    textarea:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    /* Skip link (keyboard navigation) */
    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    /* Visually hidden but still accessible to screen readers */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: 0 !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    /* Prevent user agent forced color adjustments from destroying contrast in HC modes */
    .no-forced-adjust {
      forced-color-adjust: none;
    }

    /* =========================
       NEW: Cartouche display mode chooser (subtle)
       ========================= */
    .displayChooser {
      margin: 10px 0 6px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg);
    }

    .displayChooser legend {
      font-size: 12px;
      color: var(--muted);
      padding: 0 6px;
      font-weight: 700;
    }

    .displayOpt {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-right: 14px;
      font-size: 13px;
      color: #111;
      cursor: pointer;
      user-select: none;
    }

    .displayOpt input {
      transform: translateY(1px);
    }
  </style>

</head>

<body>
  <!-- Skip link for keyboard users -->
  <a href="#main" class="skipLink">
    Skip to content
    <span class="tpLine">o tawa lipu ni</span>
  </a>

  <!-- Main landmark for assistive tech -->
  <main class="card" id="main" role="main" aria-labelledby="pageTitle">

    <h1 style="margin:0 0 6px;font-size:18px;">
      Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer
      <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
    </h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> The “nanpa-linja-n proper name” shown here is an encoding label for numbers only.
      It is intended as a proper-name style identifier and does not propose or add any new Toki Pona lexicon.
      <span class="tpLine">
        sona: nimi “nanpa-linja-n proper name” li nimi pi pana nanpa taso.
        ona li sama nimi pi jan (nimi pi nimi) taso; ona li pana ala e nimi sin pi toki pona.
      </span>
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <span class="tpLine">
        sona: ilo ni li lon nasin “as is”. mi pana ala e wawa pi pona.
        sina o lukin e ni: sitelen li pona anu seme.
      </span>
    </div>

    <div class="help" style="margin-top:10px;">
      Inputs are treated as text to preserve formatting (e.g., trailing zeros).
      <span class="tpLine">pana li sitelen taso, tan ni: nanpa pini (0) li awen sama.</span>
    </div>

    <!-- Screen-reader live region for status/errors -->
    <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <!-- MOVED: Canvases now appear ABOVE the decimal input -->
    <div class="out" role="region" aria-label="Cartouche renderings">
      <!-- Canvases are decorative; authoritative text is the words/outputs below -->
      <div class="grid2" style="margin-top:14px;" role="group" aria-label="Cartouche renderings">
        <div>
          <h3>
            sitelen pona cartouche (small)
            <span class="tpLine">poki nimi sitelen pona (lili)</span>
          </h3>
          <canvas id="canvasSmall" aria-hidden="true"></canvas>
          <div class="help">
            Rendered with your font at a smaller size.
            <span class="tpLine">sitelen li kepeken font sina, lon suli lili.</span>
          </div>
          <div class="sr-only" id="canvasSmallDesc">
            Decorative cartouche rendering. Use the text outputs below for the accessible value.
          </div>
        </div>
        <div>
          <h3>
            sitelen pona cartouche (large)
            <span class="tpLine">poki nimi sitelen pona (suli)</span>
          </h3>
          <canvas id="canvasLarge" aria-hidden="true"></canvas>
          <div id="decimalValueLine" class="help hidden">
            <strong>Value:</strong> <span id="decimalValueText" class="mono"></span>
          </div>
          <div class="help">
            Rendered with your font at a large size.
            <span class="tpLine">sitelen li kepeken font sina, lon suli mute.</span>
          </div>
          <div class="sr-only" id="canvasLargeDesc">
            Decorative cartouche rendering. Use the text outputs below for the accessible value.
          </div>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:14px;" role="group" aria-label="Decimal input and encode action">
      <div class="col">
        <label for="decimalInput">
          Enter decimal value (in en-US locale format)
          <span class="tpLine">o pana e nanpa poka (nasin en-US)</span>
        </label>
        <input
          id="decimalInput"
          type="text"
          class="mono"
          value="28.95"
          maxlength="500"
          inputmode="text"
          aria-describedby="decimalHelp"
          aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge digitTable"
        />
        <div id="decimalHelp" class="help">
          Example formats: <span class="mono">0.00</span>; <span class="mono">.75</span>; <span class="mono">-12,340</span>;  <span class="mono">2000</span>; <span class="mono">5,000</span>; <span class="mono">9¾</span>; <span class="mono">8+1/2</span>; <span class="mono">7/8</span>; <span class="mono">64.5M</span>; <span class="mono">432-555-0189</span>.
          nanpa-linja-n encoder decides how to represent these.
          <span class="tpLine">
            nasin pi pana nanpa li ken ante. ilo nanpa-linja-n li kama e nasin sitelen pi nanpa ni.
          </span>
        </div>
      </div>

      <div style="flex: 0 0 auto;">
        <button id="btnEncode" type="button" class="btnBi" aria-describedby="btnEncodeHelp">
          <span>Encode &amp; Render</span>
          <span class="tpLine">o pana e nimi nanpa, o sitelen e poki nimi</span>
        </button>
        <div id="btnEncodeHelp" class="sr-only">
          Encodes the decimal input into a nanpa-linja-n proper name and renders the sitelen pona cartouches.
        </div>
      </div>
    </div>

    <!-- NEW: Cartouche display mode selector (subtle) -->
    <fieldset class="displayChooser" aria-label="Cartouche display mode">
      <legend>Cartouche display</legend>

      <label class="displayOpt">
        <input type="radio" name="cartoucheDisplay" value="traditional" checked>
        <span>Traditional</span>
      </label>

      <label class="displayOpt">
        <input type="radio" name="cartoucheDisplay" value="uniform">
        <span>Uniform</span>
      </label>

      <div class="help small" style="margin-top:6px;">
        Traditional: existing wording. Uniform: every <span class="mono">esun</span> → <span class="mono">en</span>, every <span class="mono">nasa</span> → <span class="mono">nena</span>, and every standalone <span class="mono">e</span> → <span class="mono">en</span>. Only <span class="mono">nanpa</span> at start and end is unchanged.
      </div>
    </fieldset>

    <div class="out" role="region" aria-label="Outputs">
      <h3>
        nanpa-linja-n proper name for decimal value
        <span class="tpLine">nimi pi pana nanpa (nanpa-linja-n)</span>
      </h3>
      <textarea id="latinOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        This is the Latin string you generate from the decimal input (nanpa-linja-n custom encoding). Spaces are added for readability and will NOT affect glyph mapping.
        <span class="tpLine">
          ni li sitelen Lasina tan nanpa pana. spasi li pona lukin taso; ona li ante ala e mapu pi sitelen.
        </span>
      </div>

      <h3>
        nanpa-linja-n unique number code
        <span class="tpLine">nimi nanpa wan pi nanpa-linja-n</span>
      </h3>
      <textarea id="numberCodeOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        Derived from the nanpa-linja-n proper name: remove letters <span class="mono">n</span> and <span class="mono">e</span>, uppercase everything else.
        <span class="tpLine">
          ni li tan nimi pi nanpa-linja-n: o weka e sitelen <span class="mono">n</span> en <span class="mono">e</span>; o ante e sitelen ante tawa sitelen suli.
        </span>
      </div>

      <div id="hexSection">
        <h3>
          nasin-nanpa font code points (including cartouche start and end codes) (hex)
          <span class="tpLine">nanpa sitelen (nasin hex)</span>
        </h3>
        <textarea id="codepointsOut" class="mono" readonly aria-readonly="true"></textarea>
        <div class="help">
          Space-separated hex code points (e.g., <span class="mono">F190B F1944 ...</span>) that nasin nanpa font uses.
          <span class="tpLine">
            ni li nanpa sitelen (hex) weka-spasi: ilo sitelen nasin nanpa li kepeken ona.
          </span>
        </div>
      </div>

      <h3>
        Toki Pona words (for code points excluding cartouche start and end codes)
        <span class="tpLine">nimi pi toki pona (tan nanpa sitelen)</span>
      </h3>
      <textarea id="tpWordsOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        One Toki Pona word per code point, in the same order as the code points output.
        <span class="tpLine">
          nanpa sitelen wan la, nimi toki pona wan. nasin li sama lon poka pi nanpa sitelen.
        </span>
      </div>

      <h3 style="margin-top:20px;">
        Reverse tool: Toki Pona words → glyphs
        <span class="tpLine">ilo ante: nimi toki pona → sitelen</span>
      </h3>

      <div id="fromCodesSection" class="hidden">
        <div class="row" role="group" aria-label="Render from code points">
          <div class="col">
            <label for="codepointsIn">
              Paste code points (hex, space-separated)
              <span class="tpLine">o pana e nanpa sitelen (hex, weka-spasi)</span>
            </label>
            <input
              id="codepointsIn"
              type="text"
              class="mono"
              placeholder="F190B F1944 F193D"
              maxlength="3500"
              aria-describedby="codepointsHelp"
              aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge"
            />
            <div id="codepointsHelp" class="help">
              Accepts <span class="mono">F190B</span> or <span class="mono">U+F190B</span>.
              Input is restricted to the Toki Pona UCSUR block (<span class="mono">F1900</span>–<span class="mono">F1988</span>) plus cartouche start/end markers.
              <span class="tpLine">
                sina ken pana e <span class="mono">F190B</span> anu <span class="mono">U+F190B</span>.
                pana li ken lon poki UCSUR pi toki pona taso (<span class="mono">F1900</span>–<span class="mono">F1988</span>) en sitelen open/pini pi poki nimi.
              </span>
            </div>
          </div>
          <div style="flex: 0 0 auto;">
            <button id="btnFromCodes" type="button" class="btnBi">
              <span>Render From Code Points</span>
              <span class="tpLine">o sitelen tan nanpa sitelen</span>
            </button>
          </div>
        </div>
      </div>

      <div class="row" style="margin-top:10px;" role="group" aria-label="Render from Toki Pona words">
        <div class="col">
          <label for="tpWordsIn">
            Enter Toki Pona words (space-separated)
            <span class="tpLine">o pana e nimi toki pona (weka-spasi)</span>
          </label>
          <input
            id="tpWordsIn"
            type="text"
            class="mono"
            placeholder="nanpa esun o nanpa"
            maxlength="2500"
            aria-describedby="tpWordsHelp"
            aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge"
            spellcheck="false"
            autocapitalize="none"
            autocomplete="off"
          />
          <div id="tpWordsHelp" class="help">
            Only valid Toki Pona words are allowed (case-insensitive) or a nanpa-linja-n proper name for a decimal value or a number code (starting with #~).
            <span class="tpLine">
              nimi toki pona lon mapu taso li ken. (suli/lili pi sitelen li wile ala.)
              sina ken kin pana e nimi pi nanpa-linja-n (nimi pi pana nanpa).
            </span>
          </div>
        </div>
        <div style="flex: 0 0 auto;">
          <button id="btnFromWords" type="button" class="btnBi">
            <span>Render From Toki Pona Words</span>
            <span class="tpLine">o sitelen tan nimi toki pona</span>
          </button>
        </div>
      </div>

      <h3 style="margin-top:20px;">
        Digit reference: 0–9
        <span class="tpLine">lipu sona pi nanpa: 0–9</span>
      </h3>
      <div class="help">
        Digit, its nanpa-linja-n proper name, its nanpa-linja-n unique number code, and a sitelen pona mixed-font cartouche.
        <span class="tpLine">
          nanpa, nimi pi nanpa-linja-n, nimi nanpa wan, en poki nimi sitelen pona (font tu).
        </span>
      </div>

      <div class="tableWrap">
        <table class="digitTable" id="digitTable">
          <caption class="sr-only">
            Reference table for digits 0 through 9, including nanpa-linja-n labels and decorative cartouches.
          </caption>
          <thead>
            <tr>
              <th scope="col" style="width:80px;">
                Digit
                <span class="tpLine">nanpa</span>
              </th>
              <th scope="col">
                nanpa-linja-n proper name
                <span class="tpLine">nimi pi nanpa-linja-n</span>
              </th>
              <th scope="col">
                nanpa-linja-n unique number code
                <span class="tpLine">nimi nanpa wan</span>
              </th>
              <th scope="col" style="width:220px;">
                sitelen pona cartouche
                <span class="tpLine">poki nimi sitelen pona</span>
              </th>
            </tr>
          </thead>
          <tbody id="digitTableBody">
            <!-- rows generated by JS -->
          </tbody>
        </table>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n cartouche calculator
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <!-- CHANGED: give this link an id so JS can append the query param -->
        <a id="calculatorLink" class="repoLink" href="./calculator.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n cartouche calculator
        </a>
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona sitelen pona fonts
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n/tree/main/docs/fonts" target="_blank" rel="noopener noreferrer">
          sitelen pona nanpa-linja-n fonts
        </a>
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </div>

      <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n main documentation
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n main documentation
        </a>
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </div>

      <div class="help">#~n</div>
    </div>
  </main>

  <script>
    "use strict";

    /* ============================================================
       Accessibility helpers
       ============================================================ */

    const elSrStatus = document.getElementById("srStatus");

    function announceStatus(msg) {
      if (!elSrStatus) return;
      elSrStatus.textContent = String(msg ?? "");
    }

    function showAlertAndAnnounce(msg) {
      const s = String(msg ?? "Unknown error");
      announceStatus(s);
      alert(s);
    }

    /* ============================================================
       NEW: Cartouche display mode (Traditional vs Uniform)
       - Traditional: existing wording
       - Uniform: every "esun" -> "en", every "nasa" -> "nena", every standalone "e" -> "en"
       - Only "nanpa" at start and end remains unchanged.
       ============================================================ */

    const CARTOUCHE_DISPLAY_STORAGE_KEY = "cartoucheDisplayMode";

    // NEW: query-param name so this page can be linked consistently
    // Example: ?cartoucheDisplay=uniform
    const CARTOUCHE_DISPLAY_QUERY_PARAM = "cartoucheDisplay";

    let lastAction = "decimal"; // "decimal" | "codes" | "words"

    function getCartoucheDisplayMode() {
      const el = document.querySelector('input[name="cartoucheDisplay"]:checked');
      return (el && (el.value === "uniform" || el.value === "traditional")) ? el.value : "traditional";
    }

    function setCartoucheDisplayMode(mode) {
      const v = (mode === "uniform") ? "uniform" : "traditional";
      const target = document.querySelector(`input[name="cartoucheDisplay"][value="${v}"]`);
      if (target) target.checked = true;
      try { localStorage.setItem(CARTOUCHE_DISPLAY_STORAGE_KEY, v); } catch {}
    }

    function loadCartoucheDisplayModeFromStorage() {
      try {
        const v = localStorage.getItem(CARTOUCHE_DISPLAY_STORAGE_KEY);
        if (v === "uniform" || v === "traditional") setCartoucheDisplayMode(v);
      } catch {}
    }

    // NEW: read display mode from query param; returns "uniform" | "traditional" | null
    function readCartoucheDisplayModeFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const v = String(params.get(CARTOUCHE_DISPLAY_QUERY_PARAM) ?? "").toLowerCase().trim();
        if (v === "uniform" || v === "traditional") return v;
      } catch {}
      return null;
    }

    // NEW: apply precedence: query param (if valid) overrides localStorage; otherwise localStorage
    function applyCartoucheDisplayModeFromQueryOrStorage() {
      const q = readCartoucheDisplayModeFromQuery();
      if (q) {
        setCartoucheDisplayMode(q); // also persists to localStorage
        return;
      }
      loadCartoucheDisplayModeFromStorage();
    }

    // NEW: update the calculator.html link so it includes the current selection
    function updateCalculatorLinkWithDisplayParam() {
      const a = document.getElementById("calculatorLink");
      if (!a) return;

      try {
        const href = a.getAttribute("href") || "./calculator.html";
        const u = new URL(href, window.location.href);
        u.searchParams.set(CARTOUCHE_DISPLAY_QUERY_PARAM, getCartoucheDisplayMode());

        // keep href relative-ish (works for ./calculator.html and for absolute URLs)
        if (u.origin === window.location.origin) {
          const rel = u.pathname + (u.search || "") + (u.hash || "");
          a.setAttribute("href", rel);
        } else {
          a.setAttribute("href", u.toString());
        }
      } catch {
        // If URL construction fails, fall back to appending manually (best-effort)
        const base = (a.getAttribute("href") || "./calculator.html").split("?")[0];
        a.setAttribute("href", `${base}?${CARTOUCHE_DISPLAY_QUERY_PARAM}=${encodeURIComponent(getCartoucheDisplayMode())}`);
      }
    }

    function wireCartoucheDisplayRadios() {
      const radios = document.querySelectorAll('input[name="cartoucheDisplay"]');
      radios.forEach(r => {
        r.addEventListener("change", () => {
          setCartoucheDisplayMode(getCartoucheDisplayMode());
          updateCalculatorLinkWithDisplayParam(); // NEW
          buildDigitReferenceTable();

          // Re-render based on the user's most recent action.
          if (lastAction === "words") document.getElementById("btnFromWords")?.click();
          else if (lastAction === "codes") document.getElementById("btnFromCodes")?.click();
          else document.getElementById("btnEncode")?.click();
        });
      });
    }

    /* ============================================================
       Proper-name display formatting (Title Case per word)
       ============================================================ */

    function titleCaseNanpaProperNameForDisplay(nameStr) {
      const s = String(nameStr ?? "").trim();
      if (!s) return s;
      return s
        .split(/\s+/)
        .filter(Boolean)
        .map(w => {
          const lower = w.toLowerCase();
          if (lower.length === 1) return lower.toUpperCase();
          return lower[0].toUpperCase() + lower.slice(1);
        })
        .join(" ");
    }

    /* ============================================================
       Vulgar fraction input support (e.g., 9¾, ¾, ⅜, etc.)
       ============================================================ */

    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]],
    ]);

    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      s = s.replace(/\u2044/g, "/");

      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return s;

      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
      }
      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      if (!prefixRaw) return `${num}/${den}`;

      const isNeg = prefixRaw.startsWith("-");
      const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

      if (!prefix) {
        return `-${num}/${den}`;
      }

      const normalized = isNeg
        ? `-${prefix}+${num}/${den}`
        : `${prefix}+${num}/${den}`;

      if (normalized.slice(1).includes("-")) {
        throw new Error("Normalization produced an invalid negative sign placement.");
      }

      return normalized;
    }

    /* ============================================================
       MAPPING: Latin "glyph-string" chars -> font code points
       ============================================================ */

    const FONT_FAMILY = "TP-Cartouche-Font";

    const LATIN_CHAR_TO_CODEPOINT = {
      "0": 0xF1901,
      "1": 0xF1901,
      "2": 0xF1901,
      "3": 0xF1901,
      "4": 0xF1901,
      "5": 0xF190B,
      "6": 0xF1901,
      "7": 0xF1901,
      "8": 0xF1901,
      "9": 0xF1901,
      ".": 0xF1901,
      "-": 0xF1901,
    };

    const CODEPOINT_TO_LATIN_CHAR = new Map(
      Object.entries(LATIN_CHAR_TO_CODEPOINT).map(([ch, cp]) => [cp, ch])
    );

    function getSmallCodepointsSet() {
      return new Set([
        0xF193D, // NANPA
        0xF1940, // NENA
        0xF1941, // NI
        0xF193E, // NASA
        0xF1909, // E
        0xF190B, // ESUN
        0xF190A, // EN
      ]);
    }

    const TP_UCSUR_MIN = 0xF1900;
    const TP_UCSUR_MAX = 0xF1988;

    // cartouche start/end markers to show in HEX output
    const CARTOUCHE_START_CP = 0xF1990;
    const CARTOUCHE_END_CP   = 0xF1991;

    function withCartoucheMarkers(codepoints) {
      const cps = Array.from(codepoints ?? []);
      return [CARTOUCHE_START_CP, ...cps, CARTOUCHE_END_CP];
    }

    function stripCartoucheMarkers(codepoints) {
      const cps = Array.from(codepoints ?? []);
      if (cps.length >= 2 && cps[0] === CARTOUCHE_START_CP && cps[cps.length - 1] === CARTOUCHE_END_CP) {
        return cps.slice(1, -1);
      }
      return cps;
    }

    function isAllowedTpUcsurCodepoint(cp) {
      return (
        Number.isInteger(cp) &&
        (
          (cp >= TP_UCSUR_MIN && cp <= TP_UCSUR_MAX) ||
          cp === CARTOUCHE_START_CP ||
          cp === CARTOUCHE_END_CP
        )
      );
    }

    function assertAllAllowedTpUcsur(codepoints) {
      for (const cp of codepoints) {
        if (!isAllowedTpUcsurCodepoint(cp)) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(
            `Disallowed code point U+${hex}. Allowed range is U+${TP_UCSUR_MIN.toString(16).toUpperCase()}..U+${TP_UCSUR_MAX.toString(16).toUpperCase()} plus cartouche markers U+${CARTOUCHE_START_CP.toString(16).toUpperCase()} and U+${CARTOUCHE_END_CP.toString(16).toUpperCase()}.`
          );
        }
      }
    }

    /* ============================================================
       PYTHON-ALGORITHM PORT (core pieces)
       ============================================================ */

    const DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    const TOKEN_TO_DIGIT_WORD = {
      "NI": "ijo", "WE": "wan", "TE": "tu", "SE": "sijelo", "NA": "awen",
      "LE": "luka", "NU": "utala", "ME": "mun", "PE": "pipi", "JE": "jo",
    };

    const OPCHAR_TO_TOKEN = { ".": "NONE", "-": "NO", "/": "NONO", "+": "NONONO" };
    const MAGCHAR_TO_TOKEN = { "T": "KE", "M": "KEKE", "W": "KEKEKE" };
    const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));

    const TOKEN_PREFIXES = [ "KEKEKE", "KEKE", "KE", "NONONO", "NONO", "NE", "NO" ];

    // Reverse map: digit word -> token
    const DIGIT_WORD_TO_TOKEN = Object.fromEntries(
      Object.entries(TOKEN_TO_DIGIT_WORD).map(([tok, w]) => [w, tok])
    );

    function normalizeTpWord(raw) {
      return String(raw ?? "").toLowerCase().replace(/[^a-z]/g, "");
    }

    /**
     * Try to recognize and decode a nanpa-linja-n TP-words encoded number phrase:
     *   nanpa esun|en ... nanpa
     *
     * Accepts both Traditional and Uniform mode wordings:
     * - Start: "nanpa esun" or "nanpa en"
     * - After digits: "<digitWord> esun" or "<digitWord> en"
     * - NE (non-initial): "(nasa|nena) (e|en)"
     * - KE: "kulupu (e|en)"
     * - NONONO: (nasa|nena) o x3
     */
    function tryParseNanpaLinjanTpPhraseToCaps(input) {
      const words = String(input ?? "")
        .trim()
        .split(/\s+/)
        .map(normalizeTpWord)
        .filter(Boolean);

      // Must be at least: "nanpa esun|en ... nanpa"
      if (words.length < 3) return null;
      if (words[0] !== "nanpa") return null;
      if (!(words[1] === "esun" || words[1] === "en")) return null;
      if (words[words.length - 1] !== "nanpa") return null;

      const end = words.length - 1;

      const capsParts = ["NE"]; // start token is always NE
      let i = 2;

      while (i < end) {
        // 1) NONONO: "(nasa|nena) o" repeated 3 times
        if (
          i + 5 < end &&
          (words[i] === "nasa" || words[i] === "nena") && words[i + 1] === "o" &&
          (words[i + 2] === "nasa" || words[i + 2] === "nena") && words[i + 3] === "o" &&
          (words[i + 4] === "nasa" || words[i + 4] === "nena") && words[i + 5] === "o"
        ) {
          capsParts.push("NONONO");
          i += 6;
          continue;
        }

        // 2) NONO: "nena o nena o"
        if (
          i + 3 < end &&
          words[i] === "nena" && words[i + 1] === "o" &&
          words[i + 2] === "nena" && words[i + 3] === "o"
        ) {
          capsParts.push("NONO");
          i += 4;
          continue;
        }

        // 3) NE (non-initial): "(nasa|nena) (e|en)"
        if (
          i + 1 < end &&
          (words[i] === "nasa" || words[i] === "nena") &&
          (words[i + 1] === "e" || words[i + 1] === "en")
        ) {
          capsParts.push("NE");
          i += 2;
          continue;
        }

        // 4) KE... : one or more "kulupu (e|en)" pairs become "KE" repeated
        if (i + 1 < end && words[i] === "kulupu" && (words[i + 1] === "e" || words[i + 1] === "en")) {
          let count = 0;
          while (i + 1 < end && words[i] === "kulupu" && (words[i + 1] === "e" || words[i + 1] === "en")) {
            count += 1;
            i += 2;
          }
          capsParts.push("KE".repeat(count));
          continue;
        }

        // 5) Digits:
        //    - "<digitWord> (esun|en)"
        //    - "(nasa|nena) <digitWord>" for NI/NA/NU style
        if (i + 1 < end) {
          // "(nasa|nena) ijo/awen/utala"
          if ((words[i] === "nasa" || words[i] === "nena") && DIGIT_WORD_TO_TOKEN[words[i + 1]]) {
            const tok = DIGIT_WORD_TO_TOKEN[words[i + 1]];
            if (tok === "NI" || tok === "NA" || tok === "NU") {
              capsParts.push(tok);
              i += 2;
              continue;
            }
          }

          // "wan (esun|en)", "tu (esun|en)", ...
          if (DIGIT_WORD_TO_TOKEN[words[i]] && (words[i + 1] === "esun" || words[i + 1] === "en")) {
            capsParts.push(DIGIT_WORD_TO_TOKEN[words[i]]);
            i += 2;
            continue;
          }
        }

        // 6) NO: "(nasa|nena|ni) o"
        if (i + 1 < end) {
          const w0 = words[i], w1 = words[i + 1];
          if (
            ((w0 === "nasa" || w0 === "nena" || w0 === "ni") && w1 === "o")
          ) {
            capsParts.push("NO");
            i += 2;
            continue;
          }
        }

        return null;
      }

      const caps = capsParts.join("") + "N";

      // Validate tokenization
      tokenizeNanpaCaps(caps);

      return { caps, words };
    }

    // -------------------------------
    // #~ number-code parsing
    // -------------------------------

    const NUMBER_CODE_LETTER_TO_PAIR = {
      "I": "NI",
      "W": "WE",
      "T": "TE",
      "S": "SE",
      "A": "NA",
      "L": "LE",
      "U": "NU",
      "M": "ME",
      "P": "PE",
      "J": "JE",
      // O and K are handled as run-length tokens (NO / KE).
    };

    function normalizeNumberCodeInput(raw) {
      return String(raw ?? "").trim().replace(/\s+/g, "");
    }

    function tryParseNanpaLinjanNumberCodeToCaps(raw) {
      const s0 = normalizeNumberCodeInput(raw);
      if (!s0) return null;

      if (!s0.toUpperCase().startsWith("#~")) return null;

      const body = s0.slice(2).toUpperCase();
      if (!body) throw new Error("Number code '#~' must have letters after it.");

      if (!/^[A-Z]+$/.test(body)) {
        throw new Error("Number code may only contain letters A–Z after '#~'.");
      }

      const parts = ["NE"];
      let i = 0;

      while (i < body.length) {
        const ch = body[i];

        if (ch === "O") {
          let j = i;
          while (j < body.length && body[j] === "O") j++;
          const count = j - i;

          if (count < 1 || count > 3) throw new Error("Invalid run of 'O' in number code (max 3).");

          parts.push("NO".repeat(count));
          i = j;
          continue;
        }

        if (ch === "K") {
          let j = i;
          while (j < body.length && body[j] === "K") j++;
          const count = j - i;

          if (count < 1 || count > 3) throw new Error("Invalid run of 'K' in number code (max 3).");

          parts.push("KE".repeat(count));
          i = j;
          continue;
        }

        const pair = NUMBER_CODE_LETTER_TO_PAIR[ch];
        if (!pair) {
          throw new Error(`Invalid letter '${ch}' in number code. Allowed: I,W,T,S,A,L,U,M,P,J plus O/K runs.`);
        }

        parts.push(pair);
        i += 1;
      }

      const caps = parts.join("") + "N";

      tokenizeNanpaCaps(caps);

      const canonicalCode = "#~" + body;
      return { caps, canonicalCode };
    }

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar=",") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      const codeGroupedFrac = groups.join(sepChar);
      return `${left}${decimalChar}${codeGroupedFrac}${suffix}`;
    }

    function latinNameToNumberCode(latinName) {
      const s = String(latinName ?? "");
      const noSpaces = s.replace(/\s+/g, "");
      const withoutNE = noSpaces.replace(/[nNeE]/g, "");
      return "#~" + withoutNE.toUpperCase();
    }

    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    function numberStrToNanpaCaps(
      s,
      { thousandsChar = ",", groupFractionTriplets = false, fractionGroupSize = 3 } = {}
    ) {
      if (s == null) throw new Error("s must be a string, not null");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, thousandsChar);
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          if (out.length > 0 && out[out.length - 1] === "NENE") return;
          out.push("NENE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount = (last === "T") ? 1 : (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NEKE");
            for (const d of groups[idx]) out.push(DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            for (let i = 0; i < trailingZeroGroups; i++) out.push("KE");
          }
        }

        if (hasDecimal) {
          out.push(OPCHAR_TO_TOKEN["."]);
          for (const ch of fracPart) {
            if (ch === "_" ) continue;
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          for (let i = 0; i < magnitudeSuffixKeCount; i++) out.push("KE");
        }

        out.push("N");
        return out.join("");
      }

      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
      }

      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);
        return numCaps + "NONO" + denCaps;
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const n = s.length;

      while (i < n - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= n - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    const TOKEN_TO_DIGIT_CHAR = {
      "NI": "0", "WE": "1", "TE": "2", "SE": "3", "NA": "4",
      "LE": "5", "NU": "6", "ME": "7", "PE": "8", "JE": "9",
    };

    function keTokenCount(t) {
      if (t === "KE") return 1;
      if (t === "KEKE") return 2;
      if (t === "KEKEKE") return 3;
      return 0;
    }

    function decodeDecimalStyleTokensToString(segmentTokens) {
      if (!segmentTokens) return null;

      const tokens = Array.from(segmentTokens);

      let i = 0;
      const end = tokens.length;

      let neg = false;
      if (i < end && tokens[i] === "NO" && !(i + 1 < end && tokens[i + 1] === "NE")) {
        neg = true;
        i += 1;
      }

      let mode = "int";
      let intStr = "";
      let fracStr = "";
      let suffixKeCount = 0;

      function appendInt(ch) { intStr += ch; }
      function appendFrac(ch) { fracStr += ch; }

      function ensureIntNonEmpty() {
        if (!intStr) intStr = "0";
      }

      function appendGroupSep() {
        const sep = (mode === "int") ? "," : "_";

        if (mode === "int") {
          if (!intStr) return;
          if (!intStr.endsWith(sep)) intStr += sep;
        } else {
          if (!fracStr) return;
          if (!fracStr.endsWith(sep)) fracStr += sep;
        }
      }

      while (i < end) {
        const t = tokens[i];

        if (TOKEN_TO_DIGIT_CHAR[t] != null) {
          if (mode === "int") appendInt(TOKEN_TO_DIGIT_CHAR[t]);
          else appendFrac(TOKEN_TO_DIGIT_CHAR[t]);
          i += 1;
          continue;
        }

        if (t === "NO" && (i + 1 < end) && tokens[i + 1] === "NE") {
          if (mode !== "int") return null;
          ensureIntNonEmpty();
          mode = "frac";
          i += 2;
          continue;
        }

        if (t === "NE" && (i + 1 < end) && tokens[i + 1] === "NE") {
          appendGroupSep();
          i += 2;
          continue;
        }

        if (t === "NE" && (i + 1 < end)) {
          let j = i + 1;
          let count = 0;

          while (j < end) {
            const c = keTokenCount(tokens[j]);
            if (!c) break;
            count += c;
            j += 1;
          }

          if (count > 0) {
            if (j < end && TOKEN_TO_DIGIT_CHAR[tokens[j]] != null) {
              appendGroupSep();
              i = j;
              continue;
            }

            suffixKeCount += count;
            i = j;
            continue;
          }

          return null;
        }

        if (keTokenCount(t) > 0) return null;

        return null;
      }

      ensureIntNonEmpty();

      let suffix = "";
      if (suffixKeCount > 0) {
        if (suffixKeCount === 1) suffix = "T";
        else if (suffixKeCount === 2) suffix = "M";
        else if (suffixKeCount === 3) suffix = "B";
        else suffix = `×1000^${suffixKeCount}`;
      }

      const sign = neg ? "-" : "";
      if (mode === "frac") {
        const fracNormalized = (fracStr === "") ? "0" : fracStr;
        return sign + intStr + "." + fracNormalized + suffix;
      }

      return sign + intStr + suffix;
    }

    function tryDecodeCapsToDisplayValue(caps) {
      if (!caps) return null;

      const tokens = tokenizeNanpaCaps(String(caps).trim().toUpperCase());
      if (tokens.length < 2 || tokens[0] !== "NE" || tokens[tokens.length - 1] !== "N") return null;

      const finalNIdx = tokens.length - 1;

      const mixedIdx = tokens.indexOf("NONONO");
      if (mixedIdx >= 0) {
        const fracIdx = tokens.indexOf("NONO", mixedIdx + 1);
        if (fracIdx < 0) return null;

        const intTokens = tokens.slice(1, mixedIdx);
        const numTokens = tokens.slice(mixedIdx + 1, fracIdx);
        const denTokens = tokens.slice(fracIdx + 1, finalNIdx);

        const intStr = decodeDecimalStyleTokensToString(intTokens);
        const numStr = decodeDecimalStyleTokensToString(numTokens);
        const denStr = decodeDecimalStyleTokensToString(denTokens);

        if (!intStr || !numStr || !denStr) return null;

        return `${intStr}+${numStr}/${denStr}`;
      }

      const fracIdx = tokens.indexOf("NONO");
      if (fracIdx >= 0) {
        const numTokens = tokens.slice(1, fracIdx);
        const denTokens = tokens.slice(fracIdx + 1, finalNIdx);

        const numStr = decodeDecimalStyleTokensToString(numTokens);
        const denStr = decodeDecimalStyleTokensToString(denTokens);

        if (!numStr || !denStr) return null;

        return `${numStr}/${denStr}`;
      }

      const segTokens = tokens.slice(1, finalNIdx);
      return decodeDecimalStyleTokensToString(segTokens);
    }

    function setDecimalValueFromCapsOrClear(caps) {
      const v = tryDecodeCapsToDisplayValue(caps);
      setDecimalValueLine(v);
    }

    /**
     * Convert nanpa-caps tokens into TP words.
     * Traditional vs Uniform controlled by { mode }:
     * - Uniform affects ALL occurrences of:
     *   - esun -> en
     *   - nasa -> nena
     *   - e -> en
     * - Only "nanpa" at start and end remains "nanpa".
     */
    function nanpaCapsTokensToTpWords(tokens, { mode = "traditional" } = {}) {
      if (!tokens || tokens.length === 0) return [];

      const uniform = (mode === "uniform");
      const out = [];

      // Uniform: esun -> en everywhere
      const E_WORD = uniform ? "en" : "esun";

      // Uniform: standalone e -> en everywhere
      const E_WORD_FOR_NE_AFTER_START = uniform ? "en" : "e";

      // Uniform: nasa -> nena everywhere
      const N_WORD = uniform ? "nena" : "nasa";

      // In traditional, NO is context-sensitive: ni/nena; in uniform, NO uses nena anyway
      const N_WORD_DECIMAL_POINT = uniform ? "nena" : "ni";
      const N_WORD_FRACTION = "nena";

      // Start/end are always nanpa
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) {
            // Start is always "nanpa", but the second word is affected (esun -> en)
            out.push("nanpa", E_WORD);
            afterStartingNe = true;
          } else {
            // Non-initial NE: (nasa|nena) (e|en)
            out.push(N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
          }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          // These digit tokens historically use "nasa <digitWord>" for NI/NA/NU
          // Uniform changes "nasa" -> "nena" via N_WORD.
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD); // Uniform changes esun -> en via E_WORD.
          continue;
        }

        if (t === "NO") {
          if (afterStartingNe) {
            // Right after start NE, it's "nasa o" traditionally; uniform makes it "nena o"
            out.push(N_WORD, "o");
            afterStartingNe = false;
          } else {
            let nWordToUse = N_WORD_DECIMAL_POINT;
            const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
            const prev = (i - 1 > 0) ? tokens[i - 1] : null;
            if (prev === "NO" || nxt === "NO") nWordToUse = N_WORD_FRACTION;
            out.push(nWordToUse, "o");
            afterStartingNe = false;
          }
          continue;
        }

        if (t === "NONO") {
          out.push("nena","o","nena","o");
          afterStartingNe = false;
          continue;
        }

        if (t === "NONONO") {
          // Uniform affects nasa -> nena via N_WORD
          out.push(N_WORD,"o",N_WORD,"o",N_WORD,"o");
          afterStartingNe = false;
          continue;
        }

        // Uniform affects "e" -> "en" via E_WORD_FOR_NE_AFTER_START
        if (t === "KE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }

    const WORD_TO_UCSUR_CP = {
      "nanpa": 0xF193D,
      "esun":  0xF190B,
      "en":    0xF190A,
      "e":     0xF1909,
      "nasa":  0xF193E,
      "ni":    0xF1941,
      "nena":  0xF1940,
      "o":     0xF1944,
      "kulupu":0xF191F,

      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "sijelo":0xF195B,
      "awen":  0xF1908,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913,

      "a": 0xF1900,
      "akesi": 0xF1901,
      "ala": 0xF1902,
      "alasa": 0xF1903,
      "ale": 0xF1904,
      "ali": 0xF1904,
      "anpa": 0xF1905,
      "ante": 0xF1906,
      "anu": 0xF1907,
      "ike": 0xF190D,
      "ilo": 0xF190E,
      "insa": 0xF190F,
      "jaki": 0xF1910,
      "jan": 0xF1911,
      "jelo": 0xF1912,
      "kala": 0xF1914,
      "kalama": 0xF1915,
      "kama": 0xF1916,
      "kasi": 0xF1917,
      "ken": 0xF1918,
      "kepeken": 0xF1919,
      "kili": 0xF191A,
      "kiwen": 0xF191B,
      "ko": 0xF191C,
      "kon": 0xF191D,
      "kule": 0xF191E,
      "kute": 0xF1920,
      "la": 0xF1921,
      "lape": 0xF1922,
      "laso": 0xF1923,
      "lawa": 0xF1924,
      "len": 0xF1925,
      "lete": 0xF1926,
      "li": 0xF1927,
      "lili": 0xF1928,
      "linja": 0xF1929,
      "lipu": 0xF192A,
      "loje": 0xF192B,
      "lon": 0xF192C,
      "lukin": 0xF192E,
      "lupa": 0xF192F,
      "ma": 0xF1930,
      "mama": 0xF1931,
      "mani": 0xF1932,
      "meli": 0xF1933,
      "mi": 0xF1934,
      "mije": 0xF1935,
      "moku": 0xF1936,
      "moli": 0xF1937,
      "monsi": 0xF1938,
      "mu": 0xF1939,
      "musi": 0xF193B,
      "mute": 0xF193C,
      "nasin": 0xF193F,
      "nimi": 0xF1942,
      "noka": 0xF1943,
      "olin": 0xF1945,
      "ona": 0xF1946,
      "open": 0xF1947,
      "pakala": 0xF1948,
      "pali": 0xF1949,
      "pini": 0xF1950,
      "poka": 0xF1952,
      "poki": 0xF1953,
      "pona": 0xF1954,
      "pu": 0xF1955,
      "sama": 0xF1956,
      "seli": 0xF1957,
      "selo": 0xF1958,
      "seme": 0xF1959,
      "sewi": 0xF195A,
      "sike": 0xF195C,
      "sin": 0xF195D,
      "sina": 0xF195E,
      "sinpin": 0xF195F,
      "sitelen": 0xF1960,
      "sona": 0xF1961,
      "soweli": 0xF1962,
      "suli": 0xF1963,
      "suno": 0xF1964,
      "supa": 0xF1965,
      "suwi": 0xF1966,
      "tan": 0xF1967,
      "taso": 0xF1968,
      "tawa": 0xF1969,
      "telo": 0xF196A,
      "tenpo": 0xF196B,
      "toki": 0xF196C,
      "tomo": 0xF196D,
      "unpa": 0xF196F,
      "uta": 0xF1970,
      "walo": 0xF1972,
      "waso": 0xF1974,
      "wawa": 0xF1975,
      "weka": 0xF1976,
      "wile": 0xF1977,
      "namako": 0xF1978,
      "kin": 0xF1979,
      "oko": 0xF197A,
      "kipisi": 0xF197B,
      "leko": 0xF197C,
      "monsuta": 0xF197D,
      "tonsi": 0xF197E,
      "jasima": 0xF197F,
      "kijetesantakalu": 0xF1980,
      "soko": 0xF1981,
      "meso": 0xF1982,
      "epiku": 0xF1983,
      "kokosila": 0xF1984,
      "lanpan": 0xF1985,
      "n": 0xF1986,
      "misikeke": 0xF1987,
      "ku": 0xF1988,
    };

    const UCSUR_CP_TO_WORD = new Map(
      Object.entries(WORD_TO_UCSUR_CP).map(([w, cp]) => [cp, w])
    );

    function ucsurCodepointsToTpWords(codepoints) {
      const words = [];
      for (const cp of codepoints) {
        const w = UCSUR_CP_TO_WORD.get(cp);
        if (!w) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(`No Toki Pona word mapping for code point U+${hex}`);
        }
        words.push(w);
      }
      return words;
    }

    function tpWordsToText(words) {
      return (words ?? []).join(" ");
    }

    function parseTpWordsToCodepoints(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return [];

      const parts = raw.split(/\s+/).filter(Boolean);

      const cps = [];
      for (const p of parts) {
        const w = p.toLowerCase();
        const cp = WORD_TO_UCSUR_CP[w];
        if (cp == null) {
          throw new Error(`Invalid Toki Pona word "${p}". Only mapped words are allowed.`);
        }
        cps.push(cp);
      }

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function tpWordsToUcsurCodepoints(words) {
      const cps = [];
      for (const w of words) {
        const key = String(w).toLowerCase();
        const cp = WORD_TO_UCSUR_CP[key];
        if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
        cps.push(cp);
      }
      return cps;
    }

    function decimalToUcsurCodepoints(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return [];

      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function splitCartoucheCapsLetters(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      let outStr = "";
      let i = 0;
      const end = s0.length - 1;

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);
        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { outStr += "neno "; i += 4; continue; }
        if (pair === "NE" && nextPair === "NE") { outStr += "n "; outStr += "ene "; i += 4; continue; }
        if (pair === "NO" && nextPair === "NE" && i > 0) { outStr += "n "; outStr += "one "; i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          outStr += "n ";
          outStr += "o";
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          outStr += "no".repeat(countNo);
          if ((i + 2 * countNo) < end) outStr += " ";
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          outStr += "n ";
          outStr += "e";
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          outStr += "ke".repeat(countKe);
          if ((i + 2 * countKe) < end) outStr += " ";
          i += 2 + 2 * countKe;
          continue;
        }

        outStr += pair.toLowerCase();
        i += 2;
      }

      outStr = outStr.replace(/\s+n(?=\s|$)/g, "n");
      outStr = outStr.trim();
      outStr += "n";
      return outStr;
    }

    function encodeDecimalToLatin(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return "";
      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });
      return splitCartoucheCapsLetters(caps);
    }

    function isValidNanpaLinjanProperName(raw) {
      const s = String(raw ?? "").replace(/\s+/g, "");
      if (!s) return false;
      if (!/^[a-zA-Z]+$/.test(s)) return false;
      if (!/[nN]$/.test(s)) return false;

      const core = s.slice(0, -1);
      if (core.length < 2 || (core.length % 2) !== 0) return false;

      const caps = core.toUpperCase() + "N";
      if (!caps.startsWith("NE")) return false;

      try { tokenizeNanpaCaps(caps); return true; }
      catch { return false; }
    }

    function splitCartoucheCapsLettersSpaced(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      const parts = [];
      let current = "";
      let i = 0;
      const end = s0.length - 1;

      function flushCurrent() {
        if (current) { parts.push(current); current = ""; }
      }

      function attachDelimiterN() {
        if (current) { current += "n"; flushCurrent(); return; }
        if (parts.length === 0) { parts.push("n"); return; }
        parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      }

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);

        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { flushCurrent(); parts.push("neno"); i += 4; continue; }

        if (pair === "NE" && nextPair === "NE") { flushCurrent(); attachDelimiterN(); parts.push("ene"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NE" && i > 0) { flushCurrent(); attachDelimiterN(); parts.push("one"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          flushCurrent();
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          attachDelimiterN();
          parts.push("o" + "no".repeat(countNo));
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          flushCurrent();
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          attachDelimiterN();
          parts.push("e" + "ke".repeat(countKe));
          i += 2 + 2 * countKe;
          continue;
        }

        current += pair.toLowerCase();
        i += 2;
      }

      flushCurrent();

      if (parts.length === 0) return "n";
      parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";

      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function nanpaLinjanProperNameToUcsurCodepoints(nameStr) {
      const s = String(nameStr ?? "").toLowerCase().replace(/\s+/g, "");
      if (!s || !s.endsWith("n")) throw new Error("Not a nanpa-linja-n proper name (missing final 'n').");

      const core = s.slice(0, -1);
      const caps = core.toUpperCase() + "N";

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function codepointsToHexString(codepoints) {
      return codepoints.map(cp => cp.toString(16).toUpperCase().padStart(4, "0")).join(" ");
    }

    function codepointsToHexStringWithCartouche(codepoints) {
      return codepointsToHexString(withCartoucheMarkers(codepoints));
    }

    function parseHexCodepoints(input) {
      const raw = input.trim();
      if (!raw) return [];
      const parts = raw.split(/\s+/).map(s => s.replace(/^U\+/i, ""));
      const cps = parts.map(p => {
        const cp = parseInt(p, 16);
        if (!Number.isFinite(cp)) throw new Error(`Invalid hex code point: "${p}"`);
        return cp;
      });

      assertAllAllowedTpUcsur(cps);

      return stripCartoucheMarkers(cps);
    }

    /* =======================
       Cartouche rendering
       ======================= */

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function renderMixedCartoucheToCanvas(canvas, codepoints, largePx, smallPx, smallCodepoints, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        const px = smallCodepoints.has(cp) ? smallPx : largePx;

        ctx.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";

      for (const g of glyphRuns) {
        ctx2.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }

      return { cartW, cartH, textW: totalWidth, textH: textHeight, maxAscent, maxDescent };
    }

    function renderUniformCartoucheFromCodepoints(canvas, codepoints, fontPx, options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);

        ctx.font = `${fontPx}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(fontPx * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(fontPx * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, left, tightW });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";
      ctx2.font = `${fontPx}px "${FONT_FAMILY}"`;

      for (const g of glyphRuns) {
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }
    }

    async function ensureFontLoaded() {
      const sampleCp = 0xF190B;
      const sampleChar = String.fromCodePoint(sampleCp);
      const fontSpec = `24px "${FONT_FAMILY}"`;

      function fallbackLikely(sampleText) {
        const c = document.createElement("canvas");
        const ctx = c.getContext("2d");
        ctx.font = `48px "${FONT_FAMILY}", monospace`;
        const w1 = ctx.measureText(sampleText).width;
        ctx.font = `48px monospace`;
        const w2 = ctx.measureText(sampleText).width;
        return w1 === w2;
      }

      if (!document.fonts || !document.fonts.load || !document.fonts.check) {
        console.warn("[font] CSS Font Loading API not available; cannot reliably validate load.");
        return;
      }

      try {
        await document.fonts.load(fontSpec, sampleChar);
        await document.fonts.ready;

        const ok = document.fonts.check(fontSpec, sampleChar);
        if (!ok) {
          console.warn(`[font] NOT CONFIRMED: ${fontSpec}`);
          console.warn("[font] If opening via file://, use Live Server / http://localhost to avoid font load restrictions.");
        }

        if (fallbackLikely(sampleChar)) {
          console.warn("[font] fallback likely (width matches monospace). Font may not have the glyph, or did not load.");
        }
      } catch (e) {
        console.error("[font] load threw error:", e);
      }
    }

    /* =======================
       UI wiring
       ======================= */

    const LETTER_SPACING_GAP = 4;

    const LARGE_FONT_SIZE = 72;
    const SMALL_FONT_SIZE = 20;

    // smaller "small cartouche" glyph sizes
    const LARGE_TINY_FONT_SIZE = 28;
    const SMALL_TINY_FONT_SIZE = 7;

    const SMALL_CANVAS_RENDER_OPTS = { padding: 10, border: 1, cornerRadius: 10, letterGap: 2 };

    const elDecimal = document.getElementById("decimalInput");
    const elLatinOut = document.getElementById("latinOut");
    const elCodepointsOut = document.getElementById("codepointsOut");
    const elNumberCodeOut = document.getElementById("numberCodeOut");

    const canvasLarge = document.getElementById("canvasLarge");
    const canvasSmall = document.getElementById("canvasSmall");

    const elCodesIn = document.getElementById("codepointsIn");

    const elTpWordsOut = document.getElementById("tpWordsOut");
    const elTpWordsIn = document.getElementById("tpWordsIn");

    const MAX_DECIMAL_INPUT_CHARS = 500;
    const MAX_HEX_CODE_INPUT_CHARS = 3500;
    const MAX_TOKI_PONA_WORD_INPUT_CHARS = 2500;

    const elDecimalValueLine = document.getElementById("decimalValueLine");
    const elDecimalValueText = document.getElementById("decimalValueText");

    function setDecimalValueLine(valueOrNull) {
      if (!elDecimalValueLine || !elDecimalValueText) return;

      const s = (valueOrNull == null) ? "" : String(valueOrNull).trim();
      if (!s) {
        elDecimalValueText.textContent = "";
        elDecimalValueLine.classList.add("hidden");
        return;
      }

      elDecimalValueText.textContent = s;
      elDecimalValueLine.classList.remove("hidden");
    }

    function enforceMaxLen(el, maxLen = MAX_DECIMAL_INPUT_CHARS) {
      if (!el) return;
      const s = String(el.value ?? "");
      if (s.length > maxLen) el.value = s.slice(0, maxLen);
    }

    enforceMaxLen(elDecimal,  MAX_DECIMAL_INPUT_CHARS);
    enforceMaxLen(elCodesIn,  MAX_HEX_CODE_INPUT_CHARS);
    enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

    if (elDecimal) elDecimal.addEventListener("input", () => enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS));
    if (elCodesIn) elCodesIn.addEventListener("input", () => enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS));
    if (elTpWordsIn) elTpWordsIn.addEventListener("input", () => enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS));

    const elDigitTableBody = document.getElementById("digitTableBody");

    function buildDigitReferenceTable() {
      if (!elDigitTableBody) return;
      elDigitTableBody.innerHTML = "";

      const smallSet = getSmallCodepointsSet();
      const TINY_LARGE_PX = 22;
      const TINY_SMALL_PX = 8;

      for (let d = 0; d <= 9; d++) {
        const digitStr = String(d);
        const latinNameRaw = encodeDecimalToLatin(digitStr);
        const latinNameDisplay = titleCaseNanpaProperNameForDisplay(latinNameRaw);

        const cps = decimalToUcsurCodepoints(digitStr);
        const unique_number_code = latinNameToNumberCode(latinNameRaw);

        const tr = document.createElement("tr");

        const tdDigit = document.createElement("td");
        tdDigit.className = "mono";
        tdDigit.textContent = digitStr;

        const tdName = document.createElement("td");
        tdName.className = "mono";
        tdName.textContent = latinNameDisplay;

        const tdUniqueNumberCode = document.createElement("td");
        tdUniqueNumberCode.className = "mono";
        tdUniqueNumberCode.textContent = unique_number_code;

        const tdCanvas = document.createElement("td");
        const canvas = document.createElement("canvas");
        canvas.className = "digitCanvas";
        canvas.setAttribute("aria-hidden", "true");
        tdCanvas.appendChild(canvas);

        tr.appendChild(tdDigit);
        tr.appendChild(tdName);
        tr.appendChild(tdUniqueNumberCode);
        tr.appendChild(tdCanvas);

        elDigitTableBody.appendChild(tr);

        renderMixedCartoucheToCanvas(
          canvas,
          cps,
          TINY_LARGE_PX,
          TINY_SMALL_PX,
          smallSet,
          { padding: 8, border: 1, cornerRadius: 10, letterGap: 2 }
        );
      }
    }

    async function runEncodeFromDecimal() {
      await ensureFontLoaded();
      enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS);

      const raw = normalizeVulgarFractionInput(elDecimal.value);
      const caps = looksLikeNanpaCaps(raw)
        ? raw.toUpperCase()
        : numberStrToNanpaCaps(raw, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      setDecimalValueFromCapsOrClear(caps);

      const latinRaw = encodeDecimalToLatin(raw);
      const latinDisplay = titleCaseNanpaProperNameForDisplay(latinRaw);

      elLatinOut.value = latinDisplay;
      elNumberCodeOut.value = latinNameToNumberCode(latinRaw);

      const cps = decimalToUcsurCodepoints(raw);

      if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
      if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

      const smallSet = getSmallCodepointsSet();

      renderMixedCartoucheToCanvas(
        canvasSmall,
        cps,
        LARGE_TINY_FONT_SIZE,
        SMALL_TINY_FONT_SIZE,
        smallSet,
        SMALL_CANVAS_RENDER_OPTS
      );

      renderMixedCartoucheToCanvas(
        canvasLarge,
        cps,
        LARGE_FONT_SIZE,
        SMALL_FONT_SIZE,
        smallSet,
        { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
      );

      announceStatus(`Rendered value ${raw}.`);
    }

    document.getElementById("btnEncode").addEventListener("click", async () => {
      try {
        lastAction = "decimal";
        await runEncodeFromDecimal();
      } catch (err) {
        setDecimalValueLine(null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    document.getElementById("btnFromCodes")?.addEventListener("click", async () => {
      try {
        lastAction = "codes";
        await ensureFontLoaded();
        enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS);

        const cps = parseHexCodepoints(elCodesIn.value);

        elLatinOut.value = String.fromCodePoint(...cps);
        if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);

        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);
        if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        try {
          const tpWords = ucsurCodepointsToTpWords(cps).join(" ");
          const parsed = tryParseNanpaLinjanTpPhraseToCaps(tpWords);
          if (parsed) setDecimalValueFromCapsOrClear(parsed.caps);
          else setDecimalValueLine(null);
        } catch {
          setDecimalValueLine(null);
        }

        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          SMALL_CANVAS_RENDER_OPTS
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

        announceStatus("Rendered from code points.");
      } catch (err) {
        setDecimalValueLine(null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    document.getElementById("btnFromWords").addEventListener("click", async () => {
      try {
        lastAction = "words";
        await ensureFontLoaded();
        enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

        const rawInput = String(elTpWordsIn.value ?? "");

        const parsedNumberCode = tryParseNanpaLinjanNumberCodeToCaps(rawInput);
        if (parsedNumberCode) {
          const { caps, canonicalCode } = parsedNumberCode;

          setDecimalValueFromCapsOrClear(caps);

          const tokens = tokenizeNanpaCaps(caps);
          const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
          const cps = tpWordsToUcsurCodepoints(tpWords);

          const prettyNameRaw = splitCartoucheCapsLettersSpaced(caps);
          const prettyNameDisplay = titleCaseNanpaProperNameForDisplay(prettyNameRaw);

          elLatinOut.value = prettyNameDisplay;
          elNumberCodeOut.value = canonicalCode;

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
          if (elTpWordsOut) elTpWordsOut.value = tpWords.join(" ");

          const smallSet = getSmallCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            smallSet,
            SMALL_CANVAS_RENDER_OPTS
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            smallSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Rendered from nanpa-linja-n number code.");
          return;
        }

        const parsedTpPhrase = tryParseNanpaLinjanTpPhraseToCaps(rawInput);
        if (parsedTpPhrase) {
          const { caps, words } = parsedTpPhrase;

          setDecimalValueFromCapsOrClear(caps);

          const cps = parseTpWordsToCodepoints(words.join(" "));

          const prettyNameRaw = splitCartoucheCapsLettersSpaced(caps);
          const prettyNameDisplay = titleCaseNanpaProperNameForDisplay(prettyNameRaw);

          elLatinOut.value = prettyNameDisplay;
          elNumberCodeOut.value = latinNameToNumberCode(prettyNameRaw);

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
          if (elTpWordsOut) elTpWordsOut.value = words.join(" ");

          const smallSet = getSmallCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            smallSet,
            SMALL_CANVAS_RENDER_OPTS
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            smallSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Recognized and rendered nanpa-linja-n TP-phrase number.");
          return;
        }

        if (isValidNanpaLinjanProperName(rawInput)) {
          const cps = nanpaLinjanProperNameToUcsurCodepoints(rawInput);

          const compact = rawInput.toLowerCase().replace(/\s+/g, "");
          const core = compact.slice(0, -1);
          const caps = core.toUpperCase() + "N";

          setDecimalValueFromCapsOrClear(caps);

          const prettyNameRaw = splitCartoucheCapsLettersSpaced(caps);
          const prettyNameDisplay = titleCaseNanpaProperNameForDisplay(prettyNameRaw);

          elLatinOut.value = prettyNameDisplay;
          elNumberCodeOut.value = latinNameToNumberCode(prettyNameRaw);

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
          if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

          const smallSet = getSmallCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            smallSet,
            SMALL_CANVAS_RENDER_OPTS
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            smallSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Rendered from nanpa-linja-n proper name.");
          return;
        }

        const cps = parseTpWordsToCodepoints(elTpWordsIn.value);

        if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
        if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        elLatinOut.value = String.fromCodePoint(...cps);
        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);

        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          SMALL_CANVAS_RENDER_OPTS
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

        setDecimalValueLine(null);

        announceStatus("Rendered from Toki Pona words.");
      } catch (err) {
        setDecimalValueLine(null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    function validateTpWordsInputLive() {
      const raw = String(elTpWordsIn?.value ?? "").trim();
      if (!raw) { elTpWordsIn.setCustomValidity(""); return; }

      try {
        const parsedCode = tryParseNanpaLinjanNumberCodeToCaps(raw);
        if (parsedCode) {
          elTpWordsIn.setCustomValidity("");
          return;
        }
      } catch (e) {
        if (String(raw).trim().toUpperCase().startsWith("#~")) {
          elTpWordsIn.setCustomValidity(e?.message ?? "Invalid number code.");
          return;
        }
      }

      if (isValidNanpaLinjanProperName(raw)) {
        elTpWordsIn.setCustomValidity("");
        return;
      }

      // Accept valid mapped words (including en)
      const parts = raw.split(/\s+/).filter(Boolean);
      for (const p of parts) {
        if (WORD_TO_UCSUR_CP[p.toLowerCase()] == null) {
          elTpWordsIn.setCustomValidity(`Invalid word: ${p}`);
          return;
        }
      }
      elTpWordsIn.setCustomValidity("");
    }

    if (elTpWordsIn) elTpWordsIn.addEventListener("input", validateTpWordsInputLive);

    if (elDecimal) {
      elDecimal.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          document.getElementById("btnEncode").click();
        }
      });
    }

    window.addEventListener("load", async () => {
      try {
        await ensureFontLoaded();

        // CHANGED: query param overrides localStorage, then we update the calculator link
        applyCartoucheDisplayModeFromQueryOrStorage();
        updateCalculatorLinkWithDisplayParam();

        wireCartoucheDisplayRadios();

        buildDigitReferenceTable();
        await runEncodeFromDecimal();
      } catch (err) {
        setDecimalValueLine(null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });
  </script>
</body>
</html>
