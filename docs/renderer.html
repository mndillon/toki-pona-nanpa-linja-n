<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Toki Pona → Cartouche Calculator — toki pona tawa poki nimi</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;     /* unify background color */
      --muted: #3f4750;  /* CHANGED: darker for better contrast */
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .row { display: flex; gap: var(--gap); flex-wrap: wrap; align-items: flex-end; }


    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input[type="text"], textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg);
      font: inherit;
    }

    textarea { min-height: 84px; resize: vertical; }

    .col { flex: 1 1 320px; }

    button {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover {
      background: var(--bg);
    }

    /* NEW: bilingual button layout */
    .btnBi {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      line-height: 1.15;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    /* NEW: Toki Pona line (10pt) */
    .tpLine {
      display: block;
      margin-top: 2px;
      font-size: 10pt;
      color: var(--muted);
      line-height: 1.25;
    }

    .out { margin-top: 12px; }

    .out h3 { margin: 18px 0 8px; font-size: 14px; }

    canvas {
      display: block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: transparent;    /* background: var(--bg); */
      max-width: 100%;  
    }

    .small { font-size: 12px; color: var(--muted); }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .hidden {
      display: none !important;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src: 
        /* Web-hosted files (order matters) */
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-v5.otf")   format("opentype");
      font-display: swap;
    }

    /* Digit reference table */
    .digitTable {
      table-layout: auto;          /* natural column sizing */
      width: max-content;          /* allow table to be wider than viewport */
      min-width: 100%;             /* but don't shrink below container */
      border-collapse: collapse;
    }

    /* Keep the unique number code from overflowing into the cartouche column */
    .digitTable th:nth-child(3),
    .digitTable td:nth-child(3) {
      white-space: nowrap;   /* keep code on one line */
    }

    .tableWrap {
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }

    .digitTable th,
    .digitTable td {
      border: 1px solid var(--border);
      padding: 8px;
      vertical-align: middle;
    }

    .digitTable th {
      text-align: left;
      font-size: 12px;
      color: var(--muted);
      font-weight: 700;
    }

    .digitTable td {
      font-size: 13px;
    }

    .digitCanvas {
      display: block;
      max-width: 100%;
    }

    /* =========================
       WCAG-oriented affordances
       ========================= */

    /* Strong focus indicators */
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    textarea:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    /* Skip link (keyboard navigation) */
    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    /* Visually hidden but still accessible to screen readers */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: 0 !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    /* Prevent user agent forced color adjustments from destroying contrast in HC modes */
    .no-forced-adjust {
      forced-color-adjust: none;
    }

    /* =========================
       NEW: Cartouche display mode chooser (subtle)
       ========================= */
    .displayChooser {
      margin: 10px 0 6px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: var(--bg);
    }

    .displayChooser legend {
      font-size: 12px;
      color: var(--muted);
      padding: 0 6px;
      font-weight: 700;
    }

    .displayOpt {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-right: 14px;
      font-size: 13px;
      color: #111;
      cursor: pointer;
      user-select: none;
    }

    .displayOpt input {
      transform: translateY(1px);
    }

    .nlModeControl{ display:none !important; }

    /* Portrait image: mobile-first */
    img.portrait{
      display:block;
      width:100%;
      max-width:100vw;
      height:auto;
    }
    @media (min-width:900px){
      img.portrait{ max-width:520px; margin-inline:auto; }
    }
  </style>

</head>

<body>
  <!-- Skip link for keyboard users -->
  <a href="#main" class="skipLink">
    Skip to content
    <span class="tpLine">o tawa lipu ni</span>
  </a>

  <!-- Main landmark for assistive tech -->
  <main class="card" id="main" role="main" aria-labelledby="pageTitle">

    <h1 style="margin:0 0 6px;font-size:18px;">
      Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer
      <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
    </h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> The “nanpa-linja-n proper name” shown here is an encoding label for numbers only.
      It is intended as a proper-name style identifier and does not propose or add any new Toki Pona lexicon.
      <span class="tpLine">
        sona: nimi “nanpa-linja-n proper name” li nimi pi pana nanpa taso.
        ona li sama nimi pi jan (nimi pi nimi) taso; ona li pana ala e nimi sin pi toki pona.
      </span>
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <span class="tpLine">
        sona: ilo ni li lon nasin “as is”. mi pana ala e wawa pi pona.
        sina o lukin e ni: sitelen li pona anu seme.
      </span>
    </div>

    <div class="help" style="margin-top:10px;">
      Inputs are treated as text to preserve formatting (e.g., trailing zeros).
      <span class="tpLine">pana li sitelen taso, tan ni: nanpa pini (0) li awen sama.</span>
    </div>

    <!-- Screen-reader live region for status/errors -->
    <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <!-- MOVED: Canvases now appear ABOVE the decimal input -->
    <div class="out" role="region" aria-label="Cartouche renderings">
      <!-- Canvases are decorative; authoritative text is the words/outputs below -->
      <div class="grid2" style="margin-top:14px;" role="group" aria-label="Cartouche renderings">
        <div>
          <h3>
            sitelen pona cartouche
            <span class="tpLine">poki nimi sitelen pona</span>
          </h3>
          <canvas id="canvasSmall" aria-hidden="true"></canvas>
          <div id="cartoucheValueBox" class="help hidden" aria-label="Cartouche value">
            <strong>Cartouche value:</strong>
            <span id="cartoucheValueText" class="mono"></span>
            <span class="tpLine">
              nanpa: <span id="cartoucheValueTextTp" class="mono"></span>
            </span>
          </div>
          <div style="margin-top:8px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
            <button id="btnDownloadCartouchePng" type="button" class="btnBi" aria-describedby="btnDownloadHelp">
              <span>Download PNG</span>
              <span class="tpLine">o kama jo e sitelen PNG</span>
            </button>

            <div id="btnDownloadHelp" class="sr-only">
              Downloads the rendered cartouche as a transparent PNG image.
            </div>

            <span class="small">
              (Transparent background)
              <span class="tpLine">(poka sitelen li lon ala)</span>
            </span>
          </div>
          <div class="sr-only" id="canvasSmallDesc">
            Decorative cartouche rendering. Use the text outputs below for the accessible value.
          </div>
        </div>
        <div class="hidden">
          <h3>
            sitelen pona cartouche (large)
            <span class="tpLine">poki nimi sitelen pona (suli)</span>
          </h3>
          <canvas id="canvasLarge" aria-hidden="true"></canvas>
          <div id="decimalValueLine" class="help hidden">
            <strong>Value:</strong> <span id="decimalValueText" class="mono"></span>
          </div>
          <div class="help">
            Rendered with your font at a large size.
            <span class="tpLine">sitelen li kepeken font sina, lon suli mute.</span>
          </div>
          <div class="sr-only" id="canvasLargeDesc">
            Decorative cartouche rendering. Use the text outputs below for the accessible value.
          </div>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:14px;" role="group" aria-label="Decimal input and encode action">
      <div class="col">
        <label for="decimalInput">
          Enter decimal value (in en-US locale format)
          <span class="tpLine">o pana e nanpa poka (nasin en-US)</span>
        </label>
        <input
          id="decimalInput"
          type="text"
          class="mono"
          value="28.95"
          maxlength="500"
          inputmode="text"
          aria-describedby="decimalHelp"
          aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge digitTable"
        />
        <div id="decimalHelp" class="help">
          Example formats: <span class="mono">0.00</span>; <span class="mono">.75</span>; <span class="mono">-12,340</span>;  <span class="mono">2000</span>; <span class="mono">5,000</span>; <span class="mono">9¾</span>; <span class="mono">8+1/2</span>; <span class="mono">7/8</span>; <span class="mono">64.5M</span>; <span class="mono">007</span>; <span class="mono">432-555-0189</span>.
          nanpa-linja-n encoder decides how to represent these.
          <span class="tpLine">
            nasin pi pana nanpa li ken ante. ilo nanpa-linja-n li kama e nasin sitelen pi nanpa ni.
          </span>
        </div>
      </div>

      <div style="flex: 0 0 auto;">
        <button id="btnEncode" type="button" class="btnBi" aria-describedby="btnEncodeHelp">
          <span>Encode &amp; Render</span>
          <span class="tpLine">o pana e nimi nanpa, o sitelen e poki nimi</span>
        </button>
        <div id="btnEncodeHelp" class="sr-only">
          Encodes the decimal input into a nanpa-linja-n proper name and renders the sitelen pona cartouches.
        </div>
      </div>
    </div>

    <div id="fromCodesSection" class="hidden">
      <div class="row" role="group" aria-label="Render from code points">
        <div class="col">
          <label for="codepointsIn">
            Paste code points (hex, space-separated)
            <span class="tpLine">o pana e nanpa sitelen (hex, weka-spasi)</span>
          </label>
          <input
            id="codepointsIn"
            type="text"
            class="mono"
            placeholder="F190B F1944 F193D"
            maxlength="3500"
            aria-describedby="codepointsHelp"
            aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge"
          />
          <div id="codepointsHelp" class="help">
            Accepts <span class="mono">F190B</span> or <span class="mono">U+F190B</span>.
            Input is restricted to the Toki Pona UCSUR block (<span class="mono">F1900</span>–<span class="mono">F1988</span>) plus cartouche start/end markers.
            <span class="tpLine">
              sina ken pana e <span class="mono">F190B</span> anu <span class="mono">U+F190B</span>.
              pana li ken lon poki UCSUR pi toki pona taso (<span class="mono">F1900</span>–<span class="mono">F1988</span>) en sitelen open/pini pi poki nimi.
            </span>
          </div>
        </div>
        <div style="flex: 0 0 auto;">
          <button id="btnFromCodes" type="button" class="btnBi">
            <span>Render From Code Points</span>
            <span class="tpLine">o sitelen tan nanpa sitelen</span>
          </button>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:10px;" role="group" aria-label="Render from Toki Pona words">
      <div class="col">
        <label for="tpWordsIn">
          Enter Toki Pona words (space-separated)
          <span class="tpLine">o pana e nimi toki pona (weka-spasi)</span>
        </label>
        <input
          id="tpWordsIn"
          type="text"
          class="mono"
          placeholder="Newenin One Len Oken"
          maxlength="2500"
          aria-describedby="tpWordsHelp"
          aria-controls="latinOut numberCodeOut tpWordsOut canvasSmall canvasLarge"
          spellcheck="false"
          autocapitalize="none"
          autocomplete="off"
        />
        <div id="tpWordsHelp" class="help">
          Allowed input: Valid Toki Pona words (case-insensitive) or a nanpa-linja-n proper name for a decimal value or a number code (starting with #~).
          <span class="tpLine">
            nimi toki pona lon mapu taso li ken. (suli/lili pi sitelen li wile ala.)
            sina ken kin pana e nimi pi nanpa-linja-n (nimi pi pana nanpa).
          </span>
        </div>
      </div>
      <div style="flex: 0 0 auto;">
        <button id="btnFromWords" type="button" class="btnBi">
          <span>Render From Toki Pona Words</span>
          <span class="tpLine">o sitelen tan nimi toki pona</span>
        </button>
      </div>
    </div>

    <!-- NEW: Cartouche display mode selector (subtle) -->
     <div class="nlModeControl">
          <fieldset class="displayChooser" aria-label="Cartouche display mode">
            <legend>Cartouche display</legend>

            <label class="displayOpt">
              <input type="radio" name="cartoucheDisplay" value="traditional" checked>
              <span>Traditional</span>
            </label>

            <label class="displayOpt">
              <input type="radio" name="cartoucheDisplay" value="uniform">
              <span>Uniform</span>
            </label>
          </fieldset>
      </div>

    <div class="out" role="region" aria-label="Outputs">
      <h3>
        nanpa-linja-n proper name for decimal value
        <span class="tpLine">nimi pi pana nanpa (nanpa-linja-n)</span>
      </h3>
      <textarea id="latinOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        This is the Latin string you generate from the decimal input (nanpa-linja-n custom encoding). Spaces are added for readability and will NOT affect glyph mapping.
        <span class="tpLine">
          ni li sitelen Lasina tan nanpa pana. spasi li pona lukin taso; ona li ante ala e mapu pi sitelen.
        </span>
      </div>

      <h3>
        nanpa-linja-n unique number code
        <span class="tpLine">nimi nanpa wan pi nanpa-linja-n</span>
      </h3>
      <textarea id="numberCodeOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        Derived from the nanpa-linja-n proper name: remove letters <span class="mono">n</span> and <span class="mono">e</span>.
        <span class="tpLine">
          ni li tan nimi pi nanpa-linja-n: o weka e sitelen <span class="mono">n</span> en <span class="mono">e</span>.
        </span>
      </div>

      <div id="hexSection">
        <h3>
          nasin-nanpa UCSUR code points (including cartouche start and end codes) (hex)
          <span class="tpLine">nanpa sitelen (nasin hex)</span>
        </h3>
        <textarea id="codepointsOut" class="mono" readonly aria-readonly="true"></textarea>
        <div class="help">
          Space-separated hex code points (e.g., <span class="mono">F190B F1944 ...</span>) that nasin nanpa font uses.
          <span class="tpLine">
            ni li nanpa sitelen (hex) weka-spasi: ilo sitelen nasin nanpa li kepeken ona.
          </span>
        </div>
      </div>

      <h3>
        Toki Pona words (for UCSUR code points excluding cartouche start and end codes)
        <span class="tpLine">nimi pi toki pona (tan nanpa sitelen)</span>
      </h3>
      <textarea id="tpWordsOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        One Toki Pona word per code point, in the same order as the code points output.
        <span class="tpLine">
          nanpa sitelen wan la, nimi toki pona wan. nasin li sama lon poka pi nanpa sitelen.
        </span>
      </div>

      <h3 style="margin-top:20px;">
        Digit reference: 0–9
        <span class="tpLine">lipu sona pi nanpa: 0–9</span>
      </h3>
      <div class="help">
        Digit, its nanpa-linja-n proper name, its nanpa-linja-n unique number code, and a sitelen pona mixed-font cartouche.
        <span class="tpLine">
          nanpa, nimi pi nanpa-linja-n, nimi nanpa wan, en poki nimi sitelen pona (font tu).
        </span>
      </div>

      <div class="tableWrap">
        <table class="digitTable" id="digitTable">
          <caption class="sr-only">
            Reference table for digits 0 through 9, including nanpa-linja-n labels and decorative cartouches.
          </caption>
          <thead>
            <tr>
              <th scope="col" style="width:80px;">
                Digit
                <span class="tpLine">nanpa</span>
              </th>
              <th scope="col">
                nanpa-linja-n proper name
                <span class="tpLine">nimi pi nanpa-linja-n</span>
              </th>
              <th scope="col">
                nanpa-linja-n unique number code
                <span class="tpLine">nimi nanpa wan</span>
              </th>
              <th scope="col" style="width:220px;">
                sitelen pona cartouche
                <span class="tpLine">poki nimi sitelen pona</span>
              </th>
            </tr>
          </thead>
          <tbody id="digitTableBody">
            <!-- rows generated by JS -->
          </tbody>
        </table>
      </div>

      <div class="help">&nbsp;</div>
      <img class="portrait" src="./images/From_Decimal_Number_To_Cartouche.png" />
      <div class="help">&nbsp;</div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona Multiline text → sitelen pona glyphs → png image file download
        <span class="tpLine">o lukin e ilo ni: sitelen toki pona mute-linja tawa sitelen pona</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a id="textToSitelenLink" class="repoLink" href="./text-to-sitelen.html" target="_blank" rel="noopener noreferrer">
          Multiline text → sitelen pona glyphs → png image file download
        </a>
        <span class="tpLine">o lukin e ilo ni: sitelen toki pona mute-linja tawa sitelen pona</span>
      </div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n cartouche calculator
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <!-- CHANGED: give this link an id so JS can append the query param -->
        <a id="calculatorLink" class="repoLink" href="./calculator.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n cartouche calculator
        </a>
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n maze game
        <span class="tpLine">o lukin e musi pi nasin pi nanpa-linja-n lon toki pona</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a class="repoLink" href="./maze-toki.html" target="_blank" rel="noopener noreferrer">
          maze game
        </a>
        <span class="tpLine">musi pi nasin pi nanpa-linja-n lon toki pona</span>
      </div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona 15 puzzle game
        <span class="tpLine">o lukin e musi pi leko tawa nanpa Newelen pi toki pona</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a class="repoLink" href="./15-puzzle-toki.html" target="_blank" rel="noopener noreferrer">
          15 puzzle game
        </a>
        <span class="tpLine">musi pi leko tawa nanpa Newelen pi toki pona</span>
      </div>
      
      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out more Toki Pona tools
        <span class="tpLine">o lukin e ilo ante lon toki pona</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="./index.html" target="_blank" rel="noopener noreferrer">
          More Toki Pona tools
        </a>
        <span class="tpLine">ilo ante lon toki pona</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona sitelen pona fonts
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n/tree/main/docs/fonts" target="_blank" rel="noopener noreferrer">
          sitelen pona nanpa-linja-n fonts
        </a>
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </div>

      <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n main documentation
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </h1>
      <div class="help">The main documentation contains all the rules for converting decimal numbers into cartouches.</div>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n main documentation
        </a>
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </div>

      <div class="help">#~n</div>
    </div>
  </main>

  <script>
    "use strict";

    /* ============================================================
       Accessibility helpers
       ============================================================ */

    const WORD_FOR_NEGATIVE_SIGN = "ona" //"o" // could use ona

    const elSrStatus = document.getElementById("srStatus");

    function announceStatus(msg) {
      if (!elSrStatus) return;
      elSrStatus.textContent = String(msg ?? "");
    }

    function showAlertAndAnnounce(msg) {
      const s = String(msg ?? "Unknown error");
      announceStatus(s);
      alert(s);
    }

    /* ============================================================
       NEW: Cartouche display mode (Traditional vs Uniform)
       - Traditional: existing wording
       - Uniform: every "esun" -> "en", every "nasa" -> "nena", every standalone "e" -> "en"
       - Only "nanpa" at start and end remains unchanged.
       ============================================================ */

    const CARTOUCHE_DISPLAY_STORAGE_KEY = "cartoucheDisplayMode";

    // NEW: query-param name so this page can be linked consistently
    // Example: ?cartoucheDisplay=uniform
    const CARTOUCHE_DISPLAY_QUERY_PARAM = "cartoucheDisplay";

    let lastAction = "decimal"; // "decimal" | "codes" | "words"



    function fixOkenSuffixSpacing(s) {
      const x = String(s ?? "");
      // Only touch the exact suffix "Oken" (or "oken") when it is missing a space.
      if (/\sOken$/.test(x) || /\soken$/.test(x)) return x;
      return x.replace(/Oken$/, " Oken").replace(/oken$/, " Oken");
    }

    function getCartoucheDisplayMode() {
      //const el = document.querySelector('input[name="cartoucheDisplay"]:checked');
      //return (el && (el.value === "uniform" || el.value === "traditional")) ? el.value : "traditional";
      return "uniform";
    }

    function setCartoucheDisplayMode(mode) {
      const v = (mode === "uniform") ? "uniform" : "traditional";
      const target = document.querySelector(`input[name="cartoucheDisplay"][value="${v}"]`);
      if (target) target.checked = true;
      try { localStorage.setItem(CARTOUCHE_DISPLAY_STORAGE_KEY, v); } catch {}
    }

    function loadCartoucheDisplayModeFromStorage() {
      try {
        const v = localStorage.getItem(CARTOUCHE_DISPLAY_STORAGE_KEY);
        if (v === "uniform" || v === "traditional") setCartoucheDisplayMode(v);
      } catch {}
    }

    // NEW: read display mode from query param; returns "uniform" | "traditional" | null
    function readCartoucheDisplayModeFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const v = String(params.get(CARTOUCHE_DISPLAY_QUERY_PARAM) ?? "").toLowerCase().trim();
        if (v === "uniform" || v === "traditional") return v;
      } catch {}
      return null;
    }

    // NEW: apply precedence: query param (if valid) overrides localStorage; otherwise localStorage
    function applyCartoucheDisplayModeFromQueryOrStorage() {
      const q = readCartoucheDisplayModeFromQuery();
      if (q) {
        setCartoucheDisplayMode(q); // also persists to localStorage
        return;
      }
      loadCartoucheDisplayModeFromStorage();
    }

    // NEW: update the calculator.html link so it includes the current selection
    function updateCalculatorLinkWithDisplayParam() {
      const a = document.getElementById("calculatorLink");
      if (!a) return;

      try {
        const href = a.getAttribute("href") || "./calculator.html";
        const u = new URL(href, window.location.href);
        u.searchParams.set(CARTOUCHE_DISPLAY_QUERY_PARAM, getCartoucheDisplayMode());

        // keep href relative-ish (works for ./calculator.html and for absolute URLs)
        if (u.origin === window.location.origin) {
          const rel = u.pathname + (u.search || "") + (u.hash || "");
          a.setAttribute("href", rel);
        } else {
          a.setAttribute("href", u.toString());
        }
      } catch {
        // If URL construction fails, fall back to appending manually (best-effort)
        const base = (a.getAttribute("href") || "./calculator.html").split("?")[0];
        a.setAttribute("href", `${base}?${CARTOUCHE_DISPLAY_QUERY_PARAM}=${encodeURIComponent(getCartoucheDisplayMode())}`);
      }
    }

    // NEW: update the text-to-sitelen.html link so it includes the current selection
    function updateTextToSitelenLinkWithDisplayParam() {
      const a = document.getElementById("textToSitelenLink");
      if (!a) return;

      try {
        const href = a.getAttribute("href") || "./text-to-sitelen.html";
        const u = new URL(href, window.location.href);
        u.searchParams.set(CARTOUCHE_DISPLAY_QUERY_PARAM, getCartoucheDisplayMode());

        // keep href relative-ish (works for ./text-to-sitelen.html and for absolute URLs)
        if (u.origin === window.location.origin) {
          const rel = u.pathname + (u.search || "") + (u.hash || "");
          a.setAttribute("href", rel);
        } else {
          a.setAttribute("href", u.toString());
        }
      } catch {
        const base = (a.getAttribute("href") || "./text-to-sitelen.html").split("?")[0];
        a.setAttribute(
          "href",
          `${base}?${CARTOUCHE_DISPLAY_QUERY_PARAM}=${encodeURIComponent(getCartoucheDisplayMode())}`
        );
      }
    }

    function wireCartoucheDisplayRadios() {
      const radios = document.querySelectorAll('input[name="cartoucheDisplay"]');
      radios.forEach(r => {
        r.addEventListener("change", () => {
          setCartoucheDisplayMode(getCartoucheDisplayMode());
          updateCalculatorLinkWithDisplayParam(); // NEW
          updateTextToSitelenLinkWithDisplayParam();
          buildDigitReferenceTable();

          // Re-render based on the user's most recent action, but do NOT clear inputs.
          if (lastAction === "words") handleFromWordsClick({ clearOthers: false });
          else if (lastAction === "codes") handleFromCodesClick({ clearOthers: false });
          else handleEncodeClick({ clearOthers: false });

        });
      });
    }

    /* ============================================================
       Proper-name display formatting (Title Case per word)
       ============================================================ */

    function titleCaseNanpaProperNameForDisplay(nameStr) {
      const s = String(nameStr ?? "").trim();
      if (!s) return s;
      return s
        .split(/\s+/)
        .filter(Boolean)
        .map(w => {
          const lower = w.toLowerCase();
          if (lower.length === 1) return lower.toUpperCase();
          return lower[0].toUpperCase() + lower.slice(1);
        })
        .join(" ");
    }

    /* ============================================================
       Vulgar fraction input support (e.g., 9¾, ¾, ⅜, etc.)
       ============================================================ */

    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]],
    ]);

    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      // NEW: allow '%' as the last non-blank symbol after a vulgar fraction.
      // We strip it for normalization, then add it back.
      let hasPercent = false;
      if (/%\s*$/.test(s)) {
        hasPercent = true;
        s = s.replace(/%\s*$/, "").trim();
        if (!s) throw new Error("Percent sign must follow a number.");
      }

      s = s.replace(/\u2044/g, "/");

      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return hasPercent ? (s + "%") : s;

      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾), optionally followed by '%'.");
      }
      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      let normalized;
      if (!prefixRaw) {
        normalized = `${num}/${den}`;
      } else {
        const isNeg = prefixRaw.startsWith("-");
        const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

        if (!prefix) normalized = `-${num}/${den}`;
        else normalized = isNeg ? `-${prefix}+${num}/${den}` : `${prefix}+${num}/${den}`;

        if (normalized.slice(1).includes("-")) {
          throw new Error("Normalization produced an invalid negative sign placement.");
        }
      }

      return hasPercent ? (normalized + "%") : normalized;
    }


    /* ============================================================
       MAPPING: Latin "glyph-string" chars -> font code points
       ============================================================ */

    const FONT_FAMILY = "TP-Cartouche-Font";

    const LATIN_CHAR_TO_CODEPOINT = {
      "0": 0xF1901,
      "1": 0xF1901,
      "2": 0xF1901,
      "3": 0xF1901,
      "4": 0xF1901,
      "5": 0xF190B,
      "6": 0xF1901,
      "7": 0xF1901,
      "8": 0xF1901,
      "9": 0xF1901,
      ".": 0xF1901,
      "-": 0xF1901,
    };

    const CODEPOINT_TO_LATIN_CHAR = new Map(
      Object.entries(LATIN_CHAR_TO_CODEPOINT).map(([ch, cp]) => [cp, ch])
    );

    function getSmallCodepointsSet() {
      return new Set([
        0xF193D, // NANPA
        0xF1940, // NENA
        0xF1941, // NI
        0xF193E, // NASA
        0xF1909, // E
        0xF190B, // ESUN
        0xF190A, // EN
      ]);
    }

    // ¼-size glyphs (already used for nanpa/en/etc). Add OPEN here too.
    function getQuarterCodepointsSet() {
      return new Set([
        0xF193D, // nanpa
        0xF1940, // nena
        0xF1941, // ni
        0xF193E, // nasa
        0xF1909, // e
        0xF190B, // esun
        0xF190A, // en
        0xF1947, // open   <-- NEW: quarter size
      ]);
    }

    // ⅔-size glyphs
    function getTwoThirdsCodepointsSet() {
      return new Set([
        0xF1946, // ona   <-- NEW: two-thirds size
        0xF1944, // o     <-- NEW: two-thirds size
        0xF191F, // kulupu <-- NEW: two-thirds size
      ]);
    }

    // ½-size glyphs
    function getHalfCodepointsSet() {
      return new Set();
    }

    const TP_UCSUR_MIN = 0xF1900;
    const TP_UCSUR_MAX = 0xF19A3;//0xF1988;  

    // cartouche start/end markers to show in HEX output
    const CARTOUCHE_START_CP = 0xF1990;
    const CARTOUCHE_END_CP   = 0xF1991;

    function withCartoucheMarkers(codepoints) {
      const cps = Array.from(codepoints ?? []);
      return [CARTOUCHE_START_CP, ...cps, CARTOUCHE_END_CP];
    }

    function stripCartoucheMarkers(codepoints) {
      const cps = Array.from(codepoints ?? []);
      if (cps.length >= 2 && cps[0] === CARTOUCHE_START_CP && cps[cps.length - 1] === CARTOUCHE_END_CP) {
        return cps.slice(1, -1);
      }
      return cps;
    }

    function isAllowedTpUcsurCodepoint(cp) {
      return (
        Number.isInteger(cp) &&
        (
          (cp >= TP_UCSUR_MIN && cp <= TP_UCSUR_MAX) ||
          cp === CARTOUCHE_START_CP ||
          cp === CARTOUCHE_END_CP
        )
      );
    }

    function assertAllAllowedTpUcsur(codepoints) {
      for (const cp of codepoints) {
        if (!isAllowedTpUcsurCodepoint(cp)) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(
            `Disallowed code point U+${hex}. Allowed range is U+${TP_UCSUR_MIN.toString(16).toUpperCase()}..U+${TP_UCSUR_MAX.toString(16).toUpperCase()} plus cartouche markers U+${CARTOUCHE_START_CP.toString(16).toUpperCase()} and U+${CARTOUCHE_END_CP.toString(16).toUpperCase()}.`
          );
        }
      }
    }

    /* ============================================================
       PYTHON-ALGORITHM PORT (core pieces)
       ============================================================ */

    const DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    const TOKEN_TO_DIGIT_WORD = {
      "NI": "ijo", "WE": "wan", "TE": "tu", "SE": "seli", "NA": "awen",
      "LE": "luka", "NU": "utala", "ME": "mun", "PE": "pipi", "JE": "jo",
    };

    const OPCHAR_TO_TOKEN = { ".": "NONE", "-": "NO", "/": "NONO", "+": "NONONO" };
    const MAGCHAR_TO_TOKEN = { "T": "KE", "M": "KEKE", "W": "KEKEKE" };
    const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));

    const TOKEN_PREFIXES = [ "KEKEKE", "KEKE", "KE", "NONONO", "NONO", "OK", "NE", "NO" ];

    // Reverse map: digit word -> token
    const DIGIT_WORD_TO_TOKEN = Object.fromEntries(
      Object.entries(TOKEN_TO_DIGIT_WORD).map(([tok, w]) => [w, tok])
    );

    function normalizeTpWord(raw) {
      return String(raw ?? "").toLowerCase().replace(/[^a-z]/g, "");
    }

    /**
     * Try to recognize and decode a nanpa-linja-n TP-words encoded number phrase:
     *   nanpa esun|en ... nanpa
     *
     * Accepts both Traditional and Uniform mode wordings:
     * - Start: "nanpa esun" or "nanpa en"
     * - After digits: "<digitWord> esun" or "<digitWord> en"
     * - NE (non-initial): "(nasa|nena) (e|en)"
     * - KE: "kulupu (e|en)"
     * - NONONO: (nasa|nena) o x3
     */
    function tryParseNanpaLinjanTpPhraseToCaps(input) {
      const words = String(input ?? "")
        .trim()
        .split(/\s+/)
        .map(normalizeTpWord)
        .filter(Boolean);

      // Must be at least: "nanpa esun|en ... nanpa"
      if (words.length < 3) return null;
      if (words[0] !== "nanpa") return null;
      if (!(words[1] === "esun" || words[1] === "en")) return null;
      if (words[words.length - 1] !== "nanpa") return null;

      const end = words.length - 1;

      const capsParts = ["NE"]; // start token is always NE
      let i = 2;

      while (i < end) {
        // 1) NONONO: "(nasa|nena) o" repeated 3 times
        if (
          i + 5 < end &&
          (words[i] === "nasa" || words[i] === "nena") && words[i + 1] === "o" &&
          (words[i + 2] === "nasa" || words[i + 2] === "nena") && words[i + 3] === "o" &&
          (words[i + 4] === "nasa" || words[i + 4] === "nena") && words[i + 5] === "o"
        ) {
          capsParts.push("NONONO");
          i += 6;
          continue;
        }

        // 2) NONO: "nena o nena o"
        if (
          i + 3 < end &&
          words[i] === "nena" && words[i + 1] === "o" &&
          words[i + 2] === "nena" && words[i + 3] === "o"
        ) {
          capsParts.push("NONO");
          i += 4;
          continue;
        }

        // 3) NE (non-initial): "(nasa|nena) (e|en)"
        if (
          i + 1 < end &&
          (words[i] === "nasa" || words[i] === "nena") &&
          (words[i + 1] === "e" || words[i + 1] === "en")
        ) {
          capsParts.push("NE");
          i += 2;
          continue;
        }

        // 4) KE... : one or more "kulupu (e|en)" pairs become "KE" repeated
        if (i + 1 < end && words[i] === "kulupu" && (words[i + 1] === "e" || words[i + 1] === "en")) {
          let count = 0;
          while (i + 1 < end && words[i] === "kulupu" && (words[i + 1] === "e" || words[i + 1] === "en")) {
            count += 1;
            i += 2;
          }
          capsParts.push("KE".repeat(count));
          continue;
        }

        // 5) Digits:
        //    - "<digitWord> (esun|en)"
        //    - "(nasa|nena) <digitWord>" for NI/NA/NU style
        if (i + 1 < end) {
          // "(nasa|nena) ijo/awen/utala"
          if ((words[i] === "nasa" || words[i] === "nena") && DIGIT_WORD_TO_TOKEN[words[i + 1]]) {
            const tok = DIGIT_WORD_TO_TOKEN[words[i + 1]];
            if (tok === "NI" || tok === "NA" || tok === "NU") {
              capsParts.push(tok);
              i += 2;
              continue;
            }
          }

          // "wan (esun|en)", "tu (esun|en)", ...
          if (DIGIT_WORD_TO_TOKEN[words[i]] && (words[i + 1] === "esun" || words[i + 1] === "en")) {
            capsParts.push(DIGIT_WORD_TO_TOKEN[words[i]]);
            i += 2;
            continue;
          }
        }

        // 6) Decimal point marker:
        // - Short form: (ni o) or (nena o) => NO + NE
        // - Visible "NONE" form: (ni o nasa e) / (nena o nena en) => NO + NE
        if (i + 1 < end) {
          const w0 = words[i], w1 = words[i + 1];
          const w2 = (i + 2 < end) ? words[i + 2] : null;
          const w3 = (i + 3 < end) ? words[i + 3] : null;

          // Visible "NONE" form: (ni|nena) o (nasa|nena) (e|en)
          if (
            (w0 === "nasa" || w0 === "ni" || w0 === "nena") && w1 === "o" &&
            (w2 === "nasa" || w2 === "nena") &&
            (w3 === "e" || w3 === "en")
          ) {
            capsParts.push("NO", "NE");
            i += 4;
            continue;
          }

          // Short form: (ni|nena) o
          if ((w0 === "nasa" || w0 === "ni" || w0 === "nena") && w1 === "o") {
            capsParts.push("NO", "NE");
            i += 2;
            continue;
          }
        }


        // Percent marker:
        // - "open kipisi (e|en)" => OK
        // - "nena open kipisi (e|en)" => OK
        if (i + 2 < end && words[i] === "open" && words[i + 1] === "kipisi" && (words[i + 2] === "e" || words[i + 2] === "en")) {
          capsParts.push("OK");
          i += 3;
          continue;
        }
        if (i + 3 < end && words[i] === "nena" && words[i + 1] === "open" && words[i + 2] === "kipisi" && (words[i + 3] === "e" || words[i + 3] === "en")) {
          capsParts.push("OK");
          i += 4;
          continue;
        }



        return null;
      }

      const caps = capsParts.join("") + "N";

      // Validate tokenization
      tokenizeNanpaCaps(caps);

      return { caps, words };
    }

    // -------------------------------
    // #~ number-code parsing
    // -------------------------------

    const NUMBER_CODE_LETTER_TO_PAIR = {
      "I": "NI",
      "W": "WE",
      "T": "TE",
      "S": "SE",
      "A": "NA",
      "L": "LE",
      "U": "NU",
      "M": "ME",
      "P": "PE",
      "J": "JE",
      // O and K are handled as run-length tokens (NO / KE).
    };

    function normalizeNumberCodeInput(raw) {
      return String(raw ?? "").trim().replace(/\s+/g, "");
    }

    function tryParseNanpaLinjanNumberCodeToCaps(raw) {
      const s0 = normalizeNumberCodeInput(raw);
      if (!s0) return null;

      if (!s0.toUpperCase().startsWith("#~")) return null;

      let body = s0.slice(2).toUpperCase();

      let hasPercentOK = false;
      if (body.length >= 2 && body.endsWith("OK")) {
        hasPercentOK = true;
        body = body.slice(0, -2);
      }

      if (!body) throw new Error("Number code '#~' must have letters after it.");

      if (!/^[A-Z]+$/.test(body)) {
        throw new Error("Number code may only contain letters A–Z after '#~'.");
      }

      const parts = ["NE"];
      let i = 0;

      while (i < body.length) {
        const ch = body[i];

                if (ch === "O") {
          let j = i;
          while (j < body.length && body[j] === "O") j++;
          const count = j - i;

          if (count < 1 || count > 3) throw new Error("Invalid run of 'O' in number code (max 3).");

          // IMPORTANT:
          // - O at the very start of the number-code body represents a leading negative sign (NO).
          // - O elsewhere represents the decimal point operator (NO + NE), i.e. "NONE" in caps.
          // - OO represents NONO, OOO represents NONONO (kept as before).
          if (count === 1) {
            if (i === 0) {
              // Leading sign
              parts.push("NO");
            } else {
              // Decimal point marker: NO + NE => "NONE"
              parts.push("NO", "NE");
            }
          } else {
            // OO => "NONO", OOO => "NONONO"
            parts.push("NO".repeat(count));
          }

          i = j;
          continue;
        }


        if (ch === "K") {
          let j = i;
          while (j < body.length && body[j] === "K") j++;
          const count = j - i;

          if (count < 1 || count > 3) throw new Error("Invalid run of 'K' in number code (max 3).");

          parts.push("KE".repeat(count));
          i = j;
          continue;
        }

        const pair = NUMBER_CODE_LETTER_TO_PAIR[ch];
        if (!pair) {
          throw new Error(`Invalid letter '${ch}' in number code. Allowed: I,W,T,S,A,L,U,M,P,J plus O/K runs.`);
        }

        parts.push(pair);
        i += 1;
      }

      let caps = parts.join("") + "N";
      if (hasPercentOK) {
        if (!caps.endsWith("N")) throw new Error("Internal error: caps must end with N");
        caps = caps.slice(0, -1) + "OKN";
      }


      tokenizeNanpaCaps(caps);

      const canonicalBody = body + (hasPercentOK ? "OK" : "");
      const canonicalStyled = canonicalBody.replace(/O/g, "o").replace(/K/g, "k");
      const canonicalCode = "#~" + canonicalStyled;

      return { caps, canonicalCode };

    }

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar=",") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      const codeGroupedFrac = groups.join(sepChar);
      return `${left}${decimalChar}${codeGroupedFrac}${suffix}`;
    }

    function latinNameToNumberCode(latinName) {
      const s = String(latinName ?? "");
      const noSpaces = s.replace(/\s+/g, "");
      const withoutNE = noSpaces.replace(/[nNeE]/g, "");

      // Uppercase everything for stability, then force O/K to lower-case
      // so percent/KE markers display as o/k (per your preference).
      const up = withoutNE.toUpperCase();
      const styled = up.replace(/O/g, "o").replace(/K/g, "k");

      return "#~" + styled;
    }


    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    function numberStrToNanpaCaps(
      s,
      { thousandsChar = ",", groupFractionTriplets = false, fractionGroupSize = 3 } = {}
    ) {
      if (s == null) throw new Error("s must be a string, not null");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      // trailing percent sign => append OK token before final N
      // Accept whitespace before/after %.
      let hasPercent = false;
      if (/%\s*$/.test(raw)) {
        hasPercent = true;
        raw = raw.replace(/%\s*$/, "").trim();
        if (!raw) throw new Error("Percent sign must follow a number.");
      }

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, thousandsChar);
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function applyPercentIfNeeded(capsOut) {
        if (!hasPercent) return capsOut;
        if (!capsOut.endsWith("N")) throw new Error("Internal error: caps must end with N");
        return capsOut.slice(0, -1) + "OKN";
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          if (out.length > 0 && out[out.length - 1] === "NENE") return;
          out.push("NENE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "K" || last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount =
              (last === "K" || last === "T") ? 1 :
              (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NEKE");
            for (const d of groups[idx]) out.push(DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            for (let i = 0; i < trailingZeroGroups; i++) out.push("KE");
          }
        }

        if (hasDecimal) {
          out.push(OPCHAR_TO_TOKEN["."]);
          for (const ch of fracPart) {
            if (ch === "_") continue;
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          for (let i = 0; i < magnitudeSuffixKeCount; i++) out.push("KE");
        }

        out.push("N");
        return out.join("");
      }

      // Mixed number: left + (num/den)
      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        let capsOut = leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
        capsOut = applyPercentIfNeeded(capsOut);
        return capsOut;
      }

      // Simple fraction: num/den
      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);

        let capsOut = numCaps + "NONO" + denCaps;
        capsOut = applyPercentIfNeeded(capsOut);
        return capsOut;
      }

      // Plain integer/decimal (+ optional magnitude suffix)
      let capsOut = encodeSingleNumberSegment(raw, true);
      capsOut = applyPercentIfNeeded(capsOut);
      return capsOut;
    }


    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const n = s.length;

      while (i < n - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= n - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    const TOKEN_TO_DIGIT_CHAR = {
      "NI": "0", "WE": "1", "TE": "2", "SE": "3", "NA": "4",
      "LE": "5", "NU": "6", "ME": "7", "PE": "8", "JE": "9",
    };

    function keTokenCount(t) {
      if (t === "KE") return 1;
      if (t === "KEKE") return 2;
      if (t === "KEKEKE") return 3;
      return 0;
    }

    // ============================
    // CHANGED: separator controls
    // - NENE (NE NE) uses ene separators (can be "_")
    // - NE + KE... + digit uses group separators (keeps "," for thousands)
    // ============================
    function decodeDecimalStyleTokensToString(segmentTokens, opts = {}) {
      if (!segmentTokens) return null;

      // Two different “group separators”:
      // - eneSep: used ONLY for NENE (NE NE)
      // - groupSep: used for NE + KE... when it is followed by digits (thousands grouping)
      const intEneSep     = (opts.intEneSep     != null) ? String(opts.intEneSep)     : ",";
      const intGroupSep   = (opts.intGroupSep   != null) ? String(opts.intGroupSep)   : ",";
      const fracEneSep    = (opts.fracEneSep    != null) ? String(opts.fracEneSep)    : "_";
      const fracGroupSep  = (opts.fracGroupSep  != null) ? String(opts.fracGroupSep)  : "_";

      const tokens = Array.from(segmentTokens);

      let i = 0;
      const end = tokens.length;

      let neg = false;
      if (i < end && tokens[i] === "NO" && !(i + 1 < end && tokens[i + 1] === "NE")) {
        neg = true;
        i += 1;
      }

      let mode = "int";
      let intStr = "";
      let fracStr = "";
      let suffixKeCount = 0;

      function appendInt(ch) { intStr += ch; }
      function appendFrac(ch) { fracStr += ch; }

      function ensureIntNonEmpty() {
        if (!intStr) intStr = "0";
      }

      function appendSep(isEne) {
        const sep =
          (mode === "int")
            ? (isEne ? intEneSep : intGroupSep)
            : (isEne ? fracEneSep : fracGroupSep);

        if (mode === "int") {
          if (!intStr) return;
          if (!intStr.endsWith(sep)) intStr += sep;
        } else {
          if (!fracStr) return;
          if (!fracStr.endsWith(sep)) fracStr += sep;
        }
      }
      function appendEneSep() { appendSep(true); }
      function appendGroupSep() { appendSep(false); }

      while (i < end) {
        const t = tokens[i];

        if (TOKEN_TO_DIGIT_CHAR[t] != null) {
          if (mode === "int") appendInt(TOKEN_TO_DIGIT_CHAR[t]);
          else appendFrac(TOKEN_TO_DIGIT_CHAR[t]);
          i += 1;
          continue;
        }

        if (t === "NO" && (i + 1 < end) && tokens[i + 1] === "NE") {
          if (mode !== "int") return null;
          ensureIntNonEmpty();
          mode = "frac";
          i += 2;
          continue;
        }

        // CHANGED: NENE gets ene-separator (can be "_")
        if (t === "NE" && (i + 1 < end) && tokens[i + 1] === "NE") {
          appendEneSep();
          i += 2;
          continue;
        }

        // NE + KE... : either thousands grouping (if followed by digits) or suffix magnitude (if not)
        if (t === "NE" && (i + 1 < end)) {
          let j = i + 1;
          let count = 0;

          while (j < end) {
            const c = keTokenCount(tokens[j]);
            if (!c) break;
            count += c;
            j += 1;
          }

          if (count > 0) {
            // If followed by digits => thousands grouping separator (must remain "," for int)
            if (j < end && TOKEN_TO_DIGIT_CHAR[tokens[j]] != null) {
              appendGroupSep();
              i = j;
              continue;
            }

            // Otherwise it's a magnitude suffix (K/M/B)
            suffixKeCount += count;
            i = j;
            continue;
          }

          return null;
        }

        if (keTokenCount(t) > 0) return null;

        return null;
      }

      ensureIntNonEmpty();

      let suffix = "";
      if (suffixKeCount > 0) {
        if (suffixKeCount === 1) suffix = "K";
        else if (suffixKeCount === 2) suffix = "M";
        else if (suffixKeCount === 3) suffix = "B";
        else suffix = `×1000^${suffixKeCount}`;
      }

      const sign = neg ? "-" : "";
      if (mode === "frac") {
        const fracNormalized = (fracStr === "") ? "0" : fracStr;
        return sign + intStr + "." + fracNormalized + suffix;
      }

      return sign + intStr + suffix;
    }

    // CHANGED: opts passthrough so cartouche value can differ
    function tryDecodeCapsToDisplayValue(caps, opts = {}) {
      if (!caps) return null;

      const tokens = tokenizeNanpaCaps(String(caps).trim().toUpperCase());
      if (tokens.length < 2 || tokens[0] !== "NE" || tokens[tokens.length - 1] !== "N") return null;

      const finalNIdx = tokens.length - 1;

      const mixedIdx = tokens.indexOf("NONONO");
      if (mixedIdx >= 0) {
        const fracIdx = tokens.indexOf("NONO", mixedIdx + 1);
        if (fracIdx < 0) return null;

        const intTokens = tokens.slice(1, mixedIdx);
        const numTokens = tokens.slice(mixedIdx + 1, fracIdx);
        const denTokens = tokens.slice(fracIdx + 1, finalNIdx);

        const intStr = decodeDecimalStyleTokensToString(intTokens, opts);
        const numStr = decodeDecimalStyleTokensToString(numTokens, opts);
        const denStr = decodeDecimalStyleTokensToString(denTokens, opts);

        if (!intStr || !numStr || !denStr) return null;

        return `${intStr}+${numStr}/${denStr}`;
      }

      const fracIdx = tokens.indexOf("NONO");
      if (fracIdx >= 0) {
        const numTokens = tokens.slice(1, fracIdx);
        const denTokens = tokens.slice(fracIdx + 1, finalNIdx);

        const numStr = decodeDecimalStyleTokensToString(numTokens, opts);
        const denStr = decodeDecimalStyleTokensToString(denTokens, opts);

        if (!numStr || !denStr) return null;

        return `${numStr}/${denStr}`;
      }

      const segTokens = tokens.slice(1, finalNIdx);
      return decodeDecimalStyleTokensToString(segTokens, opts);
    }

    // CHANGED: drive two different strings:
    // - Display value: default commas
    // - Cartouche value: "_" for NENE breaks, but "," for true thousands grouping
    function setDecimalValueFromCapsOrClear(caps) {
      const vDisplay = tryDecodeCapsToDisplayValue(caps); // default behavior (commas for int)
      const vCartouche = tryDecodeCapsToDisplayValue(caps, {
        intEneSep: "_",     // NENE breaks in integer part
        intGroupSep: ",",   // thousands grouping stays comma
        fracEneSep: "_",    // keep underscores in fractional groupings
        fracGroupSep: "_"   // keep underscores in fractional groupings
      });
      setDecimalValueLine(vDisplay, vCartouche);
    }

    /**
     * Convert nanpa-caps tokens into TP words.
     * Traditional vs Uniform controlled by { mode }:
     * - Uniform affects ALL occurrences of:
     *   - esun -> en
     *   - nasa -> nena
     *   - e -> en
     * - Only "nanpa" at start and end remains "nanpa".
     */
    function nanpaCapsTokensToTpWords(tokens, { mode = "traditional" } = {}) {
      if (!tokens || tokens.length === 0) return [];

      const uniform = (mode === "uniform");
      const out = [];

      // Uniform: esun -> en everywhere
      const E_WORD = uniform ? "en" : "esun";

      // Uniform: standalone e -> en everywhere
      const E_WORD_FOR_NE_AFTER_START = uniform ? "en" : "e";

      // Uniform: nasa -> nena everywhere
      const N_WORD = uniform ? "nena" : "nasa";

      // In traditional, NO is context-sensitive: ni/nena; in uniform, NO uses nena anyway
      const N_WORD_DECIMAL_POINT = uniform ? "nena" : "ni";
      const N_WORD_FRACTION = "nena";

      // Start/end are always nanpa
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) {
            // Start is always "nanpa", but the second word is affected (esun -> en)
            out.push("nanpa", E_WORD);
            afterStartingNe = true;
          } else {
            // Non-initial NE: (nasa|nena) (e|en)
            out.push(N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
          }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          // These digit tokens historically use "nasa <digitWord>" for NI/NA/NU
          // Uniform changes "nasa" -> "nena" via N_WORD.
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD); // Uniform changes esun -> en via E_WORD.
          continue;
        }

        if (t === "NO") {
          // Case A: immediately after starting NE => leading negative sign
          if (afterStartingNe) {
            out.push(N_WORD, WORD_FOR_NEGATIVE_SIGN);
            afterStartingNe = false;
            continue;
          }

          // Case B: decimal point operator is encoded as NO + NE (caps "NONE")
          // To make the cartouche visibly show "NONE", render it as:
          //   Traditional:  ni o nasa e
          //   Uniform:      nena o nena en
          const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
          if (nxt === "NE") {
            out.push(N_WORD_DECIMAL_POINT, "o", N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
            i += 1; // consume the following NE (already rendered)
            continue;
          }

          // Fallback (should not normally occur mid-stream)
          out.push(N_WORD_DECIMAL_POINT, "o");
          afterStartingNe = false;
          continue;
        }



        if (t === "NONO") {
          out.push("nena","o","nena","o");
          afterStartingNe = false;
          continue;
        }

        if (t === "NONONO") {
          // Uniform affects nasa -> nena via N_WORD
          out.push(N_WORD,"o",N_WORD,"o",N_WORD,"o");
          afterStartingNe = false;
          continue;
        }

        // Uniform affects "e" -> "en" via E_WORD_FOR_NE_AFTER_START
        if (t === "KE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

        if (t === "OK") {
          // Percent marker:
          // Traditional vs Uniform affects only the joiner (e vs en) via E_WORD_FOR_NE_AFTER_START
          out.push("nena", "open", "kipisi", E_WORD_FOR_NE_AFTER_START);
          afterStartingNe = false;
          continue;
        }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }

    const WORD_TO_UCSUR_CP = {
      "nanpa": 0xF193D,
      "esun":  0xF190B,
      "en":    0xF190A,
      "e":     0xF1909,
      "nasa":  0xF193E,
      "ni":    0xF1941,
      "nena":  0xF1940,
      "o":     0xF1944,
      "kulupu":0xF191F,

      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "sijelo":0xF195B,
      "awen":  0xF1908,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913,

      "a": 0xF1900,
      "akesi": 0xF1901,
      "ala": 0xF1902,
      "alasa": 0xF1903,
      "ale": 0xF1904,
      "ali": 0xF1904,
      "anpa": 0xF1905,
      "ante": 0xF1906,
      "anu": 0xF1907,
      "ike": 0xF190D,
      "ilo": 0xF190E,
      "insa": 0xF190F,
      "jaki": 0xF1910,
      "jan": 0xF1911,
      "jelo": 0xF1912,
      "kala": 0xF1914,
      "kalama": 0xF1915,
      "kama": 0xF1916,
      "kasi": 0xF1917,
      "ken": 0xF1918,
      "kepeken": 0xF1919,
      "kili": 0xF191A,
      "kiwen": 0xF191B,
      "ko": 0xF191C,
      "kon": 0xF191D,
      "kule": 0xF191E,
      "kute": 0xF1920,
      "la": 0xF1921,
      "lape": 0xF1922,
      "laso": 0xF1923,
      "lawa": 0xF1924,
      "len": 0xF1925,
      "lete": 0xF1926,
      "li": 0xF1927,
      "lili": 0xF1928,
      "linja": 0xF1929,
      "lipu": 0xF192A,
      "loje": 0xF192B,
      "lon": 0xF192C,
      "lukin": 0xF192E,
      "lupa": 0xF192F,
      "ma": 0xF1930,
      "mama": 0xF1931,
      "mani": 0xF1932,
      "meli": 0xF1933,
      "mi": 0xF1934,
      "mije": 0xF1935,
      "moku": 0xF1936,
      "moli": 0xF1937,
      "monsi": 0xF1938,
      "mu": 0xF1939,
      "musi": 0xF193B,
      "mute": 0xF193C,
      "nasin": 0xF193F,
      "nimi": 0xF1942,
      "noka": 0xF1943,
      "olin": 0xF1945,
      "ona": 0xF1946,
      "open": 0xF1947,
      "pakala": 0xF1948,
      "pali": 0xF1949,
      "palisa": 0xF194A,
      "pan":    0xF194B,
      "pana":   0xF194C,
      "pi":     0xF194D,
      "pilin":  0xF194E,
      "pimeja": 0xF194F,
      "pini": 0xF1950,
      "poka": 0xF1952,
      "poki": 0xF1953,
      "pona": 0xF1954,
      "pu": 0xF1955,
      "sama": 0xF1956,
      "seli": 0xF1957,
      "selo": 0xF1958,
      "seme": 0xF1959,
      "sewi": 0xF195A,
      "sike": 0xF195C,
      "sin": 0xF195D,
      "sina": 0xF195E,
      "sinpin": 0xF195F,
      "sitelen": 0xF1960,
      "sona": 0xF1961,
      "soweli": 0xF1962,
      "suli": 0xF1963,
      "suno": 0xF1964,
      "supa": 0xF1965,
      "suwi": 0xF1966,
      "tan": 0xF1967,
      "taso": 0xF1968,
      "tawa": 0xF1969,
      "telo": 0xF196A,
      "tenpo": 0xF196B,
      "toki": 0xF196C,
      "tomo": 0xF196D,
      "unpa": 0xF196F,
      "uta": 0xF1970,
      "walo": 0xF1972,
      "waso": 0xF1974,
      "wawa": 0xF1975,
      "weka": 0xF1976,
      "wile": 0xF1977,
      "namako": 0xF1978,
      "kin": 0xF1979,
      "oko": 0xF197A,
      "kipisi": 0xF197B,
      "leko": 0xF197C,
      "monsuta": 0xF197D,
      "tonsi": 0xF197E,
      "jasima": 0xF197F,
      "kijetesantakalu": 0xF1980,
      "soko": 0xF1981,
      "meso": 0xF1982,
      "epiku": 0xF1983,
      "kokosila": 0xF1984,
      "lanpan": 0xF1985,
      "n": 0xF1986,
      "misikeke": 0xF1987,
      "ku": 0xF1988,

      "epiku": 0xF1983,
      "kokosila": 0xF1984, "lanpan": 0xF1985, "n": 0xF1986, "misikeke": 0xF1987, "ku": 0xF1988,
      "pake": 0xF19A0, "apeja": 0xF19A1, "majuna": 0xF19A2, "powe": 0xF19A3,
      "·": 0xF199C, ":": 0xF199D, 
      ",": 0xF199E,
      "ota": 0xF199C, "kolon": 0xF199D, "koma": 0xF199E
    };

    const UCSUR_CP_TO_WORD = new Map(
      Object.entries(WORD_TO_UCSUR_CP).map(([w, cp]) => [cp, w])
    );

    function ucsurCodepointsToTpWords(codepoints) {
      const words = [];
      for (const cp of codepoints) {
        const w = UCSUR_CP_TO_WORD.get(cp);
        if (!w) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(`No Toki Pona word mapping for code point U+${hex}`);
        }
        words.push(w);
      }
      return words;
    }

    function tpWordsToText(words) {
      return (words ?? []).join(" ");
    }

    function parseTpWordsToCodepoints(input) {
      const raw = String(input ?? "").trim();
      if (!raw) return [];

      //const parts = raw.split(/\s+/).filter(Boolean);
      const parts = raw.split(/(\s+|[·:])/).filter(s => s && !/^\s+$/.test(s));

      const cps = [];
      for (const p of parts) {
        const pp = WORD_TO_UCSUR_CP[p];
        if(pp == null){
          const w = p.toLowerCase();
          const cp = WORD_TO_UCSUR_CP[w];
          if (cp == null) {
            throw new Error(`Invalid Toki Pona word "${p}". Only mapped words are allowed.`);
          }
          cps.push(cp);
        }else{
          cps.push(pp);
        }
      }

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function tpWordsToUcsurCodepoints(words) {
      const cps = [];
      for (const w of words) {
        const key = String(w).toLowerCase();
        const cp = WORD_TO_UCSUR_CP[key];
        if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
        cps.push(cp);
      }
      return cps;
    }

    function decimalToUcsurCodepoints(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return [];

      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function splitCartoucheCapsLetters(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      let outStr = "";
      let i = 0;
      const end = s0.length - 1;

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);
        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { outStr += "neno "; i += 4; continue; }
        if (pair === "NE" && nextPair === "NE") { outStr += "n "; outStr += "ene "; i += 4; continue; }
        if (pair === "NO" && nextPair === "NE" && i > 0) { outStr += "n "; outStr += "one "; i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          outStr += "n ";
          outStr += "o";
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          outStr += "no".repeat(countNo);
          if ((i + 2 * countNo) < end) outStr += " ";
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          outStr += "n ";
          outStr += "e";
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          outStr += "ke".repeat(countKe);
          if ((i + 2 * countKe) < end) outStr += " ";
          i += 2 + 2 * countKe;
          continue;
        }

        if (pair === "OK") {
          // IMPORTANT: OK is a suffix-like operator token; it must start a new segment with delimiter "n"
          // so "...LE OK..." becomes "...le n oke..." => "nelenoken" after final 'n' append.
          if (i > 0 && !/\s$/.test(outStr)) outStr += " ";
          if (i > 0) outStr += "n ";
          outStr += "oke";
        } else {
          outStr += pair.toLowerCase();
        }


        i += 2;
      }

      outStr = outStr.replace(/\s+n(?=\s|$)/g, "n");
      outStr = outStr.trim();
      outStr += "n";
      return outStr;
    }

    function encodeDecimalToLatin(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return "";
      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });
      return splitCartoucheCapsLetters(caps);
    }

    function isValidNanpaLinjanProperName(raw) {
      const s = String(raw ?? "").replace(/\s+/g, "");
      if (!s) return false;
      if (!/^[a-zA-Z]+$/.test(s)) return false;
      if (!/[nN]$/.test(s)) return false;

      const core = s.slice(0, -1);
      if (core.length < 2 || (core.length % 2) !== 0) return false;

      let caps = core.toUpperCase() + "N";
      if (caps.endsWith("NOKEN")) {
        caps = caps.slice(0, -5) + "OKN";
      }

      if (!caps.startsWith("NE")) return false;

      try { tokenizeNanpaCaps(caps); return true; }
      catch { return false; }
    }

    function splitCartoucheCapsLettersSpaced(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      const parts = [];
      let current = "";
      let i = 0;
      const end = s0.length - 1;

      function flushCurrent() {
        if (current) { parts.push(current); current = ""; }
      }

      function attachDelimiterN() {
        if (current) { current += "n"; flushCurrent(); return; }
        if (parts.length === 0) { parts.push("n"); return; }
        parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      }

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);

        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { flushCurrent(); parts.push("neno"); i += 4; continue; }

        if (pair === "NE" && nextPair === "NE") { flushCurrent(); attachDelimiterN(); parts.push("ene"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NE" && i > 0) { flushCurrent(); attachDelimiterN(); parts.push("one"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          flushCurrent();
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          attachDelimiterN();
          parts.push("o" + "no".repeat(countNo));
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          flushCurrent();
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          attachDelimiterN();
          parts.push("e" + "ke".repeat(countKe));
          i += 2 + 2 * countKe;
          continue;
        }

        if (pair === "OK") {
          // OK suffix should be its own word: "... n oken"
          flushCurrent();
          attachDelimiterN();
          parts.push("oken");
          i += 2;
          continue;
        } else {
          current += pair.toLowerCase();
        }


        i += 2;
      }

      flushCurrent();

      if (parts.length === 0) return "n";
      const last = String(parts[parts.length - 1]);
      parts[parts.length - 1] = last.endsWith("n") ? last : (last + "n");

      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function nanpaLinjanProperNameToUcsurCodepoints(nameStr) {
      const s = String(nameStr ?? "").toLowerCase().replace(/\s+/g, "");
      if (!s || !s.endsWith("n")) throw new Error("Not a nanpa-linja-n proper name (missing final 'n').");

      const core = s.slice(0, -1);
      let caps = core.toUpperCase() + "N";

      // NEW: allow percent marker in proper names.
      // If user ends the name with "...oken", that uppercases to "...NOKEN" (NO+KE+N).
      // Collapse trailing NO+KE into OK.
      if (caps.endsWith("NOKEN")) {
        caps = caps.slice(0, -5) + "OKN";
      }


      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function codepointsToHexString(codepoints) {
      return codepoints.map(cp => cp.toString(16).toUpperCase().padStart(4, "0")).join(" ");
    }

    function codepointsToHexStringWithCartouche(codepoints) {
      return codepointsToHexString(withCartoucheMarkers(codepoints));
    }

    function parseHexCodepoints(input) {
      const raw = input.trim();
      if (!raw) return [];
      const parts = raw.split(/\s+/).map(s => s.replace(/^U\+/i, ""));
      const cps = parts.map(p => {
        const cp = parseInt(p, 16);
        if (!Number.isFinite(cp)) throw new Error(`Invalid hex code point: "${p}"`);
        return cp;
      });

      assertAllAllowedTpUcsur(cps);

      return stripCartoucheMarkers(cps);
    }

    /* =======================
       Cartouche rendering
       ======================= */

    function drawRoundedRect(ctx, x, y, w, h, r) {
      const radius = Math.min(r, w / 2, h / 2);
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + w, y, x + w, y + h, radius);
      ctx.arcTo(x + w, y + h, x, y + h, radius);
      ctx.arcTo(x, y + h, x, y, radius);
      ctx.arcTo(x, y, x + w, y, radius);
      ctx.closePath();
    }

    function renderMixedCartoucheToCanvas(canvas, codepoints, largePx, smallPx, 
      quarterSet,
      halfSet,
      twoThirdsSet, 
      options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);
        // Multi-size selection:
        // - quarterSet => use smallPx (your existing quarter-size)
        // - halfSet => 0.5 * largePx
        // - twoThirdsSet => (2/3) * largePx
        // - otherwise => largePx
        const px =
          (quarterSet && quarterSet.has(cp)) ? smallPx :
          (halfSet && halfSet.has(cp)) ? Math.max(1, Math.round(largePx * 0.5)) :
          (twoThirdsSet && twoThirdsSet.has(cp)) ? Math.max(1, Math.round(largePx * (2/3))) :
          largePx;


        ctx.font = `${px}px "${FONT_FAMILY}"`;
        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, px, tightW, left, ascent, descent });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;
      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";

      for (const g of glyphRuns) {
        ctx2.font = `${g.px}px "${FONT_FAMILY}"`;
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }

      return { cartW, cartH, textW: totalWidth, textH: textHeight, maxAscent, maxDescent };
    }

    function renderUniformCartoucheFromCodepoints(canvas, codepoints, fontPx, quarterSet,
  halfSet,
  twoThirdsSet,
  options = {}) {
      const pad = options.padding ?? 18;
      const border = options.border ?? 2;
      const corner = options.cornerRadius ?? 16;
      const letterGap = options.letterGap ?? 0;

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const glyphRuns = [];
      let totalWidth = 0;
      let maxAscent = 0;
      let maxDescent = 0;

      for (const cp of codepoints) {
        const ch = String.fromCodePoint(cp);

        const px =
          (quarterSet && quarterSet.has(cp)) ? Math.max(1, Math.round(fontPx * 0.25)) :
          (halfSet && halfSet.has(cp)) ? Math.max(1, Math.round(fontPx * 0.5)) :
          (twoThirdsSet && twoThirdsSet.has(cp)) ? Math.max(1, Math.round(fontPx * (2/3))) :
          fontPx;

        ctx.font = `${px}px "${FONT_FAMILY}"`;

        const m = ctx.measureText(ch);

        const ascent = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
        const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);


        const left = m.actualBoundingBoxLeft ?? 0;
        const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
        const tightW = Math.ceil(left + right);

        glyphRuns.push({ ch, left, tightW, px });

        totalWidth += tightW + letterGap;
        if (ascent > maxAscent) maxAscent = ascent;
        if (descent > maxDescent) maxDescent = descent;

      }

      if (glyphRuns.length > 0) totalWidth -= letterGap;

      const textHeight = Math.ceil(maxAscent + maxDescent);
      const cartW = Math.ceil(totalWidth + pad * 2);
      const cartH = Math.ceil(textHeight + pad * 2);

      canvas.width = cartW + border * 2;
      canvas.height = cartH + border * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      drawRoundedRect(ctx2, border, border, cartW, cartH, corner);
      ctx2.lineWidth = border;
      ctx2.strokeStyle = "#111";
      ctx2.stroke();

      const baselineY = border + pad + maxAscent;
      let x = border + pad;

      ctx2.fillStyle = "#111";
      for (const g of glyphRuns) {
        ctx2.font = `${g.px}px "${FONT_FAMILY}"`;   // <-- CRITICAL FIX
        const drawX = x + (g.left ?? 0);
        ctx2.fillText(g.ch, drawX, baselineY);
        x += g.tightW + letterGap;
      }

    }

    async function ensureFontLoaded() {
      const sampleCp = 0xF190B;
      const sampleChar = String.fromCodePoint(sampleCp);
      const fontSpec = `24px "${FONT_FAMILY}"`;

      function fallbackLikely(sampleText) {
        const c = document.createElement("canvas");
        const ctx = c.getContext("2d");
        ctx.font = `48px "${FONT_FAMILY}", monospace`;
        const w1 = ctx.measureText(sampleText).width;
        ctx.font = `48px monospace`;
        const w2 = ctx.measureText(sampleText).width;
        return w1 === w2;
      }

      if (!document.fonts || !document.fonts.load || !document.fonts.check) {
        console.warn("[font] CSS Font Loading API not available; cannot reliably validate load.");
        return;
      }

      try {
        await document.fonts.load(fontSpec, sampleChar);
        await document.fonts.ready;

        const ok = document.fonts.check(fontSpec, sampleChar);
        if (!ok) {
          console.warn(`[font] NOT CONFIRMED: ${fontSpec}`);
          console.warn("[font] If opening via file://, use Live Server / http://localhost to avoid font load restrictions.");
        }

        if (fallbackLikely(sampleChar)) {
          console.warn("[font] fallback likely (width matches monospace). Font may not have the glyph, or did not load.");
        }
      } catch (e) {
        console.error("[font] load threw error:", e);
      }
    }

    /* =======================
       UI wiring
       ======================= */

    const LETTER_SPACING_GAP = 4;

    const LARGE_FONT_SIZE = 72;
    const SMALL_FONT_SIZE = 20;

    // smaller "small cartouche" glyph sizes
    const LARGE_TINY_FONT_SIZE = 28;
    const SMALL_TINY_FONT_SIZE = 7;

    const SMALL_CANVAS_RENDER_OPTS = { padding: 10, border: 1, cornerRadius: 10, letterGap: 2 };

    const elDecimal = document.getElementById("decimalInput");
    const elLatinOut = document.getElementById("latinOut");
    const elCodepointsOut = document.getElementById("codepointsOut");
    const elNumberCodeOut = document.getElementById("numberCodeOut");

    const canvasLarge = document.getElementById("canvasLarge");
    const canvasSmall = document.getElementById("canvasSmall");

    const elCodesIn = document.getElementById("codepointsIn");

    const elTpWordsOut = document.getElementById("tpWordsOut");
    const elTpWordsIn = document.getElementById("tpWordsIn");

    const MAX_DECIMAL_INPUT_CHARS = 500;
    const MAX_HEX_CODE_INPUT_CHARS = 3500;
    const MAX_TOKI_PONA_WORD_INPUT_CHARS = 2500;

    const elDecimalValueLine = document.getElementById("decimalValueLine");
    const elDecimalValueText = document.getElementById("decimalValueText");

    const elCartoucheValueBox = document.getElementById("cartoucheValueBox");
    const elCartoucheValueText = document.getElementById("cartoucheValueText");
    const elCartoucheValueTextTp = document.getElementById("cartoucheValueTextTp");

    // ------------------------------------------------------
    // NEW: silent input clearing (no user-facing input events)
    // ------------------------------------------------------
    let suppressInputHandlers = false;

    function withSuppressedInputHandlers(fn) {
      const prev = suppressInputHandlers;
      suppressInputHandlers = true;
      try { fn(); } finally { suppressInputHandlers = prev; }
    }

    function setValueSilently(el, v = "") {
      if (!el) return;
      withSuppressedInputHandlers(() => { el.value = v; });
    }

    function clearOtherInputs(active) {
      // active: "decimal" | "codes" | "words"
      withSuppressedInputHandlers(() => {
        if (active !== "decimal") setValueSilently(elDecimal, "");
        if (active !== "codes")   setValueSilently(elCodesIn, "");
        if (active !== "words")   setValueSilently(elTpWordsIn, "");

        // If you want, also clear validity state when we clear the TP words box
        if (active !== "words" && elTpWordsIn) elTpWordsIn.setCustomValidity("");
      });
    }


    //PNG download
    function safeFilenamePart(s) {
      const t = String(s ?? "").trim();
      if (!t) return "cartouche";
      // keep it filesystem-friendly
      return t.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 80) || "cartouche";
    }

    /**
     * Export a canvas to PNG with transparency preserved.
     * `scale` lets you export a higher-res image (e.g., 4 = 4x).
     */
    function downloadCanvasAsTransparentPng(canvas, { filenameBase = "cartouche", scale = 1 } = {}) {
      if (!canvas) throw new Error("Canvas not found.");

      const w = canvas.width | 0;
      const h = canvas.height | 0;
      if (w <= 0 || h <= 0) throw new Error("Canvas is empty (nothing to download yet).");

      // Offscreen copy so we can scale and guarantee we only export drawn pixels.
      const out = document.createElement("canvas");
      out.width = Math.max(1, Math.floor(w * scale));
      out.height = Math.max(1, Math.floor(h * scale));

      const ctx = out.getContext("2d", { alpha: true });
      // Do NOT fill a background: keep it transparent.
      ctx.clearRect(0, 0, out.width, out.height);

      // Scale copy
      ctx.imageSmoothingEnabled = true; // fine for fonts/curves; set false if you want hard pixels
      ctx.drawImage(canvas, 0, 0, out.width, out.height);

      const filename = safeFilenamePart(filenameBase) + ".png";

      // Prefer toBlob (better memory behavior)
      if (out.toBlob) {
        out.toBlob((blob) => {
          if (!blob) throw new Error("PNG export failed (no blob).");

          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();

          // cleanup
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        }, "image/png");
        return;
      }

      // Fallback
      const dataUrl = out.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    function wireDownloadButton() {
      const btn = document.getElementById("btnDownloadCartouchePng");
      if (!btn) return;

      btn.addEventListener("click", () => {
        try {
          // Choose a meaningful filename. Number code tends to be short and unique.
          const code = (document.getElementById("numberCodeOut")?.value ?? "").trim();
          const base = code ? code : "cartouche";

          // Export the visible/primary cartouche. Increase scale if you want a larger PNG.
          downloadCanvasAsTransparentPng(canvasSmall, { filenameBase: base, scale: 1 });

          announceStatus("Downloaded cartouche PNG.");
        } catch (err) {
          showAlertAndAnnounce(err?.message ?? String(err));
        }
      });
    }


    // CHANGED: accept two values
    // - displayValueOrNull: used for the (hidden) large "Value:" line
    // - cartoucheValueOrNull: used for the small-cartouche value under cartouche
    //   (falls back to displayValueOrNull if omitted)
    function setDecimalValueLine(displayValueOrNull, cartoucheValueOrNull = displayValueOrNull) {
      const sDisplay = (displayValueOrNull == null) ? "" : String(displayValueOrNull).trim();
      const sCart = (cartoucheValueOrNull == null) ? "" : String(cartoucheValueOrNull).trim();

      // Existing (large section) line
      if (elDecimalValueLine && elDecimalValueText) {
        if (!sDisplay) {
          elDecimalValueText.textContent = "";
          elDecimalValueLine.classList.add("hidden");
        } else {
          elDecimalValueText.textContent = sDisplay;
          elDecimalValueLine.classList.remove("hidden");
        }
      }

      // Small-cartouche “Cartouche value” line
      if (elCartoucheValueBox && elCartoucheValueText && elCartoucheValueTextTp) {
        if (!sCart) {
          elCartoucheValueText.textContent = "";
          elCartoucheValueTextTp.textContent = "";
          elCartoucheValueBox.classList.add("hidden");
        } else {
          elCartoucheValueText.textContent = sCart;
          elCartoucheValueTextTp.textContent = sCart;
          elCartoucheValueBox.classList.remove("hidden");
        }
      }
    }

    function enforceMaxLen(el, maxLen = MAX_DECIMAL_INPUT_CHARS) {
      if (!el) return;
      const s = String(el.value ?? "");
      if (s.length > maxLen) el.value = s.slice(0, maxLen);
    }

    enforceMaxLen(elDecimal,  MAX_DECIMAL_INPUT_CHARS);
    enforceMaxLen(elCodesIn,  MAX_HEX_CODE_INPUT_CHARS);
    enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

    function onDecimalInput() {
      if (suppressInputHandlers) return;
      enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS);
    }
    function onCodesInput() {
      if (suppressInputHandlers) return;
      enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS);
    }
    function onTpWordsInputMaxLen() {
      if (suppressInputHandlers) return;
      enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);
    }

    if (elDecimal)  elDecimal.addEventListener("input", onDecimalInput);
    if (elCodesIn)  elCodesIn.addEventListener("input", onCodesInput);
    if (elTpWordsIn) elTpWordsIn.addEventListener("input", onTpWordsInputMaxLen);

    const elDigitTableBody = document.getElementById("digitTableBody");

    function buildDigitReferenceTable() {
      if (!elDigitTableBody) return;
      elDigitTableBody.innerHTML = "";

      const smallSet = getSmallCodepointsSet();
      const quarterSet = getQuarterCodepointsSet();
      const halfSet = getHalfCodepointsSet();
      const twoThirdsSet = getTwoThirdsCodepointsSet();

      const TINY_LARGE_PX = 22;
      const TINY_SMALL_PX = 8;

      for (let d = 0; d <= 9; d++) {
        const digitStr = String(d);
        const latinNameRaw = encodeDecimalToLatin(digitStr);
        const latinNameDisplay = titleCaseNanpaProperNameForDisplay(latinNameRaw);

        const cps = decimalToUcsurCodepoints(digitStr);
        const unique_number_code = latinNameToNumberCode(latinNameRaw);

        const tr = document.createElement("tr");

        const tdDigit = document.createElement("td");
        tdDigit.className = "mono";
        tdDigit.textContent = digitStr;

        const tdName = document.createElement("td");
        tdName.className = "mono";

        tdName.textContent = fixOkenSuffixSpacing(latinNameDisplay);

        const tdUniqueNumberCode = document.createElement("td");
        tdUniqueNumberCode.className = "mono";
        tdUniqueNumberCode.textContent = unique_number_code;

        const tdCanvas = document.createElement("td");
        const canvas = document.createElement("canvas");
        canvas.className = "digitCanvas";
        canvas.setAttribute("aria-hidden", "true");
        tdCanvas.appendChild(canvas);

        tr.appendChild(tdDigit);
        tr.appendChild(tdName);
        tr.appendChild(tdUniqueNumberCode);
        tr.appendChild(tdCanvas);

        elDigitTableBody.appendChild(tr);

        renderMixedCartoucheToCanvas(
          canvas,
          cps,
          TINY_LARGE_PX,
          TINY_SMALL_PX,
         quarterSet,
  halfSet,
  twoThirdsSet,
          { padding: 8, border: 1, cornerRadius: 10, letterGap: 2 }
        );
      }
    }

    async function runEncodeFromDecimal() {
      await ensureFontLoaded();
      enforceMaxLen(elDecimal, MAX_DECIMAL_INPUT_CHARS);

      const raw = normalizeVulgarFractionInput(elDecimal.value);
      const caps = looksLikeNanpaCaps(raw)
        ? raw.toUpperCase()
        : numberStrToNanpaCaps(raw, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      setDecimalValueFromCapsOrClear(caps);

      const latinRaw = encodeDecimalToLatin(raw);
      const latinDisplay = titleCaseNanpaProperNameForDisplay(latinRaw);

      elLatinOut.value = fixOkenSuffixSpacing(latinDisplay);
      elNumberCodeOut.value = latinNameToNumberCode(latinRaw);

      const cps = decimalToUcsurCodepoints(raw);

      if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
      if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

      const smallSet = getSmallCodepointsSet();
      const quarterSet = getQuarterCodepointsSet();
      const halfSet = getHalfCodepointsSet();
      const twoThirdsSet = getTwoThirdsCodepointsSet();

      renderMixedCartoucheToCanvas(
        canvasSmall,
        cps,
        LARGE_TINY_FONT_SIZE,
        SMALL_TINY_FONT_SIZE,
        quarterSet,
  halfSet,
  twoThirdsSet,
        SMALL_CANVAS_RENDER_OPTS
      );

      renderMixedCartoucheToCanvas(
        canvasLarge,
        cps,
        LARGE_FONT_SIZE,
        SMALL_FONT_SIZE,
       quarterSet,
  halfSet,
  twoThirdsSet,
        { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
      );

      announceStatus(`Rendered value ${raw}.`);
    }

    async function handleEncodeClick({ clearOthers = true } = {}) {
      try {
        lastAction = "decimal";
        if (clearOthers) clearOtherInputs("decimal");
        await runEncodeFromDecimal();
      } catch (err) {
        setDecimalValueLine(null, null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    }

    document.getElementById("btnEncode").addEventListener("click", () => {
      handleEncodeClick({ clearOthers: true });
    });

    async function handleFromCodesClick({ clearOthers = true } = {}) {
      try {
        lastAction = "codes";
        if (clearOthers) clearOtherInputs("codes");

        await ensureFontLoaded();
        enforceMaxLen(elCodesIn, MAX_HEX_CODE_INPUT_CHARS);

        const cps = parseHexCodepoints(elCodesIn.value);

        elLatinOut.value = String.fromCodePoint(...cps);
        if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);

        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);
        if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        try {
          const tpWords = ucsurCodepointsToTpWords(cps).join(" ");
          const parsed = tryParseNanpaLinjanTpPhraseToCaps(tpWords);
          if (parsed) setDecimalValueFromCapsOrClear(parsed.caps);
          else setDecimalValueLine(null, null);
        } catch {
          setDecimalValueLine(null, null);
        }

        const quarterSet = getQuarterCodepointsSet();
        const halfSet = getHalfCodepointsSet();
        const twoThirdsSet = getTwoThirdsCodepointsSet();

        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          quarterSet,
  halfSet,
  twoThirdsSet,
          SMALL_CANVAS_RENDER_OPTS
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          quarterSet,
  halfSet,
  twoThirdsSet,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

        announceStatus("Rendered from code points.");
      } catch (err) {
        setDecimalValueLine(null, null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    }

    document.getElementById("btnFromCodes")?.addEventListener("click", () => {
      handleFromCodesClick({ clearOthers: true });
    });

    async function handleFromWordsClick({ clearOthers = true } = {}) {
      try {
        lastAction = "words";
        if (clearOthers) clearOtherInputs("words");

        await ensureFontLoaded();
        enforceMaxLen(elTpWordsIn, MAX_TOKI_PONA_WORD_INPUT_CHARS);

        const rawInput = String(elTpWordsIn.value ?? "");

        const parsedNumberCode = tryParseNanpaLinjanNumberCodeToCaps(rawInput);
        if (parsedNumberCode) {
          const { caps, canonicalCode } = parsedNumberCode;

          setDecimalValueFromCapsOrClear(caps);

          const tokens = tokenizeNanpaCaps(caps);
          const tpWords = nanpaCapsTokensToTpWords(tokens, { mode: getCartoucheDisplayMode() });
          const cps = tpWordsToUcsurCodepoints(tpWords);

          const prettyNameRaw = splitCartoucheCapsLettersSpaced(caps);
          const prettyNameDisplay = titleCaseNanpaProperNameForDisplay(prettyNameRaw);

          elLatinOut.value = fixOkenSuffixSpacing(prettyNameDisplay);

          elNumberCodeOut.value = canonicalCode;

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
          if (elTpWordsOut) elTpWordsOut.value = tpWords.join(" ");

          const smallSet = getSmallCodepointsSet();
          const quarterSet = getQuarterCodepointsSet();
          const halfSet = getHalfCodepointsSet();
          const twoThirdsSet = getTwoThirdsCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            quarterSet,
  halfSet,
  twoThirdsSet,
            SMALL_CANVAS_RENDER_OPTS
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            quarterSet,
  halfSet,
  twoThirdsSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Rendered from nanpa-linja-n number code.");
          return;
        }

        const parsedTpPhrase = tryParseNanpaLinjanTpPhraseToCaps(rawInput);
        if (parsedTpPhrase) {
          const { caps, words } = parsedTpPhrase;

          setDecimalValueFromCapsOrClear(caps);

          const cps = parseTpWordsToCodepoints(words.join(" "));

          const prettyNameRaw = splitCartoucheCapsLettersSpaced(caps);
          const prettyNameDisplay = titleCaseNanpaProperNameForDisplay(prettyNameRaw);

         elLatinOut.value = fixOkenSuffixSpacing(prettyNameDisplay);

          elNumberCodeOut.value = latinNameToNumberCode(prettyNameRaw);

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
          if (elTpWordsOut) elTpWordsOut.value = words.join(" ");

          const smallSet = getSmallCodepointsSet();
          const quarterSet = getQuarterCodepointsSet();
          const halfSet = getHalfCodepointsSet();
          const twoThirdsSet = getTwoThirdsCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
           quarterSet,
  halfSet,
  twoThirdsSet,
            SMALL_CANVAS_RENDER_OPTS
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            quarterSet,
  halfSet,
  twoThirdsSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Recognized and rendered nanpa-linja-n TP-phrase number.");
          return;
        }

        if (isValidNanpaLinjanProperName(rawInput)) {
          const cps = nanpaLinjanProperNameToUcsurCodepoints(rawInput);

          const compact = rawInput.toLowerCase().replace(/\s+/g, "");
          const core = compact.slice(0, -1);
          const caps = core.toUpperCase() + "N";

          setDecimalValueFromCapsOrClear(caps);

          const prettyNameRaw = splitCartoucheCapsLettersSpaced(caps);
          const prettyNameDisplay = titleCaseNanpaProperNameForDisplay(prettyNameRaw);

          elLatinOut.value = fixOkenSuffixSpacing(prettyNameDisplay);

          elNumberCodeOut.value = latinNameToNumberCode(prettyNameRaw);

          if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
          if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

          const smallSet = getSmallCodepointsSet();
          const quarterSet = getQuarterCodepointsSet();
          const halfSet = getHalfCodepointsSet();
          const twoThirdsSet = getTwoThirdsCodepointsSet();

          renderMixedCartoucheToCanvas(
            canvasSmall,
            cps,
            LARGE_TINY_FONT_SIZE,
            SMALL_TINY_FONT_SIZE,
            quarterSet,
  halfSet,
  twoThirdsSet,
            SMALL_CANVAS_RENDER_OPTS
          );

          renderMixedCartoucheToCanvas(
            canvasLarge,
            cps,
            LARGE_FONT_SIZE,
            SMALL_FONT_SIZE,
            quarterSet,
  halfSet,
  twoThirdsSet,
            { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
          );

          announceStatus("Rendered from nanpa-linja-n proper name.");
          return;
        }

        const cps = parseTpWordsToCodepoints(elTpWordsIn.value);

        if (elCodepointsOut) elCodepointsOut.value = codepointsToHexStringWithCartouche(cps);
        if (elTpWordsOut) elTpWordsOut.value = tpWordsToText(ucsurCodepointsToTpWords(cps));

        elLatinOut.value = String.fromCodePoint(...cps);
        elNumberCodeOut.value = latinNameToNumberCode(elLatinOut.value);

        const quarterSet = getQuarterCodepointsSet();
        const halfSet = getHalfCodepointsSet();
        const twoThirdsSet = getTwoThirdsCodepointsSet();

        renderUniformCartoucheFromCodepoints(
          canvasSmall,
          cps,
          LARGE_TINY_FONT_SIZE,
          quarterSet,
  halfSet,
  twoThirdsSet,
          SMALL_CANVAS_RENDER_OPTS
        );

        renderUniformCartoucheFromCodepoints(
          canvasLarge,
          cps,
          LARGE_FONT_SIZE,
          quarterSet,
  halfSet,
  twoThirdsSet,
          { padding: 22, border: 3, cornerRadius: 18, letterGap: LETTER_SPACING_GAP }
        );

        setDecimalValueLine(null, null);

        announceStatus("Rendered from Toki Pona words.");
      } catch (err) {
        setDecimalValueLine(null, null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    }

    document.getElementById("btnFromWords").addEventListener("click", () => {
      handleFromWordsClick({ clearOthers: true });
    });

    function validateTpWordsInputLive() {
      if (suppressInputHandlers) return; // NEW: ignore programmatic clears
      const raw = String(elTpWordsIn?.value ?? "").trim();
      if (!raw) { elTpWordsIn.setCustomValidity(""); return; }

      try {
        const parsedCode = tryParseNanpaLinjanNumberCodeToCaps(raw);
        if (parsedCode) {
          elTpWordsIn.setCustomValidity("");
          return;
        }
      } catch (e) {
        if (String(raw).trim().toUpperCase().startsWith("#~")) {
          elTpWordsIn.setCustomValidity(e?.message ?? "Invalid number code.");
          return;
        }
      }

      if (isValidNanpaLinjanProperName(raw)) {
        elTpWordsIn.setCustomValidity("");
        return;
      }

      // Accept valid mapped words (including en)
      const parts = raw.split(/\s+/).filter(Boolean);
      for (const p of parts) {
        if (WORD_TO_UCSUR_CP[p.toLowerCase()] == null) {
          elTpWordsIn.setCustomValidity(`Invalid word: ${p}`);
          return;
        }
      }
      elTpWordsIn.setCustomValidity("");
    }

    if (elTpWordsIn) elTpWordsIn.addEventListener("input", validateTpWordsInputLive);

    if (elDecimal) {
      elDecimal.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          document.getElementById("btnEncode").click();
        }
      });
    }

    // NEW: Press Enter in TP-words input to trigger "Render From Toki Pona Words"
    if (elTpWordsIn) {
      elTpWordsIn.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          document.getElementById("btnFromWords").click();
        }
      });
    }

    // OPTIONAL (recommended): Press Enter in codepoints input to trigger "Render From Code Points"
    if (elCodesIn) {
      elCodesIn.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          document.getElementById("btnFromCodes")?.click();
        }
      });
    }

    window.addEventListener("load", async () => {
      try {
        await ensureFontLoaded();

        applyCartoucheDisplayModeFromQueryOrStorage();
        updateCalculatorLinkWithDisplayParam();
        updateTextToSitelenLinkWithDisplayParam();

        wireCartoucheDisplayRadios();

        wireDownloadButton(); // <-- ADD THIS

        buildDigitReferenceTable();
        await runEncodeFromDecimal();
      } catch (err) {
        setDecimalValueLine(null, null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

  </script>
</body>
</html>
