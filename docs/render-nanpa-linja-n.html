<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>nanpa-linja-n — Font Cartouche Number Renderer</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;
      --muted: #3f4750;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .row { display: flex; gap: var(--gap); flex-wrap: wrap; align-items: flex-end; }
    .col { flex: 1 1 320px; }

    label { display: block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }

    input[type="text"], textarea {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg);
      font: inherit;
    }

    textarea { min-height: 84px; resize: vertical; }

    button {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }

    button:hover { background: var(--bg); }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    .tpLine {
      display: block;
      margin-top: 2px;
      font-size: 10pt;
      color: var(--muted);
      line-height: 1.25;
    }

    .out { margin-top: 12px; }
    .out h3 { margin: 18px 0 8px; font-size: 14px; }

    canvas {
      display: block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: var(--bg);
      max-width: 100%;
    }

    .grid2 {
      display: grid;
      grid-template-columns: 1fr;
      gap: 14px;
    }

    .hidden { display: none !important; }

    /* Strong focus indicators */
    button:focus-visible,
    a:focus-visible,
    input:focus-visible,
    textarea:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    /* Skip link (keyboard navigation) */
    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    /* Visually hidden but still accessible to screen readers */
    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: -1px !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    @font-face {
      font-family: "TP-Nanpa-LinjaN-Font";
      src: url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v4.otf") format("opentype");
      font-display: swap;
    }
  </style>
</head>

<body>
  <a href="#main" class="skipLink">
    Skip to content
    <span class="tpLine">o tawa lipu ni</span>
  </a>

  <main class="card" id="main" role="main" aria-labelledby="pageTitle">
    <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
      nanpa-linja-n — Font cartouche number renderer (no manual border)
      <span class="tpLine">ilo sitelen pi poki nimi (kepeken font taso)</span>
    </h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> The “nanpa-linja-n proper name” shown here is an encoding label for numbers only.
      It is intended as a proper-name style identifier and does not propose or add any new Toki Pona lexicon.
      <span class="tpLine">
        sona: nimi “nanpa-linja-n proper name” li nimi pi pana nanpa taso.
        ona li sama nimi pi jan (nimi pi nimi) taso; ona li pana ala e nimi sin pi toki pona.
      </span>
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <span class="tpLine">
        sona: ilo ni li lon nasin “as is”. mi pana ala e wawa pi pona.
        sina o lukin e ni: sitelen li pona anu seme.
      </span>
    </div>

    <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <div class="out" role="region" aria-label="Cartouche renderings">
      <div class="grid2" style="margin-top:14px;" role="group" aria-label="Cartouche renderings">
        <div>
          <h3>
            cartouche (small)
            <span class="tpLine">poki nimi (lili)</span>
          </h3>
          <canvas id="canvasSmall" aria-hidden="true"></canvas>
          <div class="help">
            Small font size render (font draws the cartouche).
            <span class="tpLine">sitelen li lili; font li sitelen e poki nimi.</span>
          </div>
        </div>
        <div>
          <h3>
            cartouche (large)
            <span class="tpLine">poki nimi (suli)</span>
          </h3>
          <canvas id="canvasLarge" aria-hidden="true"></canvas>

          <div id="decimalValueLine" class="help hidden">
            <strong>Value:</strong> <span id="decimalValueText" class="mono"></span>
          </div>

          <div class="help">
            Large font size render (font draws the cartouche).
            <span class="tpLine">sitelen li suli; font li sitelen e poki nimi.</span>
          </div>
        </div>
      </div>
    </div>

    <div class="row" style="margin-top:14px;" role="group" aria-label="Decimal input and render action">
      <div class="col">
        <label for="decimalInput">
          Enter decimal value (treated as text)
          <span class="tpLine">o pana e nanpa poka (sitelen taso)</span>
        </label>
        <input
          id="decimalInput"
          type="text"
          class="mono"
          value="28.95"
          maxlength="500"
          inputmode="text"
          aria-describedby="decimalHelp"
          aria-controls="latinOut tpWordsOut codepointsOut codepointsWrappedOut canvasSmall canvasLarge"
        />
        <div id="decimalHelp" class="help">
          Example formats: <span class="mono">0.00</span>; <span class="mono">.75</span>; <span class="mono">-12,340</span>; <span class="mono">9¾</span>; <span class="mono">8+1/2</span>; <span class="mono">7/8</span>; <span class="mono">64.5M</span>.
          <span class="tpLine">ilo nanpa-linja-n li alasa e nasin sitelen tan sitelen nanpa ni.</span>
        </div>
      </div>

      <div style="flex: 0 0 auto;">
        <button id="btnEncode" type="button" aria-describedby="btnEncodeHelp">
          Render
        </button>
        <div id="btnEncodeHelp" class="sr-only">
          Encodes the input into nanpa-linja-n UCSUR words, wraps with cartouche start/end, and renders using the font.
        </div>
      </div>
    </div>

    <div class="out" role="region" aria-label="Outputs">
      <h3>
        nanpa-linja-n proper name (Latin, spaced)
        <span class="tpLine">nimi pi pana nanpa (sitelen Lasina, kepeken spasi)</span>
      </h3>
      <textarea id="latinOut" class="mono" readonly aria-readonly="true"></textarea>
      <div class="help">
        Human-readable Latin rendering of the nanpa-caps stream.
        <span class="tpLine">ni li sitelen Lasina pi toki nanpa; spasi li pona lukin taso.</span>
      </div>

      <h3>
        Toki Pona words (for inner UCSUR code points)
        <span class="tpLine">nimi pi toki pona (tan nanpa sitelen insa)</span>
      </h3>
      <textarea id="tpWordsOut" class="mono" readonly aria-readonly="true"></textarea>

      <h3>
        Inner code points (hex) — no cartouche wrapper
        <span class="tpLine">nanpa sitelen insa (hex) — poki nimi ala</span>
      </h3>
      <textarea id="codepointsOut" class="mono" readonly aria-readonly="true"></textarea>

      <h3>
        Wrapped code points (hex) — START + inner + END
        <span class="tpLine">nanpa sitelen (hex) — open poki nimi + insa + pini poki nimi</span>
      </h3>
      <textarea id="codepointsWrappedOut" class="mono" readonly aria-readonly="true"></textarea>

      <div class="help">
        Wrapped form is: <span class="mono">F1990</span> + (inner UCSUR sequence) + <span class="mono">F1991</span>.
        <span class="tpLine">poki nimi li lon nasin: <span class="mono">F1990</span> + (insa) + <span class="mono">F1991</span>.</span>
      </div>
    </div>
  </main>

  <script>
    "use strict";

    /* ============================================================
       Accessibility helpers
       ============================================================ */

    const elSrStatus = document.getElementById("srStatus");

    function announceStatus(msg) {
      if (!elSrStatus) return;
      elSrStatus.textContent = String(msg ?? "");
    }

    function showAlertAndAnnounce(msg) {
      const s = String(msg ?? "Unknown error");
      announceStatus(s);
      alert(s);
    }

    /* ============================================================
       Vulgar fraction input support (e.g., 9¾, ¾, ⅜, etc.)
       ============================================================ */

    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]],
    ]);

    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      // normalize fraction slash
      s = s.replace(/\u2044/g, "/");

      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return s;

      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
      }
      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      if (!prefixRaw) return `${num}/${den}`;

      const isNeg = prefixRaw.startsWith("-");
      const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

      if (!prefix) return `-${num}/${den}`;

      const normalized = isNeg ? `-${prefix}+${num}/${den}` : `${prefix}+${num}/${den}`;
      if (normalized.slice(1).includes("-")) {
        throw new Error("Normalization produced an invalid negative sign placement.");
      }
      return normalized;
    }

    /* ============================================================
       nanpa-linja-n algorithm core (encoding)
       ============================================================ */

    const DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    const TOKEN_TO_DIGIT_WORD = {
      "NI": "ijo", "WE": "wan", "TE": "tu", "SE": "seli", "NA": "awen",
      "LE": "luka", "NU": "utala", "ME": "mun", "PE": "pipi", "JE": "jo",
    };

    const OPCHAR_TO_TOKEN = { ".": "NONE", "-": "NO", "/": "NONO", "+": "NONONO" };
    const DIGIT_TOKENS = new Set(Object.keys(TOKEN_TO_DIGIT_WORD));
    const TOKEN_PREFIXES = [ "KEKEKE", "KEKE", "KE", "NONONO", "NONO", "NE", "NO" ];

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar=",") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      const groupedFrac = groups.join(sepChar);
      return `${left}${decimalChar}${groupedFrac}${suffix}`;
    }

    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");
      return (head + r).trim();
    }

    function numberStrToNanpaCaps(
      s,
      { thousandsChar = ",", groupFractionTriplets = false, fractionGroupSize = 3 } = {}
    ) {
      if (s == null) throw new Error("s must be a string, not null");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, thousandsChar);
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          if (out.length > 0 && out[out.length - 1] === "NENE") return;
          out.push("NENE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount = (last === "T") ? 1 : (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NEKE");
            for (const d of groups[idx]) out.push(DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            for (let i = 0; i < trailingZeroGroups; i++) out.push("KE");
          }
        }

        if (hasDecimal) {
          out.push(OPCHAR_TO_TOKEN["."]);
          for (const ch of fracPart) {
            if (ch === "_" ) continue;
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { pushNene(); continue; }
            if (/\d/.test(ch)) { out.push(DIGIT_TO_TOKEN[ch]); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          for (let i = 0; i < magnitudeSuffixKeCount; i++) out.push("KE");
        }

        out.push("N");
        return out.join("");
      }

      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
      }

      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);
        return numCaps + "NONO" + denCaps;
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const n = s.length;

      while (i < n - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= n - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function splitCartoucheCapsLettersSpaced(caps) {
      if (caps == null) throw new Error("caps must be a string, not None");
      const s0 = String(caps).trim().toUpperCase();
      if (!s0) return "";
      if (s0.length < 3 || !s0.startsWith("NE") || !s0.endsWith("N")) {
        throw new Error(`Not a valid nanpa-caps label: "${caps}"`);
      }

      const parts = [];
      let current = "";
      let i = 0;
      const end = s0.length - 1;

      function flushCurrent() {
        if (current) { parts.push(current); current = ""; }
      }

      function attachDelimiterN() {
        if (current) { current += "n"; flushCurrent(); return; }
        if (parts.length === 0) { parts.push("n"); return; }
        parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";
      }

      while (i < end) {
        if (i + 2 > end) throw new Error(`Malformed caps at position ${i} in "${caps}"`);

        const pair = s0.slice(i, i + 2);
        const nextPair = (i + 4 <= end) ? s0.slice(i + 2, i + 4) : null;

        if (pair === "NE" && nextPair === "NO" && i === 0) { flushCurrent(); parts.push("neno"); i += 4; continue; }
        if (pair === "NE" && nextPair === "NE") { flushCurrent(); attachDelimiterN(); parts.push("ene"); i += 4; continue; }
        if (pair === "NO" && nextPair === "NE" && i > 0) { flushCurrent(); attachDelimiterN(); parts.push("one"); i += 4; continue; }

        if (pair === "NO" && nextPair === "NO" && i > 0) {
          flushCurrent();
          let countNo = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "NO") { countNo += 1; j += 2; }
          attachDelimiterN();
          parts.push("o" + "no".repeat(countNo));
          i += 2 + 2 * countNo;
          continue;
        }

        if (pair === "NE" && nextPair === "KE") {
          flushCurrent();
          let countKe = 1;
          let j = i;
          while ((j + 6) <= end && s0.slice(j + 4, j + 6) === "KE") { countKe += 1; j += 2; }
          attachDelimiterN();
          parts.push("e" + "ke".repeat(countKe));
          i += 2 + 2 * countKe;
          continue;
        }

        current += pair.toLowerCase();
        i += 2;
      }

      flushCurrent();

      if (parts.length === 0) return "n";
      parts[parts.length - 1] = String(parts[parts.length - 1]) + "n";

      return parts.join(" ").replace(/\s+/g, " ").trim();
    }

    function nanpaCapsTokensToTpWords(tokens) {
      if (!tokens || tokens.length === 0) return [];

      const out = [];

      const E_WORD = "esun";
      const E_WORD_FOR_NE_AFTER_START = "e";
      const N_WORD = "nasa";
      const N_WORD_DECIMAL_POINT = "ni";
      const N_WORD_FRACTION = "nena";
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) { out.push("nanpa", E_WORD); afterStartingNe = true; }
          else { out.push(N_WORD, E_WORD_FOR_NE_AFTER_START); afterStartingNe = false; }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD);
          continue;
        }

        if (t === "NO") {
          if (afterStartingNe) {
            out.push(N_WORD, "o");
            afterStartingNe = false;
          } else {
            let nWordToUse = N_WORD_DECIMAL_POINT;
            const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
            const prev = (i - 1 > 0) ? tokens[i - 1] : null;
            if (prev === "NO" || nxt === "NO") nWordToUse = N_WORD_FRACTION;
            out.push(nWordToUse, "o");
            afterStartingNe = false;
          }
          continue;
        }

        if (t === "NONO") { out.push("nena","o","nena","o"); afterStartingNe=false; continue; }
        if (t === "NONONO") { out.push("nasa","o","nasa","o","nasa","o"); afterStartingNe=false; continue; }

        if (t === "KE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }

    /* ============================================================
       Minimal TP UCSUR map (only what the encoder emits)
       ============================================================ */

    const WORD_TO_UCSUR_CP = {
      "nanpa": 0xF193D,
      "esun":  0xF190B,
      "e":     0xF1909,
      "nasa":  0xF193E,
      "ni":    0xF1941,
      "nena":  0xF1940,
      "o":     0xF1944,
      "kulupu":0xF191F,

      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "sijelo":0xF195B,
      "ante":  0xF1906,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913,

      "awen":  0xF1908,
       "seli": 0xF1957,
    };

    const TP_UCSUR_MIN = 0xF1900;
    const TP_UCSUR_MAX = 0xF1988;

    function isAllowedTpUcsurCodepoint(cp) {
      return Number.isInteger(cp) && cp >= TP_UCSUR_MIN && cp <= TP_UCSUR_MAX;
    }

    function assertAllAllowedTpUcsur(codepoints) {
      for (const cp of codepoints) {
        if (!isAllowedTpUcsurCodepoint(cp)) {
          const hex = cp.toString(16).toUpperCase();
          throw new Error(
            `Disallowed code point U+${hex}. Allowed range is U+${TP_UCSUR_MIN.toString(16).toUpperCase()}..U+${TP_UCSUR_MAX.toString(16).toUpperCase()}.`
          );
        }
      }
    }

    function tpWordsToUcsurCodepoints(words) {
      const cps = [];
      for (const w of (words ?? [])) {
        const key = String(w).toLowerCase();
        const cp = WORD_TO_UCSUR_CP[key];
        if (cp == null) throw new Error(`No UCSUR code point for word "${w}"`);
        cps.push(cp);
      }
      assertAllAllowedTpUcsur(cps);
      return cps;
    }

    function tpWordsToText(words) {
      return (words ?? []).join(" ");
    }

    function codepointsToHexString(codepoints) {
      return (codepoints ?? []).map(cp => cp.toString(16).toUpperCase().padStart(4, "0")).join(" ");
    }

    function decimalToUcsurCodepoints(decimalStr) {
      const s = normalizeVulgarFractionInput(String(decimalStr ?? "").trim());
      if (!s) return [];

      const caps = looksLikeNanpaCaps(s)
        ? s.toUpperCase()
        : numberStrToNanpaCaps(s, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });

      const tokens = tokenizeNanpaCaps(caps);
      const tpWords = nanpaCapsTokensToTpWords(tokens);
      const cps = tpWordsToUcsurCodepoints(tpWords);

      assertAllAllowedTpUcsur(cps);
      return { caps, tokens, tpWords, cps };
    }

    /* ============================================================
       Font-cartouche rendering (wrap with START/END code points)
       ============================================================ */

    const FONT_FAMILY = "TP-Nanpa-LinjaN-Font";

    // Font-drawn cartouche wrapper code points
    const CP_CARTOUCHE_START = 0xF1990;
    const CP_CARTOUCHE_END   = 0xF1991;

    async function ensureFontLoaded() {
      // Use CSS Font Loading API when available
      if (!document.fonts || !document.fonts.load) return;

      // Sample: use a UCSUR TP char to force load
      const sampleChar = String.fromCodePoint(0xF193D);
      const fontSpec = `32px "${FONT_FAMILY}"`;
      await document.fonts.load(fontSpec, sampleChar);
      await document.fonts.ready;
    }

    function renderFontCartoucheToCanvas(canvas, innerCodepoints, fontPx, options = {}) {
      const pad = options.padding ?? 18;

      const wrapped = [CP_CARTOUCHE_START, ...(innerCodepoints ?? []), CP_CARTOUCHE_END];
      const s = String.fromCodePoint(...wrapped);

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";
      ctx.font = `${fontPx}px "${FONT_FAMILY}"`;

      const m = ctx.measureText(s);
      const ascent  = m.actualBoundingBoxAscent  ?? Math.ceil(fontPx * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(fontPx * 0.2);
      const left    = m.actualBoundingBoxLeft    ?? 0;
      const right   = m.actualBoundingBoxRight   ?? Math.ceil(m.width);

      const textW = Math.ceil(left + right);
      const textH = Math.ceil(ascent + descent);

      canvas.width  = textW + pad * 2;
      canvas.height = textH + pad * 2;

      const ctx2 = canvas.getContext("2d");
      ctx2.textBaseline = "alphabetic";
      ctx2.clearRect(0, 0, canvas.width, canvas.height);

      ctx2.font = `${fontPx}px "${FONT_FAMILY}"`;
      ctx2.fillStyle = "#111";

      // include left bearing so glyphs do not clip
      ctx2.fillText(s, pad + left, pad + ascent);

      return { wrappedCodepoints: wrapped, wrappedString: s };
    }

    /* ============================================================
       UI wiring
       ============================================================ */

    const LARGE_FONT_SIZE = 96;
    const SMALL_FONT_SIZE = 48;

    const elDecimal = document.getElementById("decimalInput");
    const elLatinOut = document.getElementById("latinOut");
    const elTpWordsOut = document.getElementById("tpWordsOut");
    const elCodepointsOut = document.getElementById("codepointsOut");
    const elCodepointsWrappedOut = document.getElementById("codepointsWrappedOut");

    const canvasLarge = document.getElementById("canvasLarge");
    const canvasSmall = document.getElementById("canvasSmall");

    const elDecimalValueLine = document.getElementById("decimalValueLine");
    const elDecimalValueText = document.getElementById("decimalValueText");

    function setDecimalValueLine(valueOrNull) {
      if (!elDecimalValueLine || !elDecimalValueText) return;

      const s = (valueOrNull == null) ? "" : String(valueOrNull).trim();
      if (!s) {
        elDecimalValueText.textContent = "";
        elDecimalValueLine.classList.add("hidden");
        return;
      }

      elDecimalValueText.textContent = s;
      elDecimalValueLine.classList.remove("hidden");
    }

    function enforceMaxLen(el, maxLen = 500) {
      if (!el) return;
      const s = String(el.value ?? "");
      if (s.length > maxLen) el.value = s.slice(0, maxLen);
    }

    async function runEncodeAndRender() {
      await ensureFontLoaded();
      enforceMaxLen(elDecimal, 500);

      const raw = normalizeVulgarFractionInput(elDecimal.value);
      const { caps, tpWords, cps } = decimalToUcsurCodepoints(raw);

      // Outputs
      elLatinOut.value = splitCartoucheCapsLettersSpaced(caps);
      elTpWordsOut.value = tpWordsToText(tpWords);
      elCodepointsOut.value = codepointsToHexString(cps);

      // Render (font draws cartouche; we just wrap start/end)
      const small = renderFontCartoucheToCanvas(canvasSmall, cps, SMALL_FONT_SIZE, { padding: 12 });
      const large = renderFontCartoucheToCanvas(canvasLarge, cps, LARGE_FONT_SIZE, { padding: 18 });

      elCodepointsWrappedOut.value = codepointsToHexString(large.wrappedCodepoints);

      // Value line shows normalized raw (text-preserving input); you can swap to caps-derived if you prefer
      setDecimalValueLine(String(raw ?? "").trim() || null);

      announceStatus(`Rendered value ${raw}.`);
    }

    document.getElementById("btnEncode").addEventListener("click", async () => {
      try {
        await runEncodeAndRender();
      } catch (err) {
        setDecimalValueLine(null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });

    // Keyboard support: Enter triggers render when focused in decimal input
    if (elDecimal) {
      elDecimal.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && !e.altKey && !e.ctrlKey && !e.metaKey) {
          e.preventDefault();
          document.getElementById("btnEncode").click();
        }
      });
      elDecimal.addEventListener("input", () => enforceMaxLen(elDecimal, 500));
    }

    window.addEventListener("load", async () => {
      try {
        await runEncodeAndRender();
      } catch (err) {
        setDecimalValueLine(null);
        showAlertAndAnnounce(err?.message ?? String(err));
      }
    });
  </script>
</body>
</html>
