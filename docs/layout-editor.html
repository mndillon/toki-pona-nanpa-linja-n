<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Static Canvas Layout Editor (no dependencies)</title>

  <style>
  :root{
    --topbar-h: 56px;

    /* Style inspired by your example */
    --bg: #F3DFC0;
    --ink: #111;
    --muted: #3f4750;
    --panel: rgba(255,255,255,0.35);
    --panel-strong: rgba(255,255,255,0.55);
    --panel-border: rgba(17,17,17,0.18);

    --radius: 14px;
    --btn-radius: 10px;
    --shadow: 0 12px 30px rgba(0,0,0,0.12);

    /* Stage defaults */
    --stage-maxw: 1180px;
    --stage-pad: 14px;
    --grid-size: 20px;
  }

  /* CHANGE HERE: provide your fonts (optional) */
  @font-face {
    font-family: "PatrickHand";
    src: url("./fonts/PatrickHand-Regular.ttf") format("truetype");
    font-display: swap;
  }
  @font-face {
    font-family: "TP-Cartouche-Font";
    src: url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v5.otf") format("opentype");
    font-display: swap;
  }
  @font-face {
    font-family: "TP-Nasin-Nanpa-Font";
    src: url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-v5.otf") format("opentype");
    font-display: swap;
  }

  html, body{
    height:100%;
    margin:0;
    background: var(--bg);
    color: var(--ink);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }

  /* ============================================================
     CHANGE HERE: Top bar becomes multi-row and holds tool buttons
     - tools spread across available width with wrapping
     ============================================================ */
  .topbar{
    min-height: var(--topbar-h);
    display:flex;
    flex-direction: column;          /* NEW */
    align-items: stretch;            /* NEW */
    gap: 8px;                        /* NEW */
    padding: 10px 12px;
    box-sizing:border-box;
    border-bottom: 1px solid var(--panel-border);
    background: var(--panel);
    backdrop-filter: blur(6px);
    position: sticky;
    top: 0;
    z-index: 20;
  }

  /* NEW: topbar rows for actions + tools */
  .topbarRow{
    display:flex;
    align-items:center;
    gap: 8px;
    flex-wrap: wrap;                 /* KEY: spread out across width */
  }

  /* NEW: group within topbar (optional divider) */
  .topbarGroup{
    display:flex;
    align-items:center;
    gap: 8px;
    flex-wrap: wrap;
    padding-right: 8px;
    margin-right: 8px;
    border-right: 1px solid rgba(17,17,17,0.12);
  }
  .topbarGroup:last-child{
    border-right: none;
    padding-right: 0;
    margin-right: 0;
  }

  .btn{
    appearance:none;
    border: 1px solid var(--panel-border);
    background: rgba(255,255,255,0.5);
    padding: 8px 10px;
    border-radius: var(--btn-radius);
    cursor:pointer;
    font-weight: 700;
    color: var(--ink);
    font-family: inherit;
    font-size: 16px;
    user-select:none;
    -webkit-user-select:none;
    white-space: nowrap;            /* NEW: prevent awkward wrapping inside a button */
  }
  .btn:disabled{ opacity:0.55; cursor:not-allowed; }
  .btn.primary{ background: rgba(255,255,255,0.72); border-color: rgba(17,17,17,0.32); }


  /* Toggle button pressed state (uses aria-pressed you already have) */
.btn[aria-pressed="true"]{
  background: rgba(17,17,17,0.14);
  border-color: rgba(17,17,17,0.38);
  box-shadow: inset 0 0 0 2px rgba(17,17,17,0.16);
  opacity: 1;
}

.btn[aria-pressed="false"]{
  opacity: 0.78;
}

.btn:focus-visible{
  outline: 2px solid rgba(17,17,17,0.45);
  outline-offset: 2px;
}

  .toolBtnSmall{
  padding: 6px 10px;
  font-size: 12px;
  border-radius: 10px;
  line-height: 1;
}

.toolBtn[disabled]{
  opacity: 0.45;
  cursor: not-allowed;
}


  /* CHANGE HERE: chip no longer forces itself to the far right of a single-line bar */
  .chip{
    color: var(--muted);
    font-size: 14px;
    white-space: nowrap;
    overflow:hidden;
    text-overflow: ellipsis;
    max-width: 54vw;
    margin-left: 0;                 /* NEW */
  }
  /* NEW: right-align helper if you want chip on far right of the actions row */
  .spacer{ flex: 1 1 auto; }

  /* ============================================================
     Main layout (wrap) must account for a variable-height topbar
     ============================================================ */
  .wrap{
    /* CHANGED: topbar height is no longer fixed, so do not subtract var(--topbar-h) */
    height: calc(100% - 0px);
    min-height: 0;
    display:grid;
    grid-template-columns: 320px 1fr;
    gap: 12px;
    padding: 12px;
    box-sizing: border-box;
     /* CHANGE HERE: remove centering/width cap */
  max-width: none;
    margin: 0; 
  }

  .panel{
    border: 1px solid var(--panel-border);
    background: var(--panel);
    border-radius: var(--radius);
    box-shadow: var(--shadow);
    overflow: hidden;
    min-height: 0;
  }

  .panelHeader{
   padding: 8px 10px; /* was 10px 12px */

    border-bottom: 1px solid var(--panel-border);
    background: rgba(255,255,255,0.20);
    display:flex;
    align-items:center;
    justify-content: space-between;
    gap: 10px;
    user-select:none;
    -webkit-user-select:none;
  }
  .panelHeader h2{
    margin:0;
    font-size: 18px;
  }

  /* Font-size input + preset dropdown on one line */
.propInlineRow{
  display:flex;
  align-items:center;
  gap:10px;
}

.propInlineRow > input[type="number"]{
  flex: 1 1 auto;
  min-width: 0;
}

/* CHANGE HERE: make the preset dropdown narrower */
.propInlineRow > select{
  flex: 0 0 88px;     /* was 120px */
  width: 88px;        /* keep deterministic */
  min-width: 88px;
  max-width: 88px;
  padding: 6px 8px;   /* optional: tighter */
}


  .sidebar{
    display:flex;
    flex-direction:column;
    min-height:0;
  }

  .sidebarBody{
    padding: 12px;
    display:flex;
    flex-direction:column;
    gap: 12px;
    overflow:auto;
    min-height:0;
  }

  /* ============================================================
     CHANGE HERE: tool buttons are now in the topbar, but we keep
     their styling for reuse. Make them more compact for topbar.
     ============================================================ */
  .toolGrid{
    display:grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .toolBtn{
    appearance:none;
    border: 1px solid rgba(17,17,17,0.22);
    background: rgba(255,255,255,0.38);
    padding: 7px 10px;              /* CHANGED: slightly more topbar-friendly */
    border-radius: 12px;
    cursor:pointer;
    font-weight: 800;
    font-size: 14px;
    color: var(--ink);
    user-select:none;
    -webkit-user-select:none;
    white-space: nowrap;            /* NEW: keep tool labels tidy */
  }
  .toolBtn[aria-pressed="true"]{
    background: rgba(255,255,255,0.76);
    border-color: rgba(17,17,17,0.42);
    box-shadow: 0 10px 22px rgba(0,0,0,0.10);
  }

  /* NEW: topbar-specific tool row layout */
  .toolRow{
    display:flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .row{
    display:flex;
    gap: 8px;
    align-items:center;
    flex-wrap: wrap;
  }
  .row > * { flex: 1 1 auto; }

  /* NEW: inline checkbox label used in Stage panel */
.checkInline{
  display:flex;
  align-items:center;
  gap: 6px;
  font-size: 13px;
  color: var(--muted);
  user-select:none;
  -webkit-user-select:none;
  white-space: nowrap;
}
.checkInline input{
  width: 16px;
  height: 16px;
}

  /* Header button row: do NOT use .row here (because .row > * forces flex:1) */
.hdrBtnRow{
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 6px;
  flex-wrap: wrap;
}
.hdrBtnRow > .btn{
  flex: 0 0 auto;     /* critical: buttons keep natural size */
}

/* Only this mini Stage panel should not clip its header contents */
.stageMiniPanel{
  overflow: hidden;  /* overrides .panel { overflow:hidden } */
}

.stageMiniPanel .panelHeader{
  padding-top: 10px;
  padding-bottom: 10px;
}

/* Stage mini panel: header fixed, body scrolls */
.stageMiniPanel{
  display: flex;
  flex-direction: column;
  overflow: hidden;     /* clips within rounded corners */
  min-height: 0;        /* critical for nested flex scrolling */
}

/* The content area inside Stage panel should scroll if too tall */
.stageMiniBody{
  padding: 12px;
  overflow: auto;       /* enables scrolling */
  min-height: 0;        /* critical */
  -webkit-overflow-scrolling: touch;
}

.stageMiniBody{
  max-height: 580px; /* adjust to taste */
}

  .field{
    display:flex;
    flex-direction:column;
    gap: 4px;
  }
  .field label{
    font-size: 13px;
    color: var(--muted);
    user-select:none;
    -webkit-user-select:none;
  }
  .field input[type="number"],
  .field input[type="text"],
  .field select,
  .field textarea{
    border: 1px solid rgba(17,17,17,0.20);
    background: rgba(255,255,255,0.65);
    border-radius: 12px;
    padding: 8px 10px;
    font-family: inherit;
    font-size: 14px;
    color: var(--ink);
    outline: none;
    box-sizing: border-box;
    width: 100%;
  }
  .field textarea{
    min-height: 90px;
    resize: vertical;
  }
  .field input[type="color"]{
    width: 100%;
    height: 40px;
    border-radius: 12px;
    border: 1px solid rgba(17,17,17,0.20);
    background: rgba(255,255,255,0.65);
    padding: 4px;
    box-sizing: border-box;
    cursor:pointer;
  }

  .hint{
    border: 1px solid var(--panel-border);
    background: rgba(255,255,255,0.35);
    border-radius: var(--radius);
    padding: 10px 12px;
    color: var(--muted);
    font-size: 14px;
    line-height: 1.25;
    user-select:none;
    -webkit-user-select:none;
  }

  .stagePanel{
    position: relative;
    min-height:0;
    display:flex;
    flex-direction:column;
  }
.stageBody{
  position: relative;
  flex: 1 1 auto;
  min-height:0;

  /* CHANGE HERE: reduce padding and remove vertical centering */
  padding: 8px;                 /* was var(--stage-pad) */
  box-sizing: border-box;
  display:flex;
  align-items: stretch;
  justify-content: stretch;
}


  .canvasWrap{
    position: relative;

     /* CHANGE HERE: stage uses full available width */
  width: 100%;
max-width: var(--stage-maxw); /* optional */

      /* CHANGE HERE: fill remaining height of stageBody */
  height: 100%;

    border-radius: 18px;
    border: 2px solid rgba(17,17,17,0.22);
    background: rgba(255,255,255,0.18);
    box-shadow: 0 14px 34px rgba(0,0,0,0.12);
    overflow:hidden;
    touch-action: none; /* critical for pointer events */
  }

  canvas{
    display:block;
    width: 100%;
    height: 100%;
  }

  .overlayHud{
    position:absolute;
    left: 10px;
    bottom: 10px;
    background: rgba(255,255,255,0.60);
    border: 1px solid rgba(17,17,17,0.18);
    border-radius: 12px;
    padding: 8px 10px;
    font-size: 13px;
    color: var(--muted);
    user-select:none;
    -webkit-user-select:none;
    pointer-events:none;
    max-width: 90%;
    overflow:hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .footer{
    padding: 10px 12px;
    border-top: 1px solid var(--panel-border);
    background: rgba(255,255,255,0.20);
    color: var(--muted);
    font-size: 13px;
    line-height: 1.3;
    user-select:none;
    -webkit-user-select:none;
  }



/* CHANGE HERE: sidebar layout – keep Stage visible, let only Properties body scroll */
.sidebar > .sidebarBody{
  flex: 1 1 auto;
  min-height: 0;
  overflow: hidden; /* prevents the whole sidebar from scrolling */
}



/* CHANGE HERE: Glyph picker UI (small buttons) */
.glyphPicker{
  display:flex;
  flex-direction:column;
  gap: 8px;
}

.glyphLetters{
  display:flex;
  flex-wrap:wrap;
  gap: 6px;
}

.glyphLetterBtn{
  appearance:none;
  border: 1px solid rgba(17,17,17,0.22);
  background: rgba(255,255,255,0.38);
  border-radius: 10px;
  padding: 4px 6px;
  font-weight: 800;
  font-size: 12px;
  line-height: 1;
  cursor:pointer;
  min-width: 26px;
  text-align:center;
}

.glyphLetterBtn[aria-pressed="true"]{
  background: rgba(255,255,255,0.78);
  border-color: rgba(17,17,17,0.42);
}

.glyphWords{
  display:flex;
  flex-wrap:wrap;
  gap: 6px;
}

.glyphWordBtn{
  appearance:none;
  border: 1px solid rgba(17,17,17,0.22);
  background: rgba(255,255,255,0.38);
  border-radius: 12px;
  padding: 6px 8px;
  cursor:pointer;
  display:flex;
  align-items:center;
  gap: 8px;
  font-weight: 800;
  font-size: 13px;
  white-space: nowrap;
}

.glyphWordBtn[aria-pressed="true"]{
  background: rgba(255,255,255,0.78);
  border-color: rgba(17,17,17,0.42);
  box-shadow: 0 10px 22px rgba(0,0,0,0.10);
}

.glyphPreview{
  font-family: "TP-Cartouche-Font";
  font-size: 18px;
  line-height: 1;
}


/* CHANGE HERE: Properties panel becomes a flex column so header stays fixed */
.propsPanel{
  display: flex;
  flex-direction: column;
  min-height: 0;
}

/* CHANGE HERE: Properties body is the scroller */
#propsBody{
  flex: 1 1 auto;
  min-height: 0;
  overflow: auto;
  -webkit-overflow-scrolling: touch;

  /* keep content from sitting under scrollbar */
  padding-right: 6px;

  /* Firefox thin scrollbar */
  scrollbar-width: thin;
  scrollbar-color: rgba(17,17,17,0.35) rgba(255,255,255,0.18);
}

/* Chrome/Edge/Safari thin scrollbar */
#propsBody::-webkit-scrollbar{ width: 8px; }
#propsBody::-webkit-scrollbar-track{
  background: rgba(255,255,255,0.18);
  border-radius: 999px;
}
#propsBody::-webkit-scrollbar-thumb{
  background: rgba(17,17,17,0.35);
  border-radius: 999px;
  border: 2px solid rgba(255,255,255,0.18);
}
#propsBody::-webkit-scrollbar-thumb:hover{
  background: rgba(17,17,17,0.50);
}

/* Optional: tighten property panel spacing slightly */
#propsBody .field textarea{ min-height: 84px; }

.nlModeControl{ display:none !important; }

  /* Mobile: collapse sidebar to top drawer-ish */
  @media (max-width: 860px){
    .wrap{
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
    .sidebar{ order: 1; }
    .stagePanel{ order: 2; }
    .toolGrid{ grid-template-columns: repeat(3, 1fr); }
  }

  @media (pointer: coarse), (max-width: 520px){
    /* CHANGE HERE: topbar height is now content-driven; remove fixed 52px */
    .topbar{ padding: 8px 8px; gap: 6px; }

    .btn{ font-size: 13px; padding: 6px 8px; border-radius: 10px; }
    .toolBtn{ font-size: 13px; padding: 6px 8px; border-radius: 12px; }

    .chip{ font-size: 12px; max-width: 48vw; }
    .wrap{ padding: 8px; gap: 10px; }
    .panelHeader h2{ font-size: 16px; }
  }
</style>

</head>

<body>
    <!-- CHANGE HERE: top toolbar -->
    <div class="topbar" id="topbar">
    <div class="topbarRow">
        <div class="topbarGroup" aria-label="Edit actions">
        <button class="btn" id="btnNew">New / Clear</button>
        <button class="btn" id="btnExportJson">Export JSON</button>
        <button class="btn" id="btnImportJson">Import JSON</button>
        <button class="btn" id="btnExportPng">Export PNG</button>
        </div>

        <div class="topbarGroup" aria-label="Grouping">
        <button class="btn" id="btnGroup">Group</button>
        <button class="btn" id="btnUngroup">Ungroup</button>
        </div>

        <div class="spacer"></div>
<div id="status" class="chip">Ready.</div>

    </div>

    <div class="topbarRow" aria-label="Tools">
        <!-- Keep the SAME IDs you already use -->
        <button class="toolBtn" id="toolSelect">Select</button>
        <button class="toolBtn" id="toolText">Text</button>
        <button class="toolBtn" id="toolSitelen">Sitelen</button>
        <button class="toolBtn" id="toolGlyph">Glyph</button>
        <button class="toolBtn" id="toolRect">Rectangle</button>
        <button class="toolBtn" id="toolImage">Image</button>
        <button class="toolBtn" id="toolDelete">Delete</button>
        <button class="toolBtn" id="toolPan">Pan</button>

        <button id="btnUndo" class="toolBtn toolBtnSmall" type="button" title="Undo (Ctrl/Cmd+Z)" disabled>Undo</button>
        <button id="btnRedo" class="toolBtn toolBtnSmall" type="button" title="Redo (Ctrl/Cmd+Y or Ctrl/Cmd+Shift+Z)" disabled>Redo</button>

        <button id="btnCopy" class="toolBtn toolBtnSmall" type="button" title="Copy (Ctrl/Cmd+C)">Copy</button>
        <button id="btnCut"  class="toolBtn toolBtnSmall" type="button" title="Cut (Ctrl/Cmd+X)">Cut</button>
        <button id="btnPaste"class="toolBtn toolBtnSmall" type="button" title="Paste (Ctrl/Cmd+V)">Paste</button>

    </div>
    </div>


  <div class="wrap">
    <section class="panel sidebar" aria-label="Tools and properties">
      <div class="sidebarBody">


        <div class="panel stageMiniPanel" style="box-shadow:none;">
          <div class="panelHeader">
            <h2>Stage</h2>
            <div class="hdrBtnRow">
              <button id="btnSnapGrid" class="btn" type="button" aria-pressed="true">Snap: Grid</button>
              <button id="btnSnapObjs" class="btn" type="button" aria-pressed="false">Snap: Objects</button>
              <button id="btnGrid" class="btn" type="button" aria-pressed="true">Grid</button>
            </div>
          </div>

          <div class="stageMiniBody">
            <div class="row">
              <div class="field">
                <label for="stageW">Width</label>
                <input id="stageW" type="number" min="64" step="1" value="1280" />
              </div>
              <div class="field">
                <label for="stageH">Height</label>
                <input id="stageH" type="number" min="64" step="1" value="800" />
              </div>
            </div>

            <div class="row">
              <div class="field">
                <label for="gridSize">Grid size</label>
                <input id="gridSize" type="number" min="2" step="1" value="20" />
              </div>
              <div class="field">
                <label for="snapTol">Snap tolerance</label>
                <input id="snapTol" type="number" min="1" step="1" value="6" />
              </div>
            </div>

            <div class="row">
              <div class="field">
                <label for="stageBg">Stage background</label>
                <input id="stageBg" type="color" value="#F3DFC0" />
              </div>
              <div class="field">
                <label for="defTextColor">Default text</label>
                <input id="defTextColor" type="color" value="#111111" />
              </div>
            </div>

            <div class="row">
              <div class="field">
                <label for="defFill">Default fill</label>
                <!-- color input cannot store rgba; we will store as rgba in JS, but pick hex here -->
                <input id="defFill" type="color" value="#FFFFFF" />
              </div>
              <div class="field">
                <label for="defStroke">Default stroke</label>
                <input id="defStroke" type="color" value="#111111" />
              </div>
            </div>




 <div class="row">
              <div class="field">
                <!-- NEW -->
    <label class="checkInline" style="margin:0;">
      <input id="defFillEnabled" type="checkbox" />Default allow fill</label>
              </div>
            </div>




            <div class="row">
              <div class="field">
                <label for="defStrokeW">Default stroke width</label>
                <input id="defStrokeW" type="number" min="0" step="1" value="2" />
              </div>
            </div>

          </div>
        </div>

        <div class="panel propsPanel" style="box-shadow:none;">
          <div class="panelHeader">
            <h2>Properties</h2>
            <div class="row" style="justify-content:flex-end; gap:6px;">
              <button id="btnBringFwd" class="btn" type="button" disabled>Bring Forward</button>
              <button id="btnSendBack" class="btn" type="button" disabled>Send Backward</button>
            </div>
          </div>

          <div id="propsBody" class="sidebarBody" style="padding:10px 12px;">
            <div class="hint">Select an element to edit its properties.</div>
          </div>
        </div>

        <div class="footer">
           <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <div class="footerRight">
          <a href="./index.html">Back to index</a>
        </div>
        </div>
      </div>
    </section>

    <section class="panel stagePanel" aria-label="Stage">
      <div class="panelHeader">
        <h2>Stage</h2>
        <div class="row" style="justify-content:flex-end;">
          <button id="btnFit" class="btn" type="button">Fit</button>
          <button id="btnZoomIn" class="btn" type="button">Zoom +</button>
          <button id="btnZoomOut" class="btn" type="button">Zoom -</button>
          <button id="btnResetView" class="btn" type="button">Reset View</button>
        </div>
      </div>

      <div class="stageBody">
        <div class="canvasWrap" id="canvasWrap">
          <canvas id="c"></canvas>
          <div id="hud" class="overlayHud">Ready.</div>
        </div>
      </div>
    </section>
  </div>

  <!-- Hidden file inputs -->
  <input id="fileImportJson" type="file" accept="application/json" style="display:none;" />
  <input id="filePickImage" type="file" accept="image/*" style="display:none;" />

<script>
(() => {
  "use strict";

  /* ============================================================
     CHANGE HERE: Sitelen rendering hook
     ------------------------------------------------------------
     For Sitelen elements you said: “use a different rendering function than plain text”.
     This editor includes a hook that you can replace with your own implementation.

     - Return a string to render for a single line (e.g., convert Latin TP to UCSUR glyphs).
     - Default: identity (renders the same text).
     ============================================================ */
  function renderSitelenLineToCanvasText(line) {
    // Replace this with your own:
    //   return renderSitelenSourceToUcsur(line);
    return String(line ?? "");
  }

  /* ============================================================
     Constants and utilities
     ============================================================ */
  const $ = (id) => document.getElementById(id);

  const DB_NAME = "canvas_layout_editor_db";
  const DB_STORE = "scenes";
  const DB_KEY = "scene_v1";

  const Tool = Object.freeze({
    Select: "select",
    Text: "text",
    Sitelen: "sitelen",
    Glyph: "glyph",
    Rect: "rect",
    Image: "image",
    Delete: "delete",
    Pan: "pan",
  });

  const ElementType = Object.freeze({
    Text: "text",
    Sitelen: "sitelen",
    Glyph: "glyph",
    Rect: "rect",
    Image: "image",
  });

  const DEFAULTS = Object.freeze({
    stageW: 1280,
    stageH: 800,
    gridSize: 20,
    snapTol: 6,
    showGrid: true,
    snapGrid: true,
    snapObjects: false,
    viewZoom: 1.0,

    // NEW: stage + default styling
    stageBg: "#FFFFFF", //"#F3DFC0",                 // stage background color
    defaultTextColor: "#000000",        // default text color (Text/Sitelen/Glyph)
    defaultFill: "#111111",// default fill for shapes/boxes
    defaultFillEnabled: false,
    defaultStroke: "#111111",// default stroke
    defaultStrokeW: 2,                  // default stroke width
  });




  /* ============================================================
   WORDS / UCSUR (your provided set)
   ============================================================ */
const WORD_TO_UCSUR_CP = {
  "nanpa": 0xF193D,
  "esun":  0xF190B,
  "en":    0xF190A,
  "e":     0xF1909,
  "nasa":  0xF193E,
 
  "nena":  0xF1940,
  "o":     0xF1944,
  "kulupu":0xF191F,
  "ijo":   0xF190C,
  "wan":   0xF1973,
  "tu":    0xF196E,
  "sijelo":0xF195B,
  "awen":  0xF1908,
  "luka":  0xF192D,
  "utala": 0xF1971,
  "mun":   0xF193A,
  "pipi":  0xF1951,
  "jo":    0xF1913,

  "a": 0xF1900,
  "akesi": 0xF1901,
  "ala": 0xF1902,
  "alasa": 0xF1903,
  "ale": 0xF1904,
  "ali": 0xF1904,
  "anpa": 0xF1905,
  "ante": 0xF1906,
  "anu": 0xF1907,
  "ike": 0xF190D,
  "ilo": 0xF190E,
  "insa": 0xF190F,
  "jaki": 0xF1910,
  "jan": 0xF1911,
  "jelo": 0xF1912,
  "kala": 0xF1914,
  "kalama": 0xF1915,
  "kama": 0xF1916,
  "kasi": 0xF1917,
  "ken": 0xF1918,
  "kepeken": 0xF1919,
  "kili": 0xF191A,
  "kiwen": 0xF191B,
  "ko": 0xF191C,
  "kon": 0xF191D,
  "kule": 0xF191E,
  "kute": 0xF1920,
  "la": 0xF1921,
  "lape": 0xF1922,
  "laso": 0xF1923,
  "lawa": 0xF1924,
  "len": 0xF1925,
  "lete": 0xF1926,
  "li": 0xF1927,
  "lili": 0xF1928,
  "linja": 0xF1929,
  "lipu": 0xF192A,
  "loje": 0xF192B,
  "lon": 0xF192C,
  "lukin": 0xF192E,
  "lupa": 0xF192F,
  "ma": 0xF1930,
  "mama": 0xF1931,
  "mani": 0xF1932,
  "meli": 0xF1933,
  "mi": 0xF1934,
  "mije": 0xF1935,
  "moku": 0xF1936,
  "moli": 0xF1937,
  "monsi": 0xF1938,
  "mu": 0xF1939,
  "musi": 0xF193B,
  "mute": 0xF193C,
  "nasin": 0xF193F,
  "nimi": 0xF1942,
  "noka": 0xF1943,
  "olin": 0xF1945,
  "ona": 0xF1946,
  "open": 0xF1947,
  "pakala": 0xF1948,
  "pali": 0xF1949,
  "palisa": 0xF194A,
  "pan":    0xF194B,
  "pana":   0xF194C,
  "pi":     0xF194D,
  "pilin":  0xF194E,
  "pimeja": 0xF194F,
  "pini": 0xF1950,
  "poka": 0xF1952,
  "poki": 0xF1953,
  "pona": 0xF1954,
  "pu": 0xF1955,
  "sama": 0xF1956,
  "seli": 0xF1957,
  "selo": 0xF1958,
  "seme": 0xF1959,

  "sike": 0xF195C,
  "sin": 0xF195D,
  "sina": 0xF195E,
  "sinpin": 0xF195F,
  "sitelen": 0xF1960,
  "sona": 0xF1961,
  "soweli": 0xF1962,
  "suli": 0xF1963,
  "suno": 0xF1964,
  "supa": 0xF1965,
  "suwi": 0xF1966,
  "tan": 0xF1967,
  "taso": 0xF1968,
  "tawa": 0xF1969,
  "telo": 0xF196A,
  "tenpo": 0xF196B,
  "toki": 0xF196C,
  "tomo": 0xF196D,
  "unpa": 0xF196F,
  "uta": 0xF1970,
  "walo": 0xF1972,
  "waso": 0xF1974,
  "wawa": 0xF1975,
  "weka": 0xF1976,
  "wile": 0xF1977,
  "namako": 0xF1978,
  "kin": 0xF1979,
  "oko": 0xF197A,
  "kipisi": 0xF197B,
  "leko": 0xF197C,
  "monsuta": 0xF197D,
  "tonsi": 0xF197E,
  "jasima": 0xF197F,
  "kijetesantakalu": 0xF1980,
  "soko": 0xF1981,
  "meso": 0xF1982,
  "epiku": 0xF1983,
 
  "lanpan": 0xF1985,
  "n": 0xF1986,
  "misikeke": 0xF1987,
  "ku": 0xF1988,

  "majuna": 0xF19A2,
  "su": 0xF19A6,
  "linluwi":0xF19A4,

   "ni":    0xF1941,

  "sewi": 0xF195A,

           "sewi^": 0xF198C,
  "ni>": 0xF198B,
      "ni^": 0xF198A,
      "ni<": 0xF1989


};// "kokosila": 0xF1984,


function migrateLegacyImagePayloadToAssetId(el){
  if (!el || el.type !== ElementType.Image) return;

  if (!el.image || typeof el.image !== "object") return;
  if (el.image.assetId) return; // already modern

  // Accept either legacy formats:
  //  1) { dataUrl: "data:image/png;base64,..." }
  //  2) { mime: "image/png", b64: "..." }
  let dataUrl = "";

  if (el.image.dataUrl && String(el.image.dataUrl).startsWith("data:")){
    dataUrl = String(el.image.dataUrl);
  } else if (el.image.mime && el.image.b64){
    dataUrl = `data:${String(el.image.mime)};base64,${String(el.image.b64)}`;
  }

  if (!dataUrl) return;

  const assetId = addImageAssetFromDataUrl(dataUrl);
  el.image.assetId = assetId;

  // Remove legacy fields so history snapshots and future exports don't keep base64 in-scene
  delete el.image.b64;
  delete el.image.mime;
  delete el.image.dataUrl;
}



  // CHANGE HERE: normalize imported scenes (defaults + backwards compat)
function normalizeScene(parsed){
  const out = (parsed && typeof parsed === "object") ? parsed : {};

  out.meta = out.meta || {
    version: 1,
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  };

  out.stage = Object.assign({
    w: DEFAULTS.stageW,
    h: DEFAULTS.stageH,
    showGrid: DEFAULTS.showGrid,
    gridSize: DEFAULTS.gridSize,
    snapGrid: DEFAULTS.snapGrid,
    snapObjects: DEFAULTS.snapObjects,
    snapTol: DEFAULTS.snapTol,

    // NEW
    bg: DEFAULTS.stageBg,
    defaultTextColor: DEFAULTS.defaultTextColor,
    defaultFill: DEFAULTS.defaultFill,
    defaultFillEnabled: DEFAULTS.defaultFillEnabled,
    defaultStroke: DEFAULTS.defaultStroke,
    defaultStrokeW: DEFAULTS.defaultStrokeW,
  }, out.stage || {});

  if (!("defaultFillEnabled" in out.stage)) out.stage.defaultFillEnabled = true;



  out.view = Object.assign({
    zoom: DEFAULTS.viewZoom,
    offsetX: 0,
    offsetY: 0,
  }, out.view || {});

  out.elements = Array.isArray(out.elements) ? out.elements : [];

  for (const el of out.elements){
    // Required-ish fields
    el.id = String(el.id || uid("el"));
    el.type = String(el.type || "");

    el.x = Number.isFinite(el.x) ? el.x : 0;
    el.y = Number.isFinite(el.y) ? el.y : 0;
    el.w = Number.isFinite(el.w) ? Math.max(8, el.w) : 240;
    el.h = Number.isFinite(el.h) ? Math.max(8, el.h) : 120;

    el.rotationDeg = Number.isFinite(el.rotationDeg) ? el.rotationDeg : 0;
    el.opacity = Number.isFinite(el.opacity) ? clamp(el.opacity, 0, 1) : 1;

    el.fill = rgbaOrHexToHex(el.fill || "#FFFFFF", "#FFFFFF");

    if (typeof el.fillEnabled !== "boolean") el.fillEnabled = false;

    el.stroke = rgbaOrHexToHex(el.stroke || "#111111", "#111111");
  
    const defSW = Number.isFinite(out.stage?.defaultStrokeW) ? out.stage.defaultStrokeW : 2;
    if (!Number.isFinite(el.strokeW)) {
      // Text-like elements default to no stroke; shapes default to the stage's stroke width.
      el.strokeW = (el.type === ElementType.Text || el.type === ElementType.Sitelen || el.type === ElementType.Glyph) ? 0 : defSW;
    }
    el.strokeW = Number.isFinite(el.strokeW) ? Math.max(0, el.strokeW) : 0;

    el.groupId = el.groupId ?? null;

    // CHANGE HERE: lock flag (default false on import if missing)
    el.isLocked = !!el.isLocked;

    // NEW: default false on import if missing (Text + Glyph only)
    if (el.type === ElementType.Text || el.type === ElementType.Glyph){
      el.scaleFontWithBox = (el.scaleFontWithBox == null) ? false : !!el.scaleFontWithBox;
    }


    // Remove transient drag fields if present in older exports
    delete el._startX; delete el._startY;
    delete el._startW; delete el._startH;
    delete el._startRot; delete el._startFontSize;
    delete el._startRadius;

    // Type-specific defaults
    if (el.type === ElementType.Text || el.type === ElementType.Sitelen){
      el.text = String(el.text ?? "");
      // CHANGE HERE: Sitelen defaults to PatrickHand too
      el.fontFamily = el.fontFamily || "PatrickHand";
      el.fontSize = Number.isFinite(el.fontSize) ? el.fontSize : (el.type === ElementType.Sitelen ? 44 : 28);
      el.align = el.align || "left";
      const elColor = rgbaOrHexToHex(el.color ||  "#111111", "#111111");
      console.log("Set element color " + elColor);
      el.color = elColor;
      el.lineHeight = Number.isFinite(el.lineHeight) ? el.lineHeight : 1.15;

      if (el.type === ElementType.Sitelen){
        // ADD: default keepAspect true for old JSON
        el.keepAspect = (el.keepAspect == null) ? true : !!el.keepAspect;

        // ADD: sitelen metadata container (mirrors image.origW/origH concept)
        if (!el.sitelen || typeof el.sitelen !== "object") el.sitelen = {};

        // Build raster + resize bbox on import
        updateSitelenLayout(el, { preserveCenter: true });
      }


    }

    if (el.type === ElementType.Glyph){
  el.codepoint = String(el.codepoint ?? "U+F1934");

  // CHANGE HERE: glyph font family is fixed
  el.fontFamily = "TP-Cartouche-Font";

  el.fontSize = Number.isFinite(el.fontSize) ? el.fontSize : 92;
  el.color = rgbaOrHexToHex(el.color ||  "#111111", "#111111");
}


    if (el.type === ElementType.Rect){
      el.radius = Number.isFinite(el.radius) ? Math.max(0, el.radius) : 18;
    }

    if (el.type === ElementType.Image){
      // keep as-is; may be null
      el.image = el.image ?? null;

      // CHANGE HERE: default keepAspect true for old JSON
      el.keepAspect = (el.keepAspect == null) ? true : !!el.keepAspect;

      // CHANGE HERE: if old JSON has an embedded image but no origW/origH, capture current box as “original”
      if (el.image && typeof el.image === "object"){
        if (!Number.isFinite(el.image.origW)) el.image.origW = el.w;
        if (!Number.isFinite(el.image.origH)) el.image.origH = el.h;
      }
    }

  }

  for (const el of out.elements){
  migrateLegacyImagePayloadToAssetId(el);
}


out.groups = (out.groups && typeof out.groups === "object") ? out.groups : {};

// Ensure group records have defaults
for (const [gid, g] of Object.entries(out.groups)){
  if (!g || typeof g !== "object") out.groups[gid] = { id: gid };
  if (!out.groups[gid].id) out.groups[gid].id = gid;
  if (!out.groups[gid].createdAt) out.groups[gid].createdAt = new Date().toISOString();
  if (!out.groups[gid].foreground) out.groups[gid].foreground = "#111111";
}

return out;

}

  const HANDLE = Object.freeze({
    None: "none",
    Move: "move",
    Marquee: "marquee",
    ResizeNW: "resize_nw",
    ResizeN: "resize_n",
    ResizeNE: "resize_ne",
    ResizeE: "resize_e",
    ResizeSE: "resize_se",
    ResizeS: "resize_s",
    ResizeSW: "resize_sw",
    ResizeW: "resize_w",
    Rotate: "rotate",
    Pan: "pan",
  });



function clamp(n, lo, hi){
  return Math.min(hi, Math.max(lo, n));
}





  function roundTo(v, step){ return Math.round(v / step) * step; }
  function rad(deg){ return deg * Math.PI / 180; }
  function deg(r){ return r * 180 / Math.PI; }

  // CHANGE HERE: build a correct CSS font-family string for canvas
function cssFontFamily(family){
  const f = String(family ?? "").trim();
  if (!f) return `"PatrickHand", system-ui, sans-serif`;

  // If user already supplied a full family list (contains comma), use as-is.
  if (f.includes(",")) return f;

  // If already quoted, use as-is.
  if ((f.startsWith('"') && f.endsWith('"')) || (f.startsWith("'") && f.endsWith("'"))) return f;

  // Otherwise quote a single family name safely.
  return `"${f}"`;
}

function sitelenLiteralFontFamilyForElement(el){
  // Use the element’s fontFamily for quoted/literal segments.
  // Fall back to PatrickHand if empty.
  const f = String(el.fontFamily ?? "").trim();
  return f ? f : "PatrickHand";
}

function sitelenLiteralFontAlignmentForElement(el){
  // Use the element’s align to determine line alignment
  // Fall back to left if empty.
  const f = String(el.align ?? "").trim();
  return f ? f : "left";
}


  function uid(prefix="id"){
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function deepClone(obj){
  try{
    if (typeof structuredClone === "function") return structuredClone(obj);
  }catch(_){}
  return JSON.parse(JSON.stringify(obj));
}

  function toBase64FromArrayBuffer(buf) {
    const bytes = new Uint8Array(buf);
    let bin = "";
    const CHUNK = 0x8000;
    for (let i=0; i<bytes.length; i+=CHUNK){
      bin += String.fromCharCode(...bytes.subarray(i, i+CHUNK));
    }
    return btoa(bin);
  }

  function arrayBufferFromBase64(b64) {
    const bin = atob(b64);
    const bytes = new Uint8Array(bin.length);
    for (let i=0; i<bin.length; i++) bytes[i] = bin.charCodeAt(i);
    return bytes.buffer;
  }


// ---------------------------------------------------------------------------
// Asset Management (dedupe + keep base64 out of history snapshots)
// ---------------------------------------------------------------------------
const Assets = {
  byId: new Map(),   // id -> asset
  byHash: new Map()  // hash -> id
};

function makeAssetId(prefix="img"){
  return `${prefix}_${Math.random().toString(16).slice(2)}${Date.now().toString(16)}`;
}

// Fast-ish hash for dataUrls (not cryptographic; good for dedupe)
function hashStringFNV1a(str){
  let h = 0x811c9dc5;
  for (let i=0; i<str.length; i++){
    h ^= str.charCodeAt(i);
    h = (h * 0x01000193) >>> 0;
  }
  return ("00000000" + h.toString(16)).slice(-8);
}

function addImageAssetFromDataUrl(dataUrl){
  const hash = hashStringFNV1a(dataUrl);
  const existingId = Assets.byHash.get(hash);
  if (existingId) return existingId;

  const mimeMatch = /^data:([^;]+);base64,/.exec(dataUrl);
  const mime = mimeMatch ? mimeMatch[1] : "application/octet-stream";

  const id = makeAssetId("img");
  const asset = { id, kind: "image", dataUrl, mime, hash };
  Assets.byId.set(id, asset);
  Assets.byHash.set(hash, id);
  return id;
}

function getImageAssetDataUrl(assetId){
  const a = Assets.byId.get(assetId);
  return (a && a.kind === "image") ? a.dataUrl : null;
}

// NEW: turn a picked file into a data URL using your existing base64 helper
async function dataUrlFromBlob(blob){
  const ab = await blob.arrayBuffer();
  const b64 = toBase64FromArrayBuffer(ab);
  const mime = blob.type || "application/octet-stream";
  return `data:${mime};base64,${b64}`;
}

// NEW: persistence helpers
function serializeAssets(){
  return { byId: Array.from(Assets.byId.values()) };
}

function deserializeAssets(serialized){
  Assets.byId.clear();
  Assets.byHash.clear();
  if (!serialized) return;

  const list = Array.isArray(serialized.byId) ? serialized.byId
            : Array.isArray(serialized) ? serialized
            : [];

  for (const a of list){
    if (!a || typeof a !== "object") continue;
    if (!a.id || a.kind !== "image" || !a.dataUrl) continue;

    const id = String(a.id);
    const dataUrl = String(a.dataUrl);
    const hash = String(a.hash || hashStringFNV1a(dataUrl));
    const mime = String(a.mime || "application/octet-stream");

    const asset = { id, kind:"image", dataUrl, mime, hash };
    Assets.byId.set(id, asset);
    Assets.byHash.set(hash, id);
  }
}






  function downloadBlob(blob, filename){
    const a = document.createElement("a");
    const url = URL.createObjectURL(blob);
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function nowIso(){
    const d = new Date();
    const pad = (n) => String(n).padStart(2,"0");
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
  }





  /* ============================================================
     Scene model
     ============================================================ */
  const Scene = {
    meta: {
      version: 1,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    },
    stage: {
      w: DEFAULTS.stageW,
      h: DEFAULTS.stageH,
      showGrid: DEFAULTS.showGrid,
      gridSize: DEFAULTS.gridSize,
      snapGrid: DEFAULTS.snapGrid,
      snapObjects: DEFAULTS.snapObjects,
      snapTol: DEFAULTS.snapTol,

      // NEW
      bg: DEFAULTS.stageBg,
      defaultTextColor: DEFAULTS.defaultTextColor,
      defaultFill: DEFAULTS.defaultFill,
      defaultStroke: DEFAULTS.defaultStroke,
      defaultStrokeW: DEFAULTS.defaultStrokeW,
    },
    view: {
      zoom: DEFAULTS.viewZoom,
      offsetX: 0,
      offsetY: 0,
    },
    elements: /** @type {any[]} */ ([]),
    groups: /** @type {Record<string, any>} */ ({}),
  };

  /* Each element:
     {
       id, type,
       x,y,w,h, rotationDeg,
       fill, stroke, strokeW, opacity,
       radius, // rect
       text, fontFamily, fontSize, align, color, lineHeight,
       codepoint, // glyph
       image: { mime, b64, naturalW, naturalH } // image
       groupId: string|null
     }
  */

  function defaultElementBase(type, x, y){
    console.log("Default base stage " + JSON.stringify( Scene.stage));
    return {
      id: uid("el"),
      type,
      x, y,
      w: 240,
      h: 120,
      rotationDeg: 0,
      opacity: 1.0,

        // NEW: pull defaults from stage
      fill: Scene.stage.defaultFill ?? DEFAULTS.defaultFill,
      fillEnabled : Scene.stage.defaultFillEnabled ?? DEFAULTS.defaultFillEnabled,
      stroke: Scene.stage.defaultStroke ?? DEFAULTS.defaultStroke,
      strokeW: Number.isFinite(Scene.stage.defaultStrokeW) ? Scene.stage.defaultStrokeW : DEFAULTS.defaultStrokeW,


      groupId: null,
      // CHANGE HERE: lock flag
      isLocked: false,
      // NEW: when true, bbox resize scales fontSize; when false, fontSize stays fixed
      scaleFontWithBox: false,
    };
  }

  function newTextElement(x,y){
    const el = defaultElementBase(ElementType.Text, x, y);
    el.w = 320; el.h = 140;
    el.text = "Text\n(multiline)";
    el.fontFamily = "PatrickHand";
    el.fontSize = 28;
    el.align = "left";
   el.color = Scene.stage.defaultTextColor ?? DEFAULTS.defaultTextColor;
    el.lineHeight = 1.15;
//    el.fill = "rgba(255,255,255,0.0)"; // default: no background
    el.strokeW = 0;
    el.scaleFontWithBox = false; // NEW (explicit)
    return el;
  }

  function newSitelenElement(x,y){
    const el = defaultElementBase(ElementType.Sitelen, x, y);
    el.w = 420; el.h = 160;
    el.text = "toki pona";
    el.fontFamily = "PatrickHand";
    el.fontSize = 44;
    el.align = "left";
  el.color = Scene.stage.defaultTextColor ?? DEFAULTS.defaultTextColor;
    el.lineHeight = 1.05;
//    el.fill = "rgba(255,255,255,0.0)";
    el.strokeW = 0;

      // ADD THIS:
    el.keepAspect = true;

    updateSitelenLayout(el, { preserveCenter: false });


    return el;
  }

  function newGlyphElement(x,y){
    const el = defaultElementBase(ElementType.Glyph, x, y);
    el.w = 120; el.h = 120;
    el.codepoint = "U+F1934"; // default example (mi) – user can change
    el.fontFamily = "TP-Cartouche-Font";
    el.fontSize = 92;
    el.align = "center";
   el.color = Scene.stage.defaultTextColor ?? DEFAULTS.defaultTextColor;
//    el.fill = "rgba(255,255,255,0.0)";
    el.strokeW = 0;
    el.scaleFontWithBox = false; // NEW (explicit)
    return el;
  }

  function newRectElement(x,y){
    const el = defaultElementBase(ElementType.Rect, x, y);
    el.w = 260; el.h = 160;
    el.radius = 18;
   // el.fill = "rgba(255,255,255,0.65)";
    el.opacity = 1.0;
    return el;
  }

function newImageElement(x,y){
  const el = defaultElementBase(ElementType.Image, x, y);
  el.w = 320; el.h = 220;
  el.fill = "#FFFFFF";
  el.image = null; // assigned after file pick
  el.keepAspect = true; // CHANGE HERE: default true
 // el.stroke = "rgba(17,17,17,0.35)";
 // el.strokeW = 2;
  return el;
}


  /* ============================================================
     IndexedDB
     ============================================================ */
  let dbPromise = null;

  function openDb(){
    if (dbPromise) return dbPromise;
    dbPromise = new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(DB_STORE)) db.createObjectStore(DB_STORE);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
    return dbPromise;
  }

  async function dbPut(key, value){
    const db = await openDb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readwrite");
      tx.objectStore(DB_STORE).put(value, key);
      tx.oncomplete = () => resolve(true);
      tx.onerror = () => reject(tx.error);
    });
  }

  async function dbGet(key){
    const db = await openDb();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(DB_STORE, "readonly");
      const req = tx.objectStore(DB_STORE).get(key);
      req.onsuccess = () => resolve(req.result ?? null);
      req.onerror = () => reject(req.error);
    });
  }

  let saveTimer = null;
  function scheduleAutosave(){
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(async () => {
      try{
        Scene.meta.updatedAt = new Date().toISOString();

        await dbPut(DB_KEY, {
          scene: deepClone(Scene),
          assets: serializeAssets()
        });

        setStatus("Autosaved");
      }catch(err){
        console.warn(err);
        setStatus("Autosave failed (IndexedDB).");
      }
    }, 350);
  }

  /* ============================================================
     Canvas setup and view transforms
     ============================================================ */
  const canvas = $("c");
  const ctx = canvas.getContext("2d");

  const wrap = $("canvasWrap");
  const hud = $("hud");

function setStatus(msg){
  const s = $("status");
  if (s) s.textContent = msg;
  hud.textContent = msg;
}


  function resizeCanvasToDisplay(){
    const dpr = window.devicePixelRatio || 1;
    const rect = wrap.getBoundingClientRect();
    const w = Math.max(2, Math.floor(rect.width));
    const h = Math.max(2, Math.floor(rect.height));
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    render();
  }

//  window.addEventListener("resize", resizeCanvasToDisplay);
window.addEventListener("resize", () => render());

  function stageToScreen(pt){
    return {
      x: (pt.x + Scene.view.offsetX) * Scene.view.zoom,
      y: (pt.y + Scene.view.offsetY) * Scene.view.zoom,
    };
  }
  function screenToStage(pt){
    return {
      x: pt.x / Scene.view.zoom - Scene.view.offsetX,
      y: pt.y / Scene.view.zoom - Scene.view.offsetY,
    };
  }

function fitStageToView(){
  const rect = wrap.getBoundingClientRect();

  // CHANGE HERE: smaller pad, and anchor stage to top-left instead of centering
  const pad = 8;

  const vw = rect.width - pad * 2;
  const vh = rect.height - pad * 2;

  const sx = vw / Scene.stage.w;
  const sy = vh / Scene.stage.h;
  const z = clamp(Math.min(sx, sy), 0.1, 8);

  Scene.view.zoom = z;

  // CHANGE HERE: anchor stage origin at (pad, pad) in screen/CSS pixels
  Scene.view.offsetX = pad / z;
  Scene.view.offsetY = pad / z;

  scheduleAutosave();
  render();
}


  /* ============================================================
     Image cache (for drawing)
     ============================================================ */
  const imageCache = new Map(); // el.id -> { img: HTMLImageElement, ready: bool }

  function invalidateImageCache(elId){
    imageCache.delete(elId);
  }

function ensureImageLoadedForElement(el){
  if (el.type !== ElementType.Image) return null;
  if (!el.image || typeof el.image !== "object") return null;

  // Legacy migration: older scenes may still have {mime,b64} or {dataUrl}
  if (!el.image.assetId){
    const dataUrl = (el.image.dataUrl && String(el.image.dataUrl).startsWith("data:"))
      ? String(el.image.dataUrl)
      : (el.image.mime && el.image.b64)
        ? `data:${String(el.image.mime)};base64,${String(el.image.b64)}`
        : "";

    if (dataUrl){
      try {
        el.image.assetId = addImageAssetFromDataUrl(dataUrl);
        delete el.image.b64;
        delete el.image.dataUrl;
        delete el.image.mime;
        scheduleAutosave();
      } catch {}
    }
  }

  const assetId = el.image.assetId ? String(el.image.assetId) : "";
  if (!assetId) return null;

  const dataUrl = getImageAssetDataUrl(assetId);
  if (!dataUrl) return null;

  let entry = imageCache.get(el.id);
  if (entry && entry.ready && entry.assetId === assetId) return entry.img;

  if (!entry){
    entry = { img: new Image(), ready: false, assetId: "" };
    imageCache.set(el.id, entry);
    entry.img.onload = () => { entry.ready = true; render(); };
    entry.img.onerror = () => { entry.ready = false; };
  }

  if (entry.assetId !== assetId){
    entry.ready = false;
    entry.assetId = assetId;
    entry.img.src = dataUrl;
  }

  return entry.ready ? entry.img : null;
}




//******* new code for displaying sitelen elements




/* ============================================================
   Multiline text → elements → bounding box → draw-to-canvas
   Extracted/minimized from your page: includes parsing + measuring + rendering.
   You can paste this into another HTML page and call:

     const linesEls = parseMultilineToElements(inputText, { fontPx, mode });
     const box = measureMultiline(linesEls, { fontPx, padPx: 18, lineGapPx: 18 });
     renderMultilineToCanvas(canvas, linesEls, { fontPx, fgCss: "#111", padPx: 18, lineGapPx: 18 });

   CHANGE HERE blocks indicate where to paste your existing maps and font names.
   ============================================================ */

/* ============================
   CHANGE HERE: font family names used by canvas ctx.font
   ============================ */
const FONT_FAMILY_TEXT      = "TP-Nasin-Nanpa-Font";
const FONT_FAMILY_CARTOUCHE = "TP-Cartouche-Font";
const FONT_FAMILY_LITERAL   = "PatrickHand";

/* ============================
   Layout constants used by bbox + draw
   ============================ */
const WORD_GAP_PX = 12;
const LINE_GAP_PX = 18;   // can override via options
const DEFAULT_PAD_PX = 18;

/* ============================
   Cartouche and long-pi codepoints
   ============================ */
const CARTOUCHE_START_CP = 0xF1990;
const CARTOUCHE_END_CP   = 0xF1991;

// Long "pi { ... }" container glyphs
const LONG_PI_START_CP = 0xF1993;   // START OF LONG PI
const LONG_PI_EXT_CP   = 0xF1994;   // COMBINING LONG PI EXTENSION

/* ============================
   CHANGE HERE: word → UCSUR codepoint map
   - Paste your full MULTI_LINE_WORD_TO_UCSUR_CP object here (including punctuation keys).
   - This is required for parsing and rendering known words and punctuation.
   ============================ */
const MULTI_LINE_WORD_TO_UCSUR_CP = {
  /* PASTE YOUR EXISTING MULTI_LINE_WORD_TO_UCSUR_CP HERE */
  // Example minimal placeholders:
  ...WORD_TO_UCSUR_CP,
  ":": 0xF199D,
  "·": 0xF199C,
  ",": 0xF199E,
  ".": 0xF199C,

  "kolon": 0xF199D,
  "ota": 0xF199C,
  "koma": 0xF199E
};

function isKnownTpWordKey(k) {
  return MULTI_LINE_WORD_TO_UCSUR_CP[k] != null;
}

/* ============================
   CHANGE HERE: nanpa-linja-n TP word → CP map
   - Paste your full NANPA_LINJA_N_WORD_TO_CP here if you want cartouches.
   - If you do not need number cartouches on the new page, you can keep a minimal map
     and skip using nanpa-linja-n features.
   ============================ */
const NANPA_LINJA_N_WORD_TO_CP = {
  /* PASTE YOUR EXISTING NANPA_LINJA_N_WORD_TO_CP HERE */
  "nanpa": 0xF193D,
  "en":    0xF190A,
  "esun":  0xF190B,
  "e":     0xF1909,
  "nena":  0xF1940,
  "nasa":  0xF193E,
  "ni":    0xF1941,
  "o":     0xF1944,
  "ona":   0xF1946,
  "kulupu":0xF191F,
  "ijo":   0xF190C,
  "wan":   0xF1973,
  "tu":    0xF196E,
  "seli":  0xF1957,
  "awen":  0xF1908,
  "luka":  0xF192D,
  "utala": 0xF1971,
  "mun":   0xF193A,
  "pipi":  0xF1951,
  "jo":    0xF1913
};

const CP_NANPA = NANPA_LINJA_N_WORD_TO_CP["nanpa"];
const CP_NENA  = NANPA_LINJA_N_WORD_TO_CP["nena"];
const CP_EN    = NANPA_LINJA_N_WORD_TO_CP["en"];

const UNIFORM_TO_NENA = new Set([
  NANPA_LINJA_N_WORD_TO_CP["nasa"],
  NANPA_LINJA_N_WORD_TO_CP["nasin"],
  NANPA_LINJA_N_WORD_TO_CP["ni"],
  NANPA_LINJA_N_WORD_TO_CP["nimi"],
  NANPA_LINJA_N_WORD_TO_CP["noka"],
  NANPA_LINJA_N_WORD_TO_CP["nena"]
]);

const UNIFORM_TO_EN = new Set([
  NANPA_LINJA_N_WORD_TO_CP["e"],
  NANPA_LINJA_N_WORD_TO_CP["en"],
  NANPA_LINJA_N_WORD_TO_CP["esun"]
]);

function uniformizeNanpaLinjanCartoucheCps(cps) {
  const a = Array.from(cps ?? []);
  if (a.length === 0) return a;

  for (let i = 0; i < a.length; i++) {
    const cp = a[i];

    if (cp === CP_NANPA) {
      if (i !== 0 && i !== a.length - 1) a[i] = CP_NENA;
      continue;
    }
    if (UNIFORM_TO_NENA.has(cp)) { a[i] = CP_NENA; continue; }
    if (UNIFORM_TO_EN.has(cp))   { a[i] = CP_EN; continue; }
  }
  return a;
}

/* ============================
   Common helpers
   ============================ */

function hexToRgba(hex, a = 1){
  const h = String(hex || "").trim().replace("#","");
  if (h.length !== 6) return `rgba(255,255,255,${a})`;
  const r = parseInt(h.slice(0,2), 16);
  const g = parseInt(h.slice(2,4), 16);
  const b = parseInt(h.slice(4,6), 16);
  return `rgba(${r},${g},${b},${a})`;
}

function rgbaOrHexToHex(value, fallback="#FFFFFF"){
  if(value === null) return fallback.toUpperCase();
  const s = String(value || "").trim();
  if (s.startsWith("#") && (s.length === 7)) return s;
  // parse rgba(r,g,b,a) -> hex (drop alpha)
  const m = s.match(/rgba?\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)(?:\s*,\s*([0-9.]+))?\s*\)/i);
  if (!m) return fallback.toUpperCase();
  const r = clamp(parseInt(m[1],10),0,255).toString(16).padStart(2,"0");
  const g = clamp(parseInt(m[2],10),0,255).toString(16).padStart(2,"0");
  const b = clamp(parseInt(m[3],10),0,255).toString(16).padStart(2,"0");
  return `#${r}${g}${b}`.toUpperCase();
}

function setTextQuality(ctx) {
  try { ctx.textRendering = "optimizeLegibility"; } catch (_) {}
  try { ctx.fontKerning = "normal"; } catch (_) {}
}

function normalizeTpWord(raw) {
  return String(raw ?? "").toLowerCase().replace(/[^a-z]/g, "");
}

// Glyph-key normalization for MULTI_LINE_WORD_TO_UCSUR_CP lookups
// Keeps: a-z plus ^ < > : , . and middle dot ·
function normalizeTpGlyphKey(raw) {
  return String(raw ?? "")
    .toLowerCase()
    .trim()
    .replace(/[^a-z^<>:,.·]/g, "");
}

function normalizeTpGlyphToken(raw) {
  const s0 = String(raw ?? "").trim().toLowerCase();
  if (!s0) return "";
  if (s0 === ":" || s0 === "·" || s0 === "," || s0 === ".") return s0;

  const stripped = s0.replace(/^[^a-z^<>:,.·]+|[^a-z^<>:,.·]+$/g, "");
  if (!stripped) return "";
  return normalizeTpGlyphKey(stripped);
}

/* ============================
   Long pi helpers
   ============================ */
function tokenHasOpenCurly(tok) { return String(tok ?? "").includes("{"); }
function tokenHasCloseCurly(tok){ return String(tok ?? "").includes("}"); }

function extractCurlyContentFromTokens(tokens, startIdx) {
  let j = startIdx;
  while (j < tokens.length && !tokenHasCloseCurly(tokens[j])) j++;
  if (j >= tokens.length) return null;

  const joined = tokens.slice(startIdx, j + 1).join(" ");
  const open = joined.indexOf("{");
  const close = joined.lastIndexOf("}");
  if (open < 0 || close < 0 || close <= open) return null;

  const inner = joined.slice(open + 1, close).trim();
  return { inner, endIndex: j };
}

function parseKnownTpWords(innerText) {
  const raw = String(innerText ?? "");
  const parts = raw.split(/\s+/).map(normalizeTpGlyphKey).filter(Boolean);
  const known = parts.filter(w => MULTI_LINE_WORD_TO_UCSUR_CP[w] != null);
  return known;
}

/* ============================
   Random letters → glyphs (used in [ ... ] cartouches when unknown words exist)
   - Optional. Remove if you do not need random mapping behaviour.
   ============================ */
function buildLetterBuckets() {
  const buckets = new Map();
  for (const w of Object.keys(MULTI_LINE_WORD_TO_UCSUR_CP)) {
    const k = String(w);
    if (!k) continue;
    const first = k[0].toLowerCase();
    if (!/^[a-z]$/.test(first)) continue;
    if (!buckets.has(first)) buckets.set(first, []);
    buckets.get(first).push(k);
  }
  return buckets;
}
const LETTER_BUCKETS = buildLetterBuckets();

function randInt(n) {
  if (n <= 0) return 0;
  if (globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
    const buf = new Uint32Array(1);
    globalThis.crypto.getRandomValues(buf);
    return buf[0] % n;
  }
  return Math.floor(Math.random() * n);
}

function randomGlyphCpForLetter(letter) {
  const l = String(letter ?? "").toLowerCase();
  const arr = LETTER_BUCKETS.get(l);
  if (!arr || arr.length === 0) return null;

  // Exclude convenience punctuation-words from random output (matches your current behavior)
  const banned = new Set(["ota", "kolon", "koma"]);
  const filtered = arr.filter(w => !banned.has(w));
  if (filtered.length === 0) return null;

  const word = filtered[randInt(filtered.length)];
  return MULTI_LINE_WORD_TO_UCSUR_CP[word] ?? null;
}

function lettersToRandomGlyphCps(letters) {
  const cps = [];
  const s = String(letters ?? "").toLowerCase().replace(/[^a-z]/g, "");
  for (const ch of s) {
    const cp = randomGlyphCpForLetter(ch);
    if (cp != null) cps.push(cp);
  }
  return cps;
}

/* ============================================================
   nanpa-linja-n tokenization + conversions (needed for cartouches)
   (This is the minimal dependency set for the cartouche parser in your pipeline.)
   ============================================================ */
const DIGIT_TOKENS = new Set(["NI","WE","TE","SE","NA","LE","NU","ME","PE","JE"]);
const TOKEN_PREFIXES = ["KEKEKE","KEKE","KE","NONONO","NONO","NE","NO"];

function nanpaCapsHasAtLeastOneDigitToken(tokens) {
  for (const t of (tokens ?? [])) if (DIGIT_TOKENS.has(t)) return true;
  return false;
}

function tokenizeNanpaCaps(caps) {
  const s = String(caps ?? "").trim().toUpperCase();
  if (!s) throw new Error("caps is empty");
  if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
  if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

  const tokens = [];
  let i = 0;
  const end = s.length;

  while (i < end - 1) {
    let matched = null;
    for (const pref of TOKEN_PREFIXES) {
      if (s.startsWith(pref, i)) { matched = pref; break; }
    }
    if (matched != null) { tokens.push(matched); i += matched.length; continue; }

    if (i + 2 <= end - 1) {
      const two = s.slice(i, i + 2);
      if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
    }

    throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
  }

  tokens.push("N");
  return tokens;
}

function isValidNanpaLinjanProperName(raw) {
  const s = String(raw ?? "").replace(/\s+/g, "");
  if (!s) return false;
  if (!/^[a-zA-Z]+$/.test(s)) return false;
  if (!/[nN]$/.test(s)) return false;

  const core = s.slice(0, -1);
  if (core.length < 2 || (core.length % 2) !== 0) return false;

  const caps = core.toUpperCase() + "N";
  if (!caps.startsWith("NE")) return false;

  try { tokenizeNanpaCaps(caps); return true; }
  catch { return false; }
}

const NUMBER_CODE_LETTER_TO_PAIR = {
  "I":"NI","W":"WE","T":"TE","S":"SE","A":"NA",
  "L":"LE","U":"NU","M":"ME","P":"PE","J":"JE"
};

function tryParseNanpaLinjanNumberCodeToCaps(raw) {
  const s0 = String(raw ?? "").trim().replace(/\s+/g, "");
  if (!s0) return null;
  if (!s0.toUpperCase().startsWith("#~")) return null;

  const body = s0.slice(2).toUpperCase();
  if (!body) throw new Error("Number code '#~' must have letters after it.");
  if (!/^[A-Z]+$/.test(body)) throw new Error("Number code may only contain letters A–Z after '#~'.");

  const tokens = ["NE"];
  let i = 0;

  function ensureNEBeforeOperatorRun() {
    if (tokens[tokens.length - 1] !== "NE") tokens.push("NE");
  }

  while (i < body.length) {
    const ch = body[i];

    if (ch === "O") {
      let j = i;
      while (j < body.length && body[j] === "O") j++;
      const count = j - i;
      if (count < 1 || count > 3) throw new Error("Invalid run of 'O' in number code (max 3).");

      if (count === 1) {
        if (i === 0) tokens.push("NO");
        else tokens.push("NO","NE");
      } else {
        tokens.push("NO".repeat(count)); // NONO / NONONO
      }

      i = j;
      continue;
    }

    if (ch === "K") {
      let j = i;
      while (j < body.length && body[j] === "K") j++;
      const count = j - i;
      if (count < 1 || count > 3) throw new Error("Invalid run of 'K' in number code (max 3).");

      ensureNEBeforeOperatorRun();
      tokens.push("KE".repeat(count)); // KE / KEKE / KEKEKE
      i = j;
      continue;
    }

    const pair = NUMBER_CODE_LETTER_TO_PAIR[ch];
    if (!pair) throw new Error(`Invalid letter '${ch}' in number code.`);
    tokens.push(pair);
    i += 1;
  }

  tokens.push("N");
  const caps = tokens.join("");
  tokenizeNanpaCaps(caps);
  return { caps };
}

const TOKEN_TO_DIGIT_WORD = {
  "NI":"ijo","WE":"wan","TE":"tu","SE":"seli","NA":"awen",
  "LE":"luka","NU":"utala","ME":"mun","PE":"pipi","JE":"jo"
};
const WORD_FOR_NEGATIVE_SIGN = "ona";

function nanpaCapsTokensToTpWords(tokens, { mode = "uniform" } = {}) {
  if (!tokens || tokens.length === 0) return [];

  const uniform = (mode === "uniform");
  const out = [];

  const E_WORD = uniform ? "en" : "esun";
  const E_WORD_FOR_NE_AFTER_START = uniform ? "en" : "e";
  const N_WORD = uniform ? "nena" : "nasa";

  const N_WORD_DECIMAL_POINT = uniform ? "nena" : "ni";
  const N_END_WORD = "nanpa";

  let afterStartingNe = false;

  for (let i = 0; i < tokens.length; i++) {
    const t = tokens[i];

    if (t === "NE") {
      if (out.length === 0) {
        out.push("nanpa", E_WORD);
        afterStartingNe = true;
      } else {
        out.push(N_WORD, E_WORD_FOR_NE_AFTER_START);
        afterStartingNe = false;
      }
      continue;
    }

    if (DIGIT_TOKENS.has(t)) {
      afterStartingNe = false;
      const digitWord = TOKEN_TO_DIGIT_WORD[t];
      if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
      else out.push(digitWord, E_WORD);
      continue;
    }

    if (t === "NO") {
      if (afterStartingNe) {
        out.push(N_WORD, WORD_FOR_NEGATIVE_SIGN);
        afterStartingNe = false;
        continue;
      }

      const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
      if (nxt === "NE") {
        out.push(N_WORD_DECIMAL_POINT, "o", N_WORD, E_WORD_FOR_NE_AFTER_START);
        afterStartingNe = false;
        i += 1;
        continue;
      }

      out.push(N_WORD_DECIMAL_POINT, "o");
      afterStartingNe = false;
      continue;
    }

    if (t === "NONO") { out.push("nena","o","nena","o"); afterStartingNe=false; continue; }
    if (t === "NONONO") { out.push(N_WORD,"o",N_WORD,"o",N_WORD,"o"); afterStartingNe=false; continue; }

    if (t === "KE")     { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
    if (t === "KEKE")   { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
    if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

    if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

    throw new Error(`Unknown token "${t}"`);
  }

  return out;
}

function nanpaCapsToNanpaLinjanCodepoints(caps, { mode = "uniform" } = {}) {
  const tokens = tokenizeNanpaCaps(caps);
  if (!nanpaCapsHasAtLeastOneDigitToken(tokens)) return null;

  const tpWords = nanpaCapsTokensToTpWords(tokens, { mode });

  const cps = [];
  for (const w of tpWords) {
    const cp = NANPA_LINJA_N_WORD_TO_CP[w];
    if (cp == null) return null;
    cps.push(cp);
  }

  if (mode === "uniform") return uniformizeNanpaLinjanCartoucheCps(cps);
  return cps;
}

function tryDecodeNanpaLinjanIdentifierToCodepoints(rawText, { mode = "uniform" } = {}) {
  const s = String(rawText ?? "").trim();
  if (!s) return null;

  try {
    const parsed = tryParseNanpaLinjanNumberCodeToCaps(s);
    if (parsed?.caps) return nanpaCapsToNanpaLinjanCodepoints(parsed.caps, { mode });
  } catch {
    return null;
  }

  if (!isValidNanpaLinjanProperName(s)) return null;

  const compact = s.replace(/\s+/g, "");
  const core = compact.slice(0, -1);
  const caps = core.toUpperCase() + "N";
  return nanpaCapsToNanpaLinjanCodepoints(caps, { mode });
}

/* ============================================================
   Minimal scanners for cartouche triggers in plain text:
   - Decimals: findDecimalSequencesWithCaps
   - #~ code:  findNumberCodeSequencesWithCaps
   - Proper:   findNanpaLinjanProperNameSequencesWithCaps
   - TP phrase:findNanpaLinjanTpPhraseSequences
   NOTE: These are the same style as your page; if you want a smaller feature set,
         delete what you do not need and remove callers in parseTextSegmentToElements.
   ============================================================ */
const VULGAR_FRACTIONS = new Map([
  ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
  ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
  ["⅓", [1, 3]], ["⅔", [2, 3]],
  ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
  ["⅙", [1, 6]], ["⅚", [5, 6]],
  ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
  ["↉", [0, 3]],
]);

function normalizeVulgarFractionInput(raw) {
  if (raw == null) return "";
  let s = String(raw).trim();
  if (!s) return s;

  s = s.replace(/\u2044/g, "/");

  let found = null;
  for (const ch of s) {
    if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
  }
  if (!found) return s;

  const lastChar = s.slice(-1);
  if (!VULGAR_FRACTIONS.has(lastChar)) {
    throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
  }

  const [num, den] = VULGAR_FRACTIONS.get(lastChar);
  const prefixRaw = s.slice(0, -1).trim();

  if (!prefixRaw) return `${num}/${den}`;

  const isNeg = prefixRaw.startsWith("-");
  const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;
  if (!prefix) return `-${num}/${den}`;

  return isNeg ? `-${prefix}+${num}/${den}` : `${prefix}+${num}/${den}`;
}

function looksLikeNanpaCaps(s) {
  const t = String(s ?? "").trim();
  if (!t) return false;
  if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
  return t.slice(0, 2).toUpperCase() === "NE";
}

function normalizeLooseSeparators(raw) {
  if (raw == null) return "";
  let s = String(raw);
  s = s.replace(/[−‒–—]/g, "-");
  const isNeg = s.startsWith("-");
  const head = isNeg ? "-" : "";
  const rest = isNeg ? s.slice(1) : s;
  let r = rest.replace(/\s+/g, " ");
  r = r.replace(/-+/g, "-");
  return (head + r).trim();
}

const DEC_DIGIT_TO_TOKEN = {
  "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
  "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
};

function numberStrToNanpaCaps(s) {
  let raw = normalizeLooseSeparators(String(s ?? ""));
  if (!raw) throw new Error("Empty value cannot be encoded");

  function stripFinalTerminator(segCaps) {
    if (!segCaps) return segCaps;
    if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
    return segCaps.slice(0, -1);
  }

  function encodeSingleNumberSegment(segment, includeInitialNe) {
    let seg = String(segment).trim();
    if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

    const out = [];
    if (includeInitialNe) out.push("NE");

    function pushNene() {
      const L = out.length;
      if (L >= 2 && out[L-2] === "NE" && out[L-1] === "NE") return;
      out.push("NE", "NE");
    }

    if (seg.startsWith("-")) {
      if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
      out.push("NO");
      seg = seg.slice(1).trim();
    }

    // optional magnitude suffix K/T/M/B -> 1/1/2/3 KE counts
    let magnitudeSuffixKeCount = 0;
    if (seg.length > 0) {
      const last = seg.slice(-1).toUpperCase();
      if (last === "K" || last === "T" || last === "M" || last === "B") {
        magnitudeSuffixKeCount =
          (last === "K" || last === "T") ? 1 :
          (last === "M") ? 2 : 3;
        seg = seg.slice(0, -1).trim();
        if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
      }
    }

    if ((seg.match(/\./g) || []).length > 1) {
      throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
    }

    let intPart = seg;
    let fracPart = "";
    let hasDecimal = false;
    if (seg.includes(".")) {
      [intPart, fracPart] = seg.split(".", 2);
      hasDecimal = true;
    }

    let ip = String(intPart ?? "").trim();
    if (ip === "") ip = "0";

    // integer: allow digits, separators , _ space -
    for (const ch of ip) {
      if (/\d/.test(ch)) { out.push(DEC_DIGIT_TO_TOKEN[ch]); continue; }
      if (ch === "," ) { out.push("NE","KE"); continue; }
      if (ch === "_" || ch === " " || ch === "-") { pushNene(); continue; }
      throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
    }

    if (hasDecimal) {
      out.push("NO","NE");
      if (!fracPart) throw new Error(`Missing fraction digits after '.' in "${s}"`);
      for (const ch of fracPart) {
        if (/\d/.test(ch)) { out.push(DEC_DIGIT_TO_TOKEN[ch]); continue; }
        if (ch === "_" || ch === "," || ch === " " || ch === "-") { pushNene(); continue; }
        throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
      }
    }

    if (magnitudeSuffixKeCount > 0) {
      out.push("NE");
      let remaining = magnitudeSuffixKeCount;
      while (remaining > 0) {
        const chunk = Math.min(3, remaining);
        if (out[out.length - 1] !== "NE") out.push("NE");
        out.push("KE".repeat(chunk));
        remaining -= chunk;
        if (remaining > 0) out.push("NE");
      }
    }

    out.push("N");
    return out.join("");
  }

  // mixed number a+b/c
  if (raw.includes("+")) {
    const [left, right] = raw.split("+", 2);
    let leftCaps = encodeSingleNumberSegment(left, true);

    if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
    const [num, den] = right.split("/", 2);

    let numCaps = encodeSingleNumberSegment(num, false);
    let denCaps = encodeSingleNumberSegment(den, false);

    leftCaps = stripFinalTerminator(leftCaps);
    numCaps  = stripFinalTerminator(numCaps);

    return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
  }

  // fraction a/b
  if (raw.includes("/")) {
    const [num, den] = raw.split("/", 2);
    let numCaps = encodeSingleNumberSegment(num, true);
    let denCaps = encodeSingleNumberSegment(den, false);
    numCaps = stripFinalTerminator(numCaps);
    return numCaps + "NONO" + denCaps;
  }

  return encodeSingleNumberSegment(raw, true);
}

function decimalStringToCaps(rawDecimal) {
  const normalized = normalizeVulgarFractionInput(rawDecimal);
  const caps = looksLikeNanpaCaps(normalized)
    ? normalized.toUpperCase()
    : numberStrToNanpaCaps(normalized);

  tokenizeNanpaCaps(caps);
  return caps;
}

function findDecimalSequencesWithCaps(text) {
  const original = String(text ?? "");
  if (!original) return [];

  const s = original.replace(/[−‒–—]/g, "-");

  const vulgarChars = "¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞↉";
  const re = new RegExp(
    String.raw`(?<![A-Za-z])` +
    String.raw`(` +
      String.raw`-?\s*\d*\s*[${vulgarChars}]` +
      "|" +
      String.raw`-?\s*\d[\d, _-]*\s*\+\s*\d[\d, _-]*\s*\/\s*\d[\d, _-]*` +
      "|" +
      String.raw`-?\s*\d[\d, _-]*\s*\/\s*\d[\d, _-]*` +
      "|" +
      String.raw`-?\s*(?:\d[\d, _-]*|\.\d+)(?:\.\d[\d, _-]*)?(?:\s*[kKtTmMbB])?` +
    String.raw`)` +
    String.raw`(?![A-Za-z])`,
    "g"
  );

  const results = [];
  let m;

  while ((m = re.exec(s)) !== null) {
    const rawMatch = m[1];
    if (!rawMatch) continue;

    let candidate = rawMatch.trim().replace(/[)\]}.,;:!?]+$/g, "").trim();
    if (!candidate) continue;
    if (candidate === "-" || candidate === "+") continue;

    const rel = rawMatch.indexOf(candidate);
    const start = (rel >= 0) ? (m.index + rel) : m.index;
    const end = start + candidate.length;

    try {
      const caps = decimalStringToCaps(candidate);
      results.push({ kind: "decimal", match: candidate, index: start, end, caps });
    } catch {
      // ignore
    }
  }

  results.sort((a, b) => a.index - b.index || b.end - a.end);
  const filtered = [];
  let lastEnd = -1;
  for (const r of results) {
    if (r.index < lastEnd) continue;
    filtered.push(r);
    lastEnd = r.end;
  }
  return filtered;
}

function findNumberCodeSequencesWithCaps(text) {
  const s = String(text ?? "");
  if (!s) return [];

  const re = /#~[A-Za-z]+/g;
  const out = [];
  let m;

  while ((m = re.exec(s)) !== null) {
    const raw = m[0];
    if (!raw) continue;

    const start = m.index | 0;
    const end = start + raw.length;

    try {
      const parsed = tryParseNanpaLinjanNumberCodeToCaps(raw);
      if (parsed?.caps) out.push({ kind: "code", index: start, end, caps: parsed.caps });
    } catch {
      // ignore
    }
  }

  return out;
}

function findNanpaLinjanProperNameSequencesWithCaps(text) {
  const s = String(text ?? "");
  if (!s) return [];

  const re = /(^|[^A-Za-z])((?:ne)[A-Za-z]*(?:\s+[A-Za-z]{2,}){0,20}[A-Za-z]*[nN])(?![A-Za-z])/gi;

  const hits = [];
  let m;

  while ((m = re.exec(s)) !== null) {
    const lead = m[1] ?? "";
    const rawMatch = m[2] ?? "";
    if (!rawMatch) continue;

    const start = (m.index | 0) + lead.length;
    const end = start + rawMatch.length;

    const compact = rawMatch.replace(/\s+/g, "");
    if (compact.length < 5) continue;
    if (!isValidNanpaLinjanProperName(compact)) continue;

    const core = compact.slice(0, -1);
    const caps = core.toUpperCase() + "N";

    hits.push({ kind: "name", index: start, end, caps });
  }

  return hits;
}

function findNanpaLinjanTpPhraseSequences(text) {
  const s = String(text ?? "");
  if (!s) return [];

  const tokens = [];
  const reTok = /\S+/g;
  let m;
  while ((m = reTok.exec(s)) !== null) {
    const raw = m[0];
    tokens.push({
      raw,
      norm: normalizeTpWord(raw),
      start: m.index,
      end: (m.index + raw.length)
    });
  }
  if (tokens.length < 3) return [];

  const digitWords = new Set(Object.values(TOKEN_TO_DIGIT_WORD));
  const hits = [];

  for (let i = 0; i < tokens.length - 2; i++) {
    if (tokens[i].norm !== "nanpa") continue;
    const n1 = tokens[i + 1]?.norm;
    if (!(n1 === "esun" || n1 === "en")) continue;

    let bestJ = -1;
    let bestWords = null;

    for (let j = i + 2; j < tokens.length; j++) {
      if (tokens[j].norm !== "nanpa") continue;

      const words = [];
      let allOk = true;
      let hasDigit = false;

      for (let k = i; k <= j; k++) {
        const w = tokens[k].norm;
        if (!w) { allOk = false; break; }
        if (NANPA_LINJA_N_WORD_TO_CP[w] == null) { allOk = false; break; }
        if (k >= i + 2 && k <= j - 1 && digitWords.has(w)) hasDigit = true;
        words.push(w);
      }

      if (!allOk || !hasDigit) continue;

      bestJ = j;
      bestWords = words;
    }

    if (bestJ >= 0 && bestWords) {
      hits.push({
        kind: "tpPhrase",
        index: tokens[i].start,
        end: tokens[bestJ].end,
        words: bestWords
      });
      i = bestJ;
    }
  }

  return hits;
}

function mergeAndGreedyFilterHits(allHits) {
  const hits = Array.from(allHits ?? []).filter(h =>
    h &&
    Number.isFinite(h.index) &&
    Number.isFinite(h.end) &&
    h.end > h.index &&
    (h.caps || (Array.isArray(h.words) && h.words.length > 0))
  );

  function priority(kind) {
    if (kind === "decimal") return 4;
    if (kind === "tpPhrase") return 3;
    if (kind === "code") return 2;
    return 1; // proper name
  }

  hits.sort((a, b) => {
    if (a.index !== b.index) return a.index - b.index;
    const la = (a.end - a.index);
    const lb = (b.end - b.index);
    if (la !== lb) return lb - la;
    return priority(b.kind) - priority(a.kind);
  });

  const out = [];
  let lastEnd = -1;

  for (const h of hits) {
    if (h.index < lastEnd) continue;
    out.push(h);
    lastEnd = h.end;
  }

  return out;
}

function nanpaLinjanWordsToCodepoints(words, { mode = "uniform" } = {}) {
  const cps = [];
  for (const w0 of (words ?? [])) {
    const w = normalizeTpWord(w0);
    const cp = NANPA_LINJA_N_WORD_TO_CP[w];
    if (cp == null) return null;
    cps.push(cp);
  }
  if (mode === "uniform") return uniformizeNanpaLinjanCartoucheCps(cps);
  return cps;
}

function tpWordsToCodepoints(wordsOrTokens) {
  const cps = [];
  for (const w of (wordsOrTokens ?? [])) {
    const cp = MULTI_LINE_WORD_TO_UCSUR_CP[w];
    if (cp != null) cps.push(cp);
  }
  return cps;
}

/* ============================================================
   Segment splitting: plain text, [bracket], "quote"
   ============================================================ */
function splitLineIntoSegments(line) {
  const s = String(line ?? "");
  const out = [];

  let i = 0;
  function pushTextSegment(txt) { if (txt) out.push({ kind: "text", value: txt }); }

  while (i < s.length) {
    const ch = s[i];

    if (ch === "[") {
      const j = s.indexOf("]", i + 1);
      if (j < 0) { pushTextSegment(s.slice(i)); break; }
      pushTextSegment(s.slice(i, i)); // no-op, kept from your structure
      out.push({ kind: "bracket", value: s.slice(i + 1, j) });
      i = j + 1;
      continue;
    }

    if (ch === '"') {
      let j = i + 1;
      let found = false;
      while (j < s.length) {
        if (s[j] === '"' && s[j - 1] !== "\\") { found = true; break; }
        j++;
      }
      if (!found) { pushTextSegment(s.slice(i)); break; }
      out.push({ kind: "quote", value: s.slice(i + 1, j) });
      i = j + 1;
      continue;
    }

    let j = i;
    while (j < s.length && s[j] !== "[" && s[j] !== '"') j++;
    pushTextSegment(s.slice(i, j));
    i = j;
  }

  return out;
}

/* ============================================================
   Elements model + builders
   ============================================================ */
function pushGapIfNeeded(elements, px) {
  if (elements.length === 0) return;
  const last = elements[elements.length - 1];
  if (last && last.type === "gap") return;
  elements.push({ type: "gap", px: px });
}

function renderFontCartoucheToCanvas(canvas, innerCps, { fontPx, padPx, fontFamily, fgCss }) {
  if (!canvas) throw new Error("renderFontCartoucheToCanvas: canvas missing");
  if (!innerCps || innerCps.length === 0) return { w: 0, h: 0, baselineY: 0 };

  const px = fontPx;
  const pad = padPx;
  const fam = fontFamily || FONT_FAMILY_TEXT;

  const run =
    String.fromCodePoint(CARTOUCHE_START_CP) +
    innerCps.map(cp => String.fromCodePoint(cp)).join("") +
    String.fromCodePoint(CARTOUCHE_END_CP);

  const ctx = canvas.getContext("2d");
  ctx.textBaseline = "alphabetic";
  ctx.font = `${px}px "${fam}"`;
  setTextQuality(ctx);
  const m = ctx.measureText(run);

  const ascent  = (m.actualBoundingBoxAscent  != null) ? m.actualBoundingBoxAscent  : Math.ceil(px * 0.95);
  const descent = (m.actualBoundingBoxDescent != null) ? m.actualBoundingBoxDescent : Math.ceil(px * 0.35);

  const left  = (m.actualBoundingBoxLeft  != null) ? m.actualBoundingBoxLeft  : 0;
  const right = (m.actualBoundingBoxRight != null) ? m.actualBoundingBoxRight : Math.ceil(m.width);

  const w = Math.max(1, Math.ceil(left + right + pad * 2));
  const h = Math.max(1, Math.ceil(ascent + descent + pad * 2));

  canvas.width = w;
  canvas.height = h;

  const ctx2 = canvas.getContext("2d", { alpha: true });
  ctx2.clearRect(0, 0, w, h);
  ctx2.textBaseline = "alphabetic";
  ctx2.font = `${px}px "${fam}"`;
  setTextQuality(ctx2);

  ctx2.fillStyle = fgCss || "#111";

  const x = pad + left;
  const baselineY = pad + ascent;

  ctx2.fillText(run, x, baselineY);

  return { w, h, baselineY };
}

function makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily, fgCss }) {
  if (!cps || cps.length === 0) return;
  pushGapIfNeeded(elements, WORD_GAP_PX);

  const cart = document.createElement("canvas");
  const padPx = Math.max(4, Math.round(fontPx * 0.11));

  const r = renderFontCartoucheToCanvas(cart, cps, { fontPx, padPx, fontFamily, fgCss });
  if ((r.w | 0) <= 0 || (r.h | 0) <= 0) return;

  const baselineY = r.baselineY | 0;
  const ascent = baselineY;
  const descent = (r.h | 0) - baselineY;

  elements.push({
    type: "cartouche",
    canvas: cart,
    w: r.w,
    h: r.h,
    baselineY,
    ascent,
    descent,
    fontFamily: fontFamily || FONT_FAMILY_TEXT
  });
}

function makeRunElementFromCodepoints(elements, cps, { fontPx, fontFamily }) {
  if (!cps || cps.length === 0) return;
  pushGapIfNeeded(elements, WORD_GAP_PX);
  elements.push({
    type: "run",
    cps: Array.from(cps),
    px: fontPx,
    fontFamily: fontFamily || FONT_FAMILY_TEXT
  });
}

function makeLiteralTextElement(elements, text, { fontPx, fontFamily }) {
  const s = String(text ?? "");
  if (!s) return;
  pushGapIfNeeded(elements, WORD_GAP_PX);
  elements.push({
    type: "text",
    text: s,
    px: fontPx,
    fontFamily: fontFamily || FONT_FAMILY_LITERAL
  });
}

/* ============================================================
   Token rendering for plain text segments (words + punctuation)
   ============================================================ */
function renderTpWordsFromText(text, elements, { fontPx, mode }) {
  const rawTokens = String(text ?? "").trim().split(/\s+/).filter(Boolean);

  function emitPunctGlyph(ch) {
    if (ch !== ":" && ch !== "·" && ch !== "," && ch !== ".") return false;
    const cp = MULTI_LINE_WORD_TO_UCSUR_CP[ch];
    if (cp == null) return false;
    pushGapIfNeeded(elements, WORD_GAP_PX);
    elements.push({ type: "glyph", cp, px: fontPx, fontFamily: FONT_FAMILY_TEXT });
    return true;
  }

  function splitTokenPunct(tok) {
    const s = String(tok ?? "");
    if (!s) return { lead: "", core: "", trail: "" };

    const numericLike =
      /[0-9]/.test(s) ||
      /^-?\.\d/.test(s) ||
      /^-?\d/.test(s);

    const coreChar = numericLike
      ? /[#~A-Za-z0-9^<>.,_-]/
      : /[#~A-Za-z0-9^<>]/;

    let a = 0;
    let b = s.length;

    while (a < b && !coreChar.test(s[a])) a++;
    while (b > a && !coreChar.test(s[b - 1])) b--;

    // strip typical sentence punctuation at end of token
    while (b > a && /[)\]}.,;:!?]+$/.test(s.slice(b - 1, b))) b--;

    return { lead: s.slice(0, a), core: s.slice(a, b), trail: s.slice(b) };
  }

  for (let i = 0; i < rawTokens.length; i++) {
    const tok = rawTokens[i];
    const normTok = normalizeTpWord(tok);

    // long pi: pi { ... }
    if (normTok === "pi") {
      const nextTok = rawTokens[i + 1];
      if (nextTok != null && tokenHasOpenCurly(nextTok)) {
        const extracted = extractCurlyContentFromTokens(rawTokens, i + 1);
        if (extracted && extracted.inner != null) {
          const innerWords = parseKnownTpWords(extracted.inner);
          if (innerWords.length >= 2) {
            const cps = [];
            cps.push(LONG_PI_START_CP);
            cps.push(MULTI_LINE_WORD_TO_UCSUR_CP[innerWords[0]]);
            for (let k = 1; k < innerWords.length; k++) {
              cps.push(LONG_PI_EXT_CP);
              cps.push(MULTI_LINE_WORD_TO_UCSUR_CP[innerWords[k]]);
            }
            makeRunElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_TEXT });
            i = extracted.endIndex;
            continue;
          }
        }
      }
    }

    const { lead, core, trail } = splitTokenPunct(tok);
    for (const ch of lead) emitPunctGlyph(ch);

    const trimmed = core;

    // identifier cartouche: #~... or NE...n proper-name
    if (trimmed) {
      const idCps =
        tryDecodeNanpaLinjanIdentifierToCodepoints(trimmed, { mode }) ??
        tryDecodeNanpaLinjanIdentifierToCodepoints(trimmed.replace(/\s+/g, ""), { mode });

      if (idCps && idCps.length) {
        makeCartoucheElementFromCodepoints(elements, idCps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE });
        for (const ch of trail) emitPunctGlyph(ch);
        continue;
      }
    }

    // normal word glyph
    const glyphKey = normalizeTpGlyphKey(trimmed);
    if (glyphKey && MULTI_LINE_WORD_TO_UCSUR_CP[glyphKey] != null) {
      pushGapIfNeeded(elements, WORD_GAP_PX);
      elements.push({ type: "glyph", cp: MULTI_LINE_WORD_TO_UCSUR_CP[glyphKey], px: fontPx, fontFamily: FONT_FAMILY_TEXT });
    }

    for (const ch of trail) emitPunctGlyph(ch);
  }
}

/* ============================================================
   Segment parsers: text / bracket / quote
   ============================================================ */
function parseTextSegmentToElements(segmentText, elements, { fontPx, mode, fgCss = "#111" ,literalFontFamily}) {
  const s = String(segmentText ?? "");
  if (!s.trim()) return;

  const decHits    = findDecimalSequencesWithCaps(s);
  const codeHits   = findNumberCodeSequencesWithCaps(s);
  const nameHits   = findNanpaLinjanProperNameSequencesWithCaps(s);
  const phraseHits = findNanpaLinjanTpPhraseSequences(s);

  const hits = mergeAndGreedyFilterHits([...decHits, ...phraseHits, ...codeHits, ...nameHits]);

  if (!hits || hits.length === 0) {
    renderTpWordsFromText(s, elements, { fontPx, mode });
    return;
  }

  let pos = 0;

  for (const h of hits) {
    const a = Math.max(0, h.index | 0);
    const b = Math.max(a, h.end | 0);

    if (a > pos) {
      renderTpWordsFromText(s.slice(pos, a), elements, { fontPx, mode });
    }

    if (h.kind === "tpPhrase") {
      const cps = nanpaLinjanWordsToCodepoints(h.words, { mode });
      if (cps && cps.length) {
        makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
      } else {
        renderTpWordsFromText(s.slice(a, b), elements, { fontPx, mode });
      }
    } else {
      const cps = nanpaCapsToNanpaLinjanCodepoints(h.caps, { mode });
      if (cps && cps.length) {
        makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
      } else {
        renderTpWordsFromText(s.slice(a, b), elements, { fontPx, mode });
      }
    }

    pos = b;
  }

  if (pos < s.length) {
    renderTpWordsFromText(s.slice(pos), elements, { fontPx, mode });
  }
}

function parseQuoteSegmentToElements(quoteContent, elements, { fontPx, literalFontFamily } = {}) {
  const raw = String(quoteContent ?? "");
  let literal = raw.replace(/\\"/g, '"').replace(/\\\\/g, "\\");
  literal = literal.replace(/\t/g, "    ");
  if (literal.length === 0) return;

  const fam = String(literalFontFamily ?? "").trim() || FONT_FAMILY_LITERAL;
  makeLiteralTextElement(elements, literal, { fontPx, fontFamily: fam });
}


function parseBracketSegmentToElements(bracketContent, elements, { fontPx, mode, fgCss = "#111", literalFontFamily }) {
  const content = String(bracketContent ?? "").trim();
  if (!content) return;

  // try decimal cartouche first
  try {
    const caps = decimalStringToCaps(content);
    const cps = nanpaCapsToNanpaLinjanCodepoints(caps, { mode });
    if (cps && cps.length) {
      makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
      return;
    }
  } catch {}

  // try identifier cartouche
  const idCps =
    tryDecodeNanpaLinjanIdentifierToCodepoints(content, { mode }) ??
    tryDecodeNanpaLinjanIdentifierToCodepoints(content.replace(/\s+/g, ""), { mode });

  if (idCps && idCps.length) {
    makeCartoucheElementFromCodepoints(elements, idCps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
    return;
  }

  // if all tokens are known tp glyph-tokens -> cartouche using their glyphs
  const wordsRaw = content.split(/\s+/).filter(Boolean);
  const glyphTokens = wordsRaw.map(normalizeTpGlyphToken).filter(Boolean);
  if (glyphTokens.length >= 1 && glyphTokens.every(isKnownTpWordKey)) {
    makeCartoucheElementFromCodepoints(elements, tpWordsToCodepoints(glyphTokens), { fontPx, fontFamily: FONT_FAMILY_TEXT, fgCss });
    return;
  }

  // fallback: random letters → glyph cartouche
  makeCartoucheElementFromCodepoints(elements, lettersToRandomGlyphCps(content), { fontPx, fontFamily: FONT_FAMILY_TEXT, fgCss });
}

/* ============================================================
   Line parsing: line → elements
   ============================================================ */
function lineToElements(line, { fontPx, mode = "uniform", fgCss = "#111", literalFontFamily } = {}) {
  const segs = splitLineIntoSegments(line);
  const elements = [];

  for (const seg of segs) {
    if (seg.kind === "text") {
      parseTextSegmentToElements(seg.value, elements, { fontPx, mode, fgCss, literalFontFamily });
    } else if (seg.kind === "bracket") {
      parseBracketSegmentToElements(seg.value, elements, { fontPx, mode, fgCss, literalFontFamily });
    } else if (seg.kind === "quote") {
      parseQuoteSegmentToElements(seg.value, elements, { fontPx, literalFontFamily });
    }
  }

  while (elements.length > 0 && elements[elements.length - 1].type === "gap") elements.pop();
  return elements;
}

function parseMultilineToElements(multilineText, { fontPx, mode = "uniform", fgCss = "#111", literalFontFamily } = {}) {
  const raw = String(multilineText ?? "");
  const lines = raw.replace(/\r\n/g, "\n").split("\n");
  return lines.map(line => lineToElements(line, { fontPx, mode, fgCss, literalFontFamily }));
}

/* ============================================================
   Measuring primitives (used by bounding box and rendering)
   ============================================================ */
function measureTextRun(ctx, text, px, fontFamily) {
  const chars = String(text ?? "");
  ctx.font = `${px}px "${fontFamily}"`;
  setTextQuality(ctx);
  const m = ctx.measureText(chars);

  const ascent  = (m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8));
  const descent = (m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2));
  const w = Math.ceil(m.width);

  return { chars, ascent, descent, left: 0, w, h: Math.ceil(ascent + descent), px, fontFamily };
}

function measureGlyph(ctx, cp, px, fontFamily) {
  const ch = String.fromCodePoint(cp);
  ctx.font = `${px}px "${fontFamily}"`;
  setTextQuality(ctx);
  const m = ctx.measureText(ch);

  const ascent  = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
  const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

  const left = m.actualBoundingBoxLeft ?? 0;
  const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
  const tightW = Math.ceil(left + right);

  return { ch, ascent, descent, left, w: tightW, h: Math.ceil(ascent + descent), px, fontFamily };
}

function measureRun(ctx, cps, px, fontFamily) {
  const chars = (cps ?? []).map(cp => String.fromCodePoint(cp)).join("");
  ctx.font = `${px}px "${fontFamily}"`;
  setTextQuality(ctx);
  const m = ctx.measureText(chars);

  const ascent  = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
  const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

  const left = m.actualBoundingBoxLeft ?? 0;
  const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
  const tightW = Math.ceil(left + right);

  return { chars, ascent, descent, left, w: tightW, h: Math.ceil(ascent + descent), px, fontFamily };
}

/* ============================================================
   BOUNDING BOX: measure multi-line before drawing
   Returns: { width, height, padPx, lineGapPx, lines:[...lineMetrics...] }
   ============================================================ */
function measureMultiline(linesElements, { fontPx, padPx = DEFAULT_PAD_PX, lineGapPx = LINE_GAP_PX } = {}) {
  const tmp = document.createElement("canvas");
  const ctx = tmp.getContext("2d");
  ctx.textBaseline = "alphabetic";

  const measuredLines = [];
  let maxLineW = 0;
  let totalH = 0;

  for (const lineEls of (linesElements ?? [])) {
    let w = 0;
    let maxAscent = 0;
    let maxDescent = 0;

    const measuredEls = [];

    for (const el of lineEls) {
      if (el.type === "text") {
        const fam = el.fontFamily || FONT_FAMILY_LITERAL;
        const r = measureTextRun(ctx, el.text, el.px ?? fontPx, fam);
        measuredEls.push({ ...el, m: r });
        w += r.w;
        if (r.ascent > maxAscent) maxAscent = r.ascent;
        if (r.descent > maxDescent) maxDescent = r.descent;
        continue;
      }

      if (el.type === "gap") {
        measuredEls.push(el);
        w += Math.max(0, el.px | 0);
        continue;
      }

      if (el.type === "glyph") {
        const fam = el.fontFamily || FONT_FAMILY_TEXT;
        const g = measureGlyph(ctx, el.cp, el.px ?? fontPx, fam);
        measuredEls.push({ ...el, m: g });
        w += g.w;
        if (g.ascent > maxAscent) maxAscent = g.ascent;
        if (g.descent > maxDescent) maxDescent = g.descent;
        continue;
      }

      if (el.type === "run") {
        const fam = el.fontFamily || FONT_FAMILY_TEXT;
        const r = measureRun(ctx, el.cps, el.px ?? fontPx, fam);
        measuredEls.push({ ...el, m: r });
        w += r.w;
        if (r.ascent > maxAscent) maxAscent = r.ascent;
        if (r.descent > maxDescent) maxDescent = r.descent;
        continue;
      }

      if (el.type === "cartouche") {
        measuredEls.push(el);
        w += (el.w | 0);

        const a = el.ascent ?? Math.ceil((el.h | 0) * 0.7);
        const d = el.descent ?? Math.ceil((el.h | 0) * 0.3);

        if (a > maxAscent) maxAscent = a;
        if (d > maxDescent) maxDescent = d;
        continue;
      }
    }

    const lineBoxH = Math.max(maxAscent + maxDescent, fontPx);
    measuredLines.push({ measuredEls, w, lineBoxH, maxAscent, maxDescent });

    if (w > maxLineW) maxLineW = w;
    totalH += lineBoxH;
  }

  totalH += Math.max(0, (measuredLines.length - 1) * lineGapPx);

  const width  = Math.max(1, Math.ceil(maxLineW + padPx * 2));
  const height = Math.max(1, Math.ceil(totalH  + padPx * 2));

  return { width, height, padPx, lineGapPx, lines: measuredLines };
}


/* ============================================================
   DRAW: render multi-line to a canvas (also computes bounding box)
   ============================================================ */
function renderMultilineToCanvas(outCanvas, linesElements, { fontPx, fgCss = "#111", padPx = DEFAULT_PAD_PX, lineGapPx = LINE_GAP_PX, literalFontAlignment = "left" } = {}) {
  if (!outCanvas) throw new Error("renderMultilineToCanvas: outCanvas missing");

  const box = measureMultiline(linesElements, { fontPx, padPx, lineGapPx });
  outCanvas.width = box.width;
  outCanvas.height = box.height;

  const outCtx = outCanvas.getContext("2d", { alpha: true });
  outCtx.clearRect(0, 0, outCanvas.width, outCanvas.height);
  outCtx.textBaseline = "alphabetic";
  outCtx.fillStyle = fgCss;
  setTextQuality(outCtx);

  let y = box.padPx;

  for (let li = 0; li < box.lines.length; li++) {
    const L = box.lines[li];
    let x = box.padPx;

    //we can use alignment here to push x to the right  ??????????????
    //we get the line width from L
    const lineWidth = L.w;
    //we calculate extra space on this line
    const extraSpaceOnLine = Math.max( 0, box.width - lineWidth - box.padPx * 2 );
    //we push the starting x over depending on alignment
    if (literalFontAlignment === "center") x = x + extraSpaceOnLine / 2;
    if (literalFontAlignment === "right")  x = x + extraSpaceOnLine;


    const glyphBaseline = y + L.maxAscent;

    for (const el of L.measuredEls) {
      if (el.type === "text") {
        const m = el.m;
        const fam = el.fontFamily || FONT_FAMILY_LITERAL;
        outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
        outCtx.fillText(m.chars, x, glyphBaseline);
        x += m.w;
        continue;
      }

      if (el.type === "gap") { x += Math.max(0, el.px | 0); continue; }

      if (el.type === "glyph") {
        const m = el.m;
        const fam = el.fontFamily || FONT_FAMILY_TEXT;
        outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
        const drawX = x + (m.left ?? 0);
        outCtx.fillText(m.ch, drawX, glyphBaseline);
        x += m.w;
        continue;
      }

      if (el.type === "run") {
        const m = el.m;
        const fam = el.fontFamily || FONT_FAMILY_TEXT;
        outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
        const drawX = x + (m.left ?? 0);
        outCtx.fillText(m.chars, drawX, glyphBaseline);
        x += m.w;
        continue;
      }

      if (el.type === "cartouche") {
        const by = (el.baselineY != null) ? (el.baselineY | 0) : Math.floor((el.h | 0) * 0.75);
        const drawY = glyphBaseline - by;
        outCtx.drawImage(el.canvas, x, drawY);
        x += el.w;
        continue;
      }
    }

    y += L.lineBoxH;
    if (li < box.lines.length - 1) y += box.lineGapPx;
  }

  return box; // return measured bbox/metrics for callers that want it
}

/* ============================================================
   Convenience: parse + measure + draw in one call
   ============================================================ */
function renderTextToCanvas(
  outCanvas,
  multilineText,
  {
    fontPx,
    mode = "uniform",
    fgCss = "#111",
    padPx = DEFAULT_PAD_PX,
    lineGapPx = LINE_GAP_PX,
    literalFontFamily,            // NEW: accept it
    literalFontAlignment,   //New accept alignment
  } = {}
) {
  // NEW: forward literalFontFamily into the parser so "..." segments use the element’s font
  const linesEls = parseMultilineToElements(multilineText, {
    fontPx,
    mode,
    fgCss,
    literalFontFamily,
  });

  return renderMultilineToCanvas(outCanvas, linesEls, {
    fontPx,
    fgCss,
    padPx,
    lineGapPx,
    literalFontAlignment,
  });
}






//******* end of new code for displaying sitelen elements

/* ============================================================
   Sitelen raster cache (text -> offscreen canvas)
   ------------------------------------------------------------
   This is the hook layer you requested.
   - Measure bbox for sitelen text (dummy now)
   - Allocate offscreen canvas
   - Draw sitelen onto offscreen (dummy now)
   - Resize element box to measured size
   - Draw like an image (drawImage), allowing rotate/stretch
   ============================================================ */

const sitelenCache = new Map(); // el.id -> { sig, canvas, naturalW, naturalH }


/** Build a signature so we only rebuild when relevant props change */
function sitelenSignature(el){
  return [
    String(el.text ?? ""),
    String(el.align ?? "left"),
    Number(el.fontSize ?? 44),
    String(el.color ?? "#111111"),

    // literal segments font depends on element fontFamily
    sitelenLiteralFontFamilyForElement(el),

    // include anything else that materially changes raster output
    "mode:uniform",
    `pad:${DEFAULT_PAD_PX}`,
    `lineGap:${LINE_GAP_PX}`,
  ].join("|");
}



function sitelenMeasureBBox(el){
  const fontPx = Math.max(6, Number(el.fontSize ?? 44));

  const opts = {
    fontPx,
    mode: "uniform",
    fgCss: el.color || "#111",
    padPx: DEFAULT_PAD_PX,
    lineGapPx: LINE_GAP_PX,

    // NEW: literal font comes from the element, not a constant
    literalFontFamily: sitelenLiteralFontFamilyForElement(el),
  };

  const linesEls = parseMultilineToElements(String(el.text ?? ""), opts);
  const box = measureMultiline(linesEls, opts);

  return { w: Math.max(8, box.width), h: Math.max(8, box.height) };
}



function sitelenRenderToOffscreen(el,w,h){
  const off = document.createElement("canvas");
  const fontPx = Math.max(6, Number(el.fontSize ?? 44));

  const opts = {
    fontPx,
    mode: "uniform",
    fgCss: el.color || "#111111",
    padPx: DEFAULT_PAD_PX,
    lineGapPx: LINE_GAP_PX,

    literalFontFamily: sitelenLiteralFontFamilyForElement(el),
    literalFontAlignment: sitelenLiteralFontAlignmentForElement(el),
  };

  renderTextToCanvas(off, String(el.text ?? ""), opts);
  return off;
}


/**
 * Ensure sitelen raster exists and is current.
 * Returns {canvas, naturalW, naturalH}
 */
function ensureSitelenRaster(el){
  if (el.type !== ElementType.Sitelen) return null;

  //console.log("ensure sitelen raster");

  const sig = sitelenSignature(el);
  const existing = sitelenCache.get(el.id);
  if (existing && existing.sig === sig) return existing;

  console.log("ensure sitelen new raster");

  // Build fresh raster
  const bb = sitelenMeasureBBox(el);
  const canvas = sitelenRenderToOffscreen(el, bb.w, bb.h);

  const entry = {
    sig,
    canvas,
    naturalW: canvas.width,
    naturalH: canvas.height,
  };

  // Ensure metadata container
  if (!el.sitelen || typeof el.sitelen !== "object") el.sitelen = {};

  // Always update intrinsic size (natural size is content-dependent)
  el.sitelen.naturalW = entry.naturalW;
  el.sitelen.naturalH = entry.naturalH;

  // IMPORTANT: also reset "orig" to the new natural size whenever the raster changes.
  // This ensures "Keep aspect ratio" toggling reverts to the *current* natural size.
  el.sitelen.origW = entry.naturalW;
  el.sitelen.origH = entry.naturalH;

  sitelenCache.set(el.id, entry);
  return entry;
}



/**
 * Recompute sitelen bbox + raster, and resize element box to match.
 * Call this whenever sitelen text/font settings change.
 */
function updateSitelenLayout(el, opts){
  if (!el || el.type !== ElementType.Sitelen) return;

  const options = Object.assign({ preserveCenter: true }, opts || {});

  const cx = el.x + el.w / 2;
  const cy = el.y + el.h / 2;

  // Build (or rebuild) raster; this also refreshes el.sitelen.{naturalW,naturalH,origW,origH}
  const entry = ensureSitelenRaster(el);
  if (!entry) return;

  // Resize element box to the CURRENT natural size (your requirement)
  const newW = Math.max(8, entry.naturalW);
  const newH = Math.max(8, entry.naturalH);

  el.w = newW;
  el.h = newH;

  if (options.preserveCenter){
    el.x = cx - el.w / 2;
    el.y = cy - el.h / 2;
  }
}


/** Clear sitelen cache for a single element (call when you replace your renderer) */
function invalidateSitelenCache(elId){
  sitelenCache.delete(elId);
}

function refreshAllSitelenElementsPreserveCenter(){
  for (const el of Scene.elements){
    if (el.type === ElementType.Sitelen){
      invalidateSitelenCache(el.id);
      updateSitelenLayout(el, { preserveCenter: true });
    }
  }
}

//clipboard:
/* ============================================================
   Copy / Cut / Paste clipboard
   ============================================================ */
const CLIPBOARD = {
  elements: null,          // deep-cloned element snapshots
  groups: null,            // deep-cloned group records (optional)
  hadSingleGroup: false,   // whether the selection was a single group
  sourceGroupId: null,     // original group id if selection was a single group
  pasteIndex: 0,           // increments each paste (for repeated offset)
};

function selectionIdsArray(){
  return [...selectedIds];
}

function selectionIsEmpty(){
  return selectedIds.size === 0;
}

function cleanupGroupsAfterElementRemoval(){
  const used = new Set(Scene.elements.map(e => e.groupId).filter(Boolean));
  for (const gid of Object.keys(Scene.groups)){
    if (!used.has(gid)) delete Scene.groups[gid];
  }
}

function removeElementsByIds(idsSet){
  Scene.elements = Scene.elements.filter(e => !idsSet.has(e.id));
  cleanupGroupsAfterElementRemoval();
}




  /* ============================================================
     Selection, hit testing, handles
     ============================================================ */
  let activeTool = Tool.Select;

  /** @type {Set<string>} */
  let selectedIds = new Set(); // selected elements (or elements in selected group)


//history undo/redo
/* ============================================================
   Undo / Redo (history)
   ------------------------------------------------------------
   - We snapshot the *model* (Scene + selection + active tool).
   - Commits happen on discrete actions (add/delete/paste/group),
     at end of drags, and on committed inspector edits.
   ============================================================ */

const History = {
  max: 120,
  undo: /** @type {Array<{snap:any, reason:string, ts:number}>} */([]),
  redo: /** @type {Array<{snap:any, reason:string, ts:number}>} */([]),
  lastSig: "",
  isRestoring: false
};



function snapshotForHistory(){
  return {
    scene: deepClone({ stage: Scene.stage, view: Scene.view, elements: Scene.elements }),
    selectionIds: Array.from(selectedIds),
    activeTool
  };
}

function signatureForHistory(snap){
  return JSON.stringify(snap);
}

function updateUndoRedoUi(){
  const btnUndo = $("btnUndo");
  const btnRedo = $("btnRedo");
  if (!btnUndo || !btnRedo) return;

  // Undo stack always contains the current state at the top.
  btnUndo.disabled = (History.undo.length <= 1);
  btnRedo.disabled = (History.redo.length === 0);

  const undoTop = History.undo.length > 0 ? History.undo[History.undo.length-1] : null;
  const redoTop = History.redo.length > 0 ? History.redo[History.redo.length-1] : null;

  btnUndo.title = undoTop ? `Undo (Ctrl/Cmd+Z)\nLast: ${undoTop.reason}` : "Undo (Ctrl/Cmd+Z)";
  btnRedo.title = redoTop ? `Redo (Ctrl/Cmd+Y or Ctrl/Cmd+Shift+Z)\nNext: ${redoTop.reason}` : "Redo (Ctrl/Cmd+Y or Ctrl/Cmd+Shift+Z)";
}

function historyReset(reason="Reset"){
  History.undo.length = 0;
  History.redo.length = 0;

  const snap = snapshotForHistory();
  const sig = signatureForHistory(snap);
  History.lastSig = sig;

  History.undo.push({ snap, reason, ts: Date.now() });
  updateUndoRedoUi();
}

function historyCommit(reason){
  if (History.isRestoring) return;

  const snap = snapshotForHistory();
  const sig = signatureForHistory(snap);
  if (sig === History.lastSig) return;

  History.lastSig = sig;
  History.undo.push({ snap, reason, ts: Date.now() });

  if (History.undo.length > History.max) History.undo.shift();
  History.redo.length = 0;

  updateUndoRedoUi();
}

let _historyCommitTimer = null;
function historyCommitDebounced(reason, ms=250){
  if (History.isRestoring) return;
  clearTimeout(_historyCommitTimer);
  _historyCommitTimer = setTimeout(() => historyCommit(reason), ms);
}

function applyHistorySnapshot(snap){
  console.log("applyHistorySnapshot start");
  History.isRestoring = true;
  try{
    History.lastSig = signatureForHistory(snap);

    Scene.stage = deepClone(snap.scene.stage);
    Scene.view  = deepClone(snap.scene.view);
    Scene.elements = deepClone(snap.scene.elements);

    selectedIds = new Set(Array.isArray(snap.selectionIds) ? snap.selectionIds : []);
    setTool(snap.activeTool || Tool.Select);

    // Defensive: caches depend on the model.
    try{ clearAllSitelenCache && clearAllSitelenCache(); }catch(_){}
    try{ clearAllImageCache && clearAllImageCache(); }catch(_){}

    updateUiForSelection();
    //updateInspector();
    console.log("applyHistorySnapshot prerender");
    render();
    console.log("applyHistorySnapshot postrender");
    scheduleAutosave();
  }finally{
    History.isRestoring = false;
    updateUndoRedoUi();
  }
}

function historyUndo(){
  if (History.undo.length <= 1) return;
  const current = History.undo.pop();
  History.redo.push(current);
  const prev = History.undo[History.undo.length-1];
  applyHistorySnapshot(prev.snap);
  setStatus("Undo.");
}

function historyRedo(){
  if (History.redo.length === 0) return;
  const next = History.redo.pop();
  History.undo.push(next);
  applyHistorySnapshot(next.snap);
  setStatus("Redo.");
}
//history undo/redo end





  function isSelected(elId){ return selectedIds.has(elId); }

  function getElementById(id){
    return Scene.elements.find(e => e.id === id) || null;
  }

  function selectionHasLocked(){
  for (const id of selectedIds){
    const el = getElementById(id);
    if (el && el.isLocked) return true;
  }
  return false;
}

  function getSelectedElements(){
    const out = [];
    for (const id of selectedIds){
      const el = getElementById(id);
      if (el) out.push(el);
    }
    return out;
  }

  function clearSelection(){
    selectedIds.clear();
    updateUiForSelection();
    render();
  }

  function toggleSelectElement(elId){
    if (selectedIds.has(elId)) selectedIds.delete(elId);
    else selectedIds.add(elId);
    updateUiForSelection();
    render();
  }

  function selectOnlyElements(ids){
    selectedIds = new Set(ids);
    updateUiForSelection();
    render();
  }

  function selectWholeGroupIfApplicable(clickedEl, originalEvent){
  if (!clickedEl) return;

  // Do not auto-expand when user is intentionally multi-selecting
  const multi = !!(originalEvent && (originalEvent.shiftKey || originalEvent.ctrlKey || originalEvent.metaKey));
  if (multi) return;

  const gid = clickedEl.groupId;
  if (!gid) return;

  const members = getElementsInGroup(gid);
  if (members.length > 0){
    selectOnlyElements(members.map(e => e.id));
  }
}

  function anySelected(){
    return selectedIds.size > 0;
  }

  function getGroupIdFromSelection(){
    // If all selected elements share same non-null groupId, return it.
    const sels = getSelectedElements();
    if (!sels.length) return null;
    const gid = sels[0].groupId || null;
    if (!gid) return null;
    for (const el of sels) if (el.groupId !== gid) return null;
    return gid;
  }

  function getElementsInGroup(groupId){
    return Scene.elements.filter(e => e.groupId === groupId);
  }

  function isTextLikeElement(el){
  return el && (
    el.type === ElementType.Text ||
    el.type === ElementType.Sitelen ||
    el.type === ElementType.Glyph
  );
}

function moveSelectionZ(delta){
  // delta: +1 = bring forward (towards end), -1 = send backward (towards start)
  if (!selectedIds || selectedIds.size === 0) return;

  // If anything locked is selected, do nothing (matches your UI disable intent)
  if (selectionHasLocked()) return;

console.log("moveSelectionZ");

  const n = Scene.elements.length;
  if (n <= 1) return;

  // Indices of selected elements in Scene.elements order
  const selectedIdx = [];
  for (let i = 0; i < n; i++){
    if (selectedIds.has(Scene.elements[i].id)) selectedIdx.push(i);
  }
  if (selectedIdx.length === 0) return;

  // Treat selection as a single block:
  // remove selected elements, then reinsert them shifted by delta.
  const minIdx = selectedIdx[0];
  const maxIdx = selectedIdx[selectedIdx.length - 1];

  // Boundary checks: if block is already at the edge, nothing to do
  if (delta < 0 && minIdx === 0) return;
  if (delta > 0 && maxIdx === n - 1) return;

  // Extract selected elements in draw order (preserve relative order)
  const selectedEls = [];
  const remaining = [];
  for (const el of Scene.elements){
    if (selectedIds.has(el.id)) selectedEls.push(el);
    else remaining.push(el);
  }

  // Compute insertion index in the remaining array.
  // Original block started at minIdx in the original array.
  // After removing selectedEls, everything before minIdx is still before.
  let insertAt = minIdx;

  // Shift by one "slot" in the final array.
  // For forward: insert after the next unselected element.
  // For backward: insert before the previous unselected element.
  if (delta > 0){
    insertAt = minIdx + 1; // move block one step towards end
  } else if (delta < 0){
    insertAt = minIdx - 1; // move block one step towards start
  }

  // Clamp insertAt to remaining bounds
  insertAt = Math.max(0, Math.min(insertAt, remaining.length));

  // But: insertAt is expressed in terms of the final array positions.
  // Since remaining is missing selectedEls, we must ensure the “step” is relative to unselected neighbors.
  // Adjust by counting how many selected indices were before the target position.
  // A simple robust way: simulate one-step swap with neighbor.
  if (delta > 0){
    // Swap block with the first unselected element immediately after it (if any)
    // Find first unselected element after maxIdx in original:
    const neighbor = Scene.elements[maxIdx + 1];
    if (!neighbor || selectedIds.has(neighbor.id)) return;

    // In remaining, neighbor sits at position: (maxIdx + 1) - (#selected before it)
    let selectedBeforeNeighbor = 0;
    for (const idx of selectedIdx) if (idx < (maxIdx + 1)) selectedBeforeNeighbor++;
    const neighborPos = (maxIdx + 1) - selectedBeforeNeighbor;

    // Put block after neighbor
    insertAt = neighborPos + 1;
  } else {
    // Swap block with the unselected element immediately before it
    const neighbor = Scene.elements[minIdx - 1];
    if (!neighbor || selectedIds.has(neighbor.id)) return;

    let selectedBeforeNeighbor = 0;
    for (const idx of selectedIdx) if (idx < (minIdx - 1)) selectedBeforeNeighbor++;
    const neighborPos = (minIdx - 1) - selectedBeforeNeighbor;

    // Put block before neighbor
    insertAt = neighborPos;
  }

  // Rebuild Scene.elements with the moved block
  const next = remaining.slice(0, insertAt)
    .concat(selectedEls)
    .concat(remaining.slice(insertAt));

  //Scene.elements = next;
  // IMPORTANT: mutate in-place so any cached refs see it
  Scene.elements.splice(0, Scene.elements.length, ...next);

  //console.log("draw order:", Scene.elements.map(e => e.id).join(","));

}

function applyGroupForeground(groupId, cssColor){
  if (!groupId) return;
  if (!Scene.groups[groupId]) Scene.groups[groupId] = { id: groupId, createdAt: new Date().toISOString() };

  Scene.groups[groupId].foreground = cssColor;

  const els = getElementsInGroup(groupId);
  for (const el of els){
    if (!isTextLikeElement(el)) continue;

    el.color =  rgbaOrHexToHex( cssColor , "~111111");

    // Sitelen needs raster/layout refresh because color is baked into the offscreen canvas
    if (el.type === ElementType.Sitelen){
      invalidateSitelenCache(el.id);
      updateSitelenLayout(el, { preserveCenter: true });
    }
  }
}

  // ===============================
// Arrow-key nudge (fixes snap bounce)
// ===============================
function wireArrowKeyNudge(){
  window.addEventListener("keydown", (e) => {
    // Ignore typing inside inputs/textareas/selects/contenteditable
    if (isTypingContext(e.target)) return;

    // Only when something is selected
    if (!selectedIds || selectedIds.size === 0) return;

    // Block nudging locked selection
    if (selectionHasLocked()){
      // optional: silent ignore instead of alert
      return;
    }

    const key = e.key;

    // Only arrow keys
    const isArrow =
      key === "ArrowLeft" || key === "ArrowRight" ||
      key === "ArrowUp"   || key === "ArrowDown";
    if (!isArrow) return;

    e.preventDefault();

    // Base nudge in STAGE units (not screen px)
    // Normal: 1, Shift: 10, Alt: gridSize (optional)
    let step = 1;
    if (e.shiftKey) step = 10;

    // If grid snap is enabled, make arrow nudges actually move.
    // Option A (recommended): nudge by grid size when snapGrid is ON.
    if (Scene.stage.snapGrid){
      const gs = Math.max(1, Number(Scene.stage.gridSize || 20));
      step = gs;

      // If you still want Shift to be "bigger", multiply:
      if (e.shiftKey) step = gs * 5; // tweak as you like
    }

    // Optional: Alt forces grid size even if snapGrid is off
    if (e.altKey){
      const gs = Math.max(1, Number(Scene.stage.gridSize || 20));
      step = gs;
    }

    let dx = 0, dy = 0;
    if (key === "ArrowLeft")  dx = -step;
    if (key === "ArrowRight") dx =  step;
    if (key === "ArrowUp")    dy = -step;
    if (key === "ArrowDown")  dy =  step;

    // Apply move directly in stage space
    const sels = getSelectedElements();

    for (const el of sels){
      el.x += dx;
      el.y += dy;
    }

    // If you want object snapping even on arrow moves, you can apply it here.
    // But DO NOT re-round to grid again because step already accounts for it.
    // If you DO want object snap only:
    if (!Scene.stage.snapGrid && Scene.stage.snapObjects){
      const ids = sels.map(e => e.id);
      // Use your existing snap logic without grid rounding:
      const snapped = applySnapMove(dx, dy, ids);
      // applySnapMove assumes _startX/_startY; easiest is:
      // (skip, unless you refactor applySnapMove to be "pure" over current positions)
    }

    scheduleAutosave();
    updateUiForSelection();
    render();
    historyCommitDebounced("Nudge");

  });
}


  function pickTopmostElementAtStagePoint(ptStage){
    // Iterate from topmost (end of array) to bottom.
    for (let i = Scene.elements.length - 1; i >= 0; i--){
      const el = Scene.elements[i];
      if (pointInElement(ptStage, el)) return el;
    }
    return null;
  }

  function pointInElement(pt, el){
    // Treat element bounds as rotated rectangle about its center.
    const cx = el.x + el.w/2;
    const cy = el.y + el.h/2;
    const a = -rad(el.rotationDeg || 0);

    const dx = pt.x - cx;
    const dy = pt.y - cy;
    const rx = dx * Math.cos(a) - dy * Math.sin(a);
    const ry = dx * Math.sin(a) + dy * Math.cos(a);

    return (Math.abs(rx) <= el.w/2) && (Math.abs(ry) <= el.h/2);
  }

  function elementCorners(el){
    const cx = el.x + el.w/2, cy = el.y + el.h/2;
    const a = rad(el.rotationDeg || 0);
    const hw = el.w/2, hh = el.h/2;
    const pts = [
      {x:-hw,y:-hh},{x:hw,y:-hh},{x:hw,y:hh},{x:-hw,y:hh}
    ].map(p => ({
      x: cx + p.x * Math.cos(a) - p.y * Math.sin(a),
      y: cy + p.x * Math.sin(a) + p.y * Math.cos(a),
    }));
    return pts;
  }

  function aabbOfElements(els){
    if (!els.length) return { x:0, y:0, w:0, h:0 };
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const el of els){
      const cs = elementCorners(el);
      for (const p of cs){
        minX = Math.min(minX, p.x);
        minY = Math.min(minY, p.y);
        maxX = Math.max(maxX, p.x);
        maxY = Math.max(maxY, p.y);
      }
    }
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  }

  function getSelectionAabb(){
    return aabbOfElements(getSelectedElements());
  }

  function handlesForAabb(aabb){
    const s = 8 / Scene.view.zoom; // handle size in stage units
    const x = aabb.x, y = aabb.y, w = aabb.w, h = aabb.h;
    const cx = x + w/2, cy = y + h/2;

    const pts = {
      nw: {x:x, y:y},
      n:  {x:cx, y:y},
      ne: {x:x+w, y:y},
      e:  {x:x+w, y:cy},
      se: {x:x+w, y:y+h},
      s:  {x:cx, y:y+h},
      sw: {x:x, y:y+h},
      w:  {x:x, y:cy},
      rot:{x:cx, y:y - 24/Scene.view.zoom}, // rotate handle above
    };

    function box(p){ return { x: p.x - s, y: p.y - s, w: s*2, h: s*2 }; }

    return {
      ResizeNW: box(pts.nw),
      ResizeN:  box(pts.n),
      ResizeNE: box(pts.ne),
      ResizeE:  box(pts.e),
      ResizeSE: box(pts.se),
      ResizeS:  box(pts.s),
      ResizeSW: box(pts.sw),
      ResizeW:  box(pts.w),
      Rotate:   box(pts.rot),
      rotPt: pts.rot,
      center: {x:cx, y:cy},
    };
  }

  function pointInAabb(pt, box){
    return pt.x >= box.x && pt.x <= box.x + box.w && pt.y >= box.y && pt.y <= box.y + box.h;
  }

  function hitTestSelectionHandles(ptStage){
    if (!anySelected()) return HANDLE.None;
    const aabb = getSelectionAabb();
    if (aabb.w < 1 || aabb.h < 1) return HANDLE.None;

    const hs = handlesForAabb(aabb);
    if (pointInAabb(ptStage, hs.Rotate)) return HANDLE.Rotate;
    if (pointInAabb(ptStage, hs.ResizeNW)) return HANDLE.ResizeNW;
    if (pointInAabb(ptStage, hs.ResizeN))  return HANDLE.ResizeN;
    if (pointInAabb(ptStage, hs.ResizeNE)) return HANDLE.ResizeNE;
    if (pointInAabb(ptStage, hs.ResizeE))  return HANDLE.ResizeE;
    if (pointInAabb(ptStage, hs.ResizeSE)) return HANDLE.ResizeSE;
    if (pointInAabb(ptStage, hs.ResizeS))  return HANDLE.ResizeS;
    if (pointInAabb(ptStage, hs.ResizeSW)) return HANDLE.ResizeSW;
    if (pointInAabb(ptStage, hs.ResizeW))  return HANDLE.ResizeW;

    // Move: click inside selection aabb (after handles checked)
    if (pointInAabb(ptStage, aabb)) return HANDLE.Move;
    return HANDLE.None;
  }

  /* ============================================================
     Drag state and gestures
     ============================================================ */
  const drag = {
    active: false,
    pointerId: null,
    mode: HANDLE.None,
    startScreen: {x:0,y:0},
    startStage: {x:0,y:0},
    startAabb: null,
    startElsSnapshot: null, // array of {id, x,y,w,h,rotationDeg,fontSize}
    startAngle: 0,
    marquee: null, // {x0,y0,x1,y1}
    panStartView: null,
  };

  function isTypingContext(el){
    if (!el) return false;
    const tag = String(el.tagName || "").toLowerCase();
    return tag === "input" || tag === "textarea" || tag === "select" || el.isContentEditable;
  }

  function getPointerScreen(e){
    const r = wrap.getBoundingClientRect();
    return { x: e.clientX - r.left, y: e.clientY - r.top };
  }

  function startPointerCapture(e){
    wrap.setPointerCapture(e.pointerId);
    drag.active = true;
    drag.pointerId = e.pointerId;
  }

  function endPointerCapture(){
    drag.active = false;
    drag.pointerId = null;
    drag.mode = HANDLE.None;
    drag.startAabb = null;
    drag.startElsSnapshot = null;
    drag.startAngle = 0;
    drag.marquee = null;
    drag.panStartView = null;
  }

  function snapshotSelected(){
    const sels = getSelectedElements();
    return sels.map(el => ({
      id: el.id,
      x: el.x, y: el.y, w: el.w, h: el.h,
      rotationDeg: el.rotationDeg || 0,
      fontSize: el.fontSize ?? null,
      radius: el.radius ?? null,
    }));
  }

  function applySnapMove(dx, dy, movingElIds){
    const tol = Scene.stage.snapTol;
    if (!Scene.stage.snapGrid && !Scene.stage.snapObjects) return {dx,dy};

    // Compute candidate snaps on aabb of moving selection (before move)
    const sels = movingElIds.map(id => getElementById(id)).filter(Boolean);
    const aabb0 = aabbOfElements(sels);
    let ndx = dx, ndy = dy;

    if (Scene.stage.snapGrid){
      const gs = Math.max(2, Scene.stage.gridSize|0);
      const tx = roundTo(aabb0.x + dx, gs) - aabb0.x;
      const ty = roundTo(aabb0.y + dy, gs) - aabb0.y;
      if (Math.abs(tx - dx) <= tol) ndx = tx;
      if (Math.abs(ty - dy) <= tol) ndy = ty;
    }

    if (Scene.stage.snapObjects){
      // Simple snapping: align selection aabb edges/center with other elements' aabb edges/center.
      const others = Scene.elements.filter(e => !movingElIds.includes(e.id));
      const linesX = [];
      const linesY = [];
      for (const o of others){
        const b = aabbOfElements([o]);
        linesX.push(b.x, b.x + b.w, b.x + b.w/2);
        linesY.push(b.y, b.y + b.h, b.y + b.h/2);
      }

      const bx = aabb0.x + ndx, by = aabb0.y + ndy, bw = aabb0.w, bh = aabb0.h;
      const candX = [bx, bx + bw, bx + bw/2];
      const candY = [by, by + bh, by + bh/2];

      // find closest within tolerance
      for (const cx of candX){
        for (const lx of linesX){
          const d = lx - cx;
          if (Math.abs(d) <= tol){
            ndx += d;
            break;
          }
        }
      }
      for (const cy of candY){
        for (const ly of linesY){
          const d = ly - cy;
          if (Math.abs(d) <= tol){
            ndy += d;
            break;
          }
        }
      }
    }

    return {dx: ndx, dy: ndy};
  }

  function applyMoveToSelection(dx, dy){
    const ids = [...selectedIds];
    const snapped = applySnapMove(dx, dy, ids);

    for (const id of ids){
      const el = getElementById(id);
      if (!el) continue;
      el.x = el._startX + snapped.dx;
      el.y = el._startY + snapped.dy;

      if (Scene.stage.snapGrid){
        const gs = Math.max(2, Scene.stage.gridSize|0);
        el.x = roundTo(el.x, gs);
        el.y = roundTo(el.y, gs);
      }
    }
  }

  function applyRotateToSelection(deltaDeg){
    const ids = [...selectedIds];
    const aabb = drag.startAabb;
    const cx = aabb.x + aabb.w/2;
    const cy = aabb.y + aabb.h/2;

    for (const id of ids){
      const el = getElementById(id);
      if (!el) continue;
      const sx = el._startX + el.w/2;
      const sy = el._startY + el.h/2;

      const r0 = rad(0);
      const a = rad(deltaDeg);

      // rotate element center around selection center
      const dx = sx - cx;
      const dy = sy - cy;
      const nx = dx * Math.cos(a) - dy * Math.sin(a);
      const ny = dx * Math.sin(a) + dy * Math.cos(a);
      const newCx = cx + nx;
      const newCy = cy + ny;

      el.x = newCx - el.w/2;
      el.y = newCy - el.h/2;

      el.rotationDeg = (el._startRot + deltaDeg);
    }
  }

  function applyScaleToSelection(handleMode, currPtStage, keepAspect){
    const ids = [...selectedIds];
    const a0 = drag.startAabb;
    const cx = a0.x + a0.w/2;
    const cy = a0.y + a0.h/2;

    // Determine anchor point opposite handle
    let ax = cx, ay = cy;
    let hx = currPtStage.x, hy = currPtStage.y;

    const left = a0.x, right = a0.x + a0.w, top = a0.y, bottom = a0.y + a0.h;

    switch(handleMode){
      case HANDLE.ResizeNW: ax = right; ay = bottom; break;
      case HANDLE.ResizeN:  ax = cx;    ay = bottom; break;
      case HANDLE.ResizeNE: ax = left;  ay = bottom; break;
      case HANDLE.ResizeE:  ax = left;  ay = cy; break;
      case HANDLE.ResizeSE: ax = left;  ay = top; break;
      case HANDLE.ResizeS:  ax = cx;    ay = top; break;
      case HANDLE.ResizeSW: ax = right; ay = top; break;
      case HANDLE.ResizeW:  ax = right; ay = cy; break;
    }

    // Old handle reference point (based on start aabb)
    let ox = cx, oy = cy;
    switch(handleMode){
      case HANDLE.ResizeNW: ox = left;  oy = top; break;
      case HANDLE.ResizeN:  ox = cx;    oy = top; break;
      case HANDLE.ResizeNE: ox = right; oy = top; break;
      case HANDLE.ResizeE:  ox = right; oy = cy; break;
      case HANDLE.ResizeSE: ox = right; oy = bottom; break;
      case HANDLE.ResizeS:  ox = cx;    oy = bottom; break;
      case HANDLE.ResizeSW: ox = left;  oy = bottom; break;
      case HANDLE.ResizeW:  ox = left;  oy = cy; break;
    }

    const v0x = ox - ax, v0y = oy - ay;
    const v1x = hx - ax, v1y = hy - ay;

    const sx = (Math.abs(v0x) < 1e-6) ? 1 : (v1x / v0x);
    const sy = (Math.abs(v0y) < 1e-6) ? 1 : (v1y / v0y);

    let ssx = sx, ssy = sy;
    if (keepAspect){
      const s = (Math.abs(ssx) < Math.abs(ssy)) ? ssx : ssy;
      ssx = s; ssy = s;
    }

    // Clamp scaling
    ssx = clamp(ssx, 0.1, 10);
    ssy = clamp(ssy, 0.1, 10);

    for (const id of ids){
      const el = getElementById(id);
      if (!el) continue;

      // Scale element center relative to anchor
      const c0x = (el._startX + el._startW/2);
      const c0y = (el._startY + el._startH/2);

      const dcx = c0x - ax;
      const dcy = c0y - ay;

      const c1x = ax + dcx * ssx;
      const c1y = ay + dcy * ssy;

      let nw = Math.max(8, el._startW * ssx);
let nh = Math.max(8, el._startH * ssy);

let x1 = c1x - nw/2;
let y1 = c1y - nh/2;

// CHANGE HERE: aspect lock for images when keepAspect is true
// CHANGE HERE: aspect lock for images + sitelen when keepAspect is true
if (
  (el.type === ElementType.Image || el.type === ElementType.Sitelen) &&
  ((el.keepAspect == null) ? true : !!el.keepAspect)
){

    // Aspect ratio source:
  // - Image: intrinsic (naturalW/H) or stored origW/H
  // - Sitelen: raster intrinsic (sitelenCache) or stored sitelen.origW/H
  let aspect = null;

  if (el.type === ElementType.Image){
    if (el.image && el.image.naturalW > 0 && el.image.naturalH > 0){
      aspect = el.image.naturalW / el.image.naturalH;
    } else if (el.image && Number.isFinite(el.image.origW) && Number.isFinite(el.image.origH) && el.image.origH > 0){
      aspect = el.image.origW / el.image.origH;
    }
  } else if (el.type === ElementType.Sitelen){
    const r = ensureSitelenRaster(el); // safe: cached unless text/font /align changed
    if (r && r.naturalW > 0 && r.naturalH > 0){
      aspect = r.naturalW / r.naturalH;
    } else if (el.sitelen && Number.isFinite(el.sitelen.origW) && Number.isFinite(el.sitelen.origH) && el.sitelen.origH > 0){
      aspect = el.sitelen.origW / el.sitelen.origH;
    }
  }

  if (aspect && isFinite(aspect) && aspect > 0){
    // Preserve the “opposite side/corner” feel of the handle by pinning the appropriate edges
    const left0 = x1;
    const right0 = x1 + nw;
    const top0 = y1;
    const bottom0 = y1 + nh;
    const cy0 = y1 + nh/2;
    const cx0 = x1 + nw/2;

    // Choose whether width or height is the driver based on handle direction
    const usesHeightAsDriver =
      (handleMode === HANDLE.ResizeN || handleMode === HANDLE.ResizeS);

    if (usesHeightAsDriver){
      nh = Math.max(8, nh);
      nw = Math.max(8, nh * aspect);
    } else {
      nw = Math.max(8, nw);
      nh = Math.max(8, nw / aspect);
    }

    // Now place box based on handle
    switch(handleMode){
      case HANDLE.ResizeE:
        x1 = left0;
        y1 = cy0 - nh/2;
        break;
      case HANDLE.ResizeW:
        x1 = right0 - nw;
        y1 = cy0 - nh/2;
        break;
      case HANDLE.ResizeS:
        x1 = cx0 - nw/2;
        y1 = top0;
        break;
      case HANDLE.ResizeN:
        x1 = cx0 - nw/2;
        y1 = bottom0 - nh;
        break;

      case HANDLE.ResizeNE: // opposite is bottom-left
        x1 = left0;
        y1 = bottom0 - nh;
        break;
      case HANDLE.ResizeNW: // opposite is bottom-right
        x1 = right0 - nw;
        y1 = bottom0 - nh;
        break;
      case HANDLE.ResizeSE: // opposite is top-left
        x1 = left0;
        y1 = top0;
        break;
      case HANDLE.ResizeSW: // opposite is top-right
        x1 = right0 - nw;
        y1 = top0;
        break;

      default:
        // fallback: keep center stable
        x1 = cx0 - nw/2;
        y1 = cy0 - nh/2;
        break;
    }
  }
}

el.w = nw;
el.h = nh;
el.x = x1;
el.y = y1;


      // Scale font size for text-like elements
      // Scale font size ONLY when enabled (Text + Glyph)
      const canScaleFont =
        (el.type === ElementType.Text || el.type === ElementType.Glyph) &&
        !!el.scaleFontWithBox;

      if (canScaleFont && typeof el._startFontSize === "number"){
        const s = Math.max(0.2, (Math.abs(ssx) + Math.abs(ssy)) / 2);
        el.fontSize = Math.max(6, el._startFontSize * s);
      }


      // Scale rect radius
      if (el.type === ElementType.Rect && typeof el._startRadius === "number"){
        const s = Math.max(0.2, (Math.abs(ssx)+Math.abs(ssy))/2);
        el.radius = Math.max(0, el._startRadius * s);
      }
    }
  }

  function beginDragSelectionMode(mode, ptScreen, ptStage){
    drag.mode = mode;
    drag.startScreen = ptScreen;
    drag.startStage = ptStage;

    drag.startAabb = getSelectionAabb();
    drag.startElsSnapshot = snapshotSelected();

    // store start values on elements for simpler apply
    for (const s of drag.startElsSnapshot){
      const el = getElementById(s.id);
      if (!el) continue;
      el._startX = s.x; el._startY = s.y;
      el._startW = s.w; el._startH = s.h;
      el._startRot = s.rotationDeg;
      el._startFontSize = s.fontSize;
      el._startRadius = s.radius;
    }

    if (mode === HANDLE.Rotate){
      const aabb = drag.startAabb;
      const cx = aabb.x + aabb.w/2;
      const cy = aabb.y + aabb.h/2;
      drag.startAngle = Math.atan2(ptStage.y - cy, ptStage.x - cx);
    }
  }

  function finalizeDrag(){
    let changed = false;

    for (const el of Scene.elements){
      if (el._startX !== undefined){
        if (
          el.x !== el._startX || el.y !== el._startY ||
          el.w !== el._startW || el.h !== el._startH ||
          el.rot !== el._startRot ||
          el.fontSize !== el._startFontSize ||
          el.radius !== el._startRadius
        ){
          changed = true;
          break;
        }
      }
    }

    // clean temp fields
    for (const el of Scene.elements){
      delete el._startX; delete el._startY;
      delete el._startW; delete el._startH;
      delete el._startRot;
      delete el._startFontSize;
      delete el._startRadius;
    }
    scheduleAutosave();
    updateUiForSelection();
    render();
    if (changed) historyCommit("Transform");
  }

  /* ============================================================
     Tools
     ============================================================ */
  function setTool(t){
    activeTool = t;
    // update tool button states
    const map = [
      [Tool.Select, "toolSelect"],
      [Tool.Text, "toolText"],
      [Tool.Sitelen, "toolSitelen"],
      [Tool.Glyph, "toolGlyph"],
      [Tool.Rect, "toolRect"],
      [Tool.Image, "toolImage"],
      [Tool.Delete, "toolDelete"],
      [Tool.Pan, "toolPan"],
    ];
    for (const [tool, id] of map){
      const b = $(id);
      b.setAttribute("aria-pressed", (tool === activeTool) ? "true" : "false");
    }
    setStatus(`Tool: ${activeTool}`);
  }

  function addElement(el){
    Scene.elements.push(el);
    selectOnlyElements([el.id]);
    scheduleAutosave();
    render();
    historyCommit("Add element");

  }

function resizeCanvasToDisplaySize(){
  const dpr = window.devicePixelRatio || 1;

  // Use the container box (more stable than <canvas> rect in some browsers)
  const rect = wrap.getBoundingClientRect();

  const w = Math.max(1, Math.round(rect.width * dpr));
  const h = Math.max(1, Math.round(rect.height * dpr));

  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
    return true;
  }
  return false;
}


  /* ============================================================
     Rendering
     ============================================================ */
  function render(){
  //  console.log("render called");
  // CHANGE HERE: always sync canvas backing store to its CSS size
  resizeCanvasToDisplaySize(); // this should ONLY resize canvas.width/height; do not setTransform in it

  // CHANGE HERE: use the canvas rect (the actual drawing viewport), not the page wrap
  const crect = canvas.getBoundingClientRect();
  const cssW = crect.width;
  const cssH = crect.height;

  // CHANGE HERE: reset + clear deterministically
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // CHANGE HERE: draw in CSS pixel coordinates (your stageToScreen should output CSS px)
  const dpr = window.devicePixelRatio || 1;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  // If any code relies on clearRect in CSS px space, you can use:
  // ctx.clearRect(0, 0, cssW, cssH);

  // draw stage boundary (in screen coords / CSS px)
  const stageTL = stageToScreen({x:0,y:0});
  const stageBR = stageToScreen({x:Scene.stage.w,y:Scene.stage.h});
  const sx = stageTL.x, sy = stageTL.y, sw = stageBR.x - stageTL.x, sh = stageBR.y - stageTL.y;

  // subtle stage background
  //ctx.save();
 // ctx.fillStyle = "rgba(255,255,255,0.08)";
  //ctx.fillRect(sx, sy, sw, sh);
//  ctx.restore();

ctx.save();
// NEW: stage background from scene
ctx.fillStyle = Scene.stage.bg || DEFAULTS.stageBg;
ctx.fillRect(sx, sy, sw, sh);
ctx.restore();


  // grid
  if (Scene.stage.showGrid){
    drawGrid();
  }

  // draw elements in order
  for (const el of Scene.elements){
   // console.log("drawing", el.id);
    drawElement(el);
  }

  // selection overlays
  drawSelectionOverlay();

  // marquee overlay
  if (drag.marquee){
    drawMarquee(drag.marquee);
  }
}


  function drawGrid(){
    const gs = Math.max(2, Scene.stage.gridSize|0);
    const tl = stageToScreen({x:0,y:0});
    const br = stageToScreen({x:Scene.stage.w,y:Scene.stage.h});
    const sx = tl.x, sy = tl.y, sw = br.x - tl.x, sh = br.y - tl.y;

    const step = gs * Scene.view.zoom;

    ctx.save();
    ctx.beginPath();
    ctx.rect(sx, sy, sw, sh);
    ctx.clip();

    ctx.lineWidth = 1;
    ctx.strokeStyle = "rgba(17,17,17,0.10)";

    // vertical
    for (let x = sx; x <= sx + sw + 0.5; x += step){
      ctx.beginPath();
      ctx.moveTo(x, sy);
      ctx.lineTo(x, sy + sh);
      ctx.stroke();
    }
    // horizontal
    for (let y = sy; y <= sy + sh + 0.5; y += step){
      ctx.beginPath();
      ctx.moveTo(sx, y);
      ctx.lineTo(sx + sw, y);
      ctx.stroke();
    }

    ctx.restore();

    // stage outline
    ctx.save();
    ctx.strokeStyle = "rgba(17,17,17,0.22)";
    ctx.lineWidth = 2;
    ctx.strokeRect(sx, sy, sw, sh);
    ctx.restore();
  }

  function drawElement(el){
    // Apply view transform: stage->screen
    const p0 = stageToScreen({x: el.x, y: el.y});
    const scale = Scene.view.zoom;

    const cxStage = el.x + el.w/2;
    const cyStage = el.y + el.h/2;
    const c = stageToScreen({x: cxStage, y: cyStage});

    const w = el.w * scale;
    const h = el.h * scale;

    ctx.save();
    ctx.globalAlpha = clamp(el.opacity ?? 1, 0, 1);

    // rotate about center
    ctx.translate(c.x, c.y);
    ctx.rotate(rad(el.rotationDeg || 0));

    // local top-left in screen coords around center
    const lx = -w/2;
    const ly = -h/2;

    // draw by type
    if (el.type === ElementType.Rect){
      drawRectLocal(el, lx, ly, w, h);
    } else if (el.type === ElementType.Text){
      drawTextLocal(el, lx, ly, w, h, false);
    } else if (el.type === ElementType.Sitelen){
      drawSitelenRasterLocal(el, lx, ly, w, h);
    } else if (el.type === ElementType.Glyph){
      drawGlyphLocal(el, lx, ly, w, h);
    } else if (el.type === ElementType.Image){
      drawImageLocal(el, lx, ly, w, h);
    }

    ctx.restore();
  }

  function drawRoundedRectPath(x,y,w,h,r){
    const rr = Math.max(0, Math.min(r, w/2, h/2));
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawRectLocal(el, x,y,w,h){
    const r = el.radius ?? 0;

    if (el.fillEnabled && el.fill && el.fill !== "transparent"){
      ctx.save();
      ctx.fillStyle = el.fill;
      drawRoundedRectPath(x,y,w,h, r * Scene.view.zoom);
      ctx.fill();
      ctx.restore();
    }

    if ((el.strokeW ?? 0) > 0){
      ctx.save();
      ctx.lineWidth = (el.strokeW ?? 1);
      ctx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
      drawRoundedRectPath(x,y,w,h, r * Scene.view.zoom);
      ctx.stroke();
      ctx.restore();
    }
  }

  function splitLinesForBox(text){
    return String(text ?? "").replace(/\r\n?/g,"\n").split("\n");
  }

  function wrapLine(ctx, text, maxWidth){
    const words = text.split(" ");
    const lines = [];
    let cur = "";
    for (const w of words){
      const test = cur ? (cur + " " + w) : w;
      const m = ctx.measureText(test).width;
      if (m <= maxWidth || !cur){
        cur = test;
      } else {
        lines.push(cur);
        cur = w;
      }
    }
    if (cur) lines.push(cur);
    return lines;
  }

  function drawTextLocal(el, x,y,w,h, isSitelen){
    // Optional background box if fill/stroke present
    if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
      ctx.save();
      ctx.fillStyle = el.fill;
      ctx.fillRect(x,y,w,h);
      ctx.restore();
    }
    if ((el.strokeW ?? 0) > 0){
      ctx.save();
      ctx.lineWidth = (el.strokeW ?? 1);
      ctx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }

    const pad = 8 * Scene.view.zoom;
    const innerX = x + pad;
    const innerY = y + pad;
    const innerW = Math.max(0, w - pad*2);
    const innerH = Math.max(0, h - pad*2);

    const fontSize = Math.max(6, (el.fontSize ?? 24) * Scene.view.zoom);
    const fontFamily = el.fontFamily || "PatrickHand";
    const lineHeight = Math.max(0.8, el.lineHeight ?? 1.15);

    ctx.save();
    ctx.fillStyle = el.color || "#111";
    ctx.font = `${fontSize}px ${cssFontFamily(fontFamily)}, system-ui, sans-serif`;
    ctx.textBaseline = "top";

    // alignment
    let textAlign = (el.align || "left");
    if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right") textAlign = "left";
    ctx.textAlign = textAlign;

    const rawLines = splitLinesForBox(el.text);
    const allLines = [];

    for (const ln0 of rawLines){
      const ln = isSitelen ? renderSitelenLineToCanvasText(ln0) : String(ln0 ?? "");
      const wrapped = wrapLine(ctx, ln, innerW);
      for (const wln of wrapped) allLines.push(wln);
    }

    const lhPx = fontSize * lineHeight;
    let ty = innerY;
    for (const ln of allLines){
      if (ty + lhPx > innerY + innerH + 0.5) break;

      let tx = innerX;
      if (textAlign === "center") tx = innerX + innerW/2;
      if (textAlign === "right") tx = innerX + innerW;

      ctx.fillText(ln, tx, ty);
      ty += lhPx;
    }

    ctx.restore();
  }

  function parseCodepointInput(s){
    const raw = String(s ?? "").trim();
    if (!raw) return null;
    // Accept: "U+F1934" or "0xF1934" or a literal character
    if (/^U\+[0-9A-Fa-f]+$/.test(raw)){
      return parseInt(raw.slice(2), 16);
    }
    if (/^0x[0-9A-Fa-f]+$/.test(raw)){
      return parseInt(raw.slice(2), 16);
    }
    if (raw.length === 1){
      return raw.codePointAt(0);
    }
    return null;
  }



// CHANGE HERE: build reverse map (codepoint -> word)
const CP_TO_WORD = (() => {
  const m = new Map();
  for (const [w, cp] of Object.entries(WORD_TO_UCSUR_CP)){
    if (typeof cp === "number") m.set(cp, w);
  }
  return m;
})();

function codepointToWord(cp){
  if (typeof cp !== "number") return null;
  return CP_TO_WORD.get(cp) || null;
}

function codepointToFirstLetter(cp){
  const w = codepointToWord(cp);
  if (!w || !w.length) return null;
  return w[0].toLowerCase();
}

function firstLetterOfWord(w){
  const s = String(w ?? "").trim().toLowerCase();
  return s ? s[0] : null;
}

function makeGlyphPicker(el){
  // Determine currently selected word (by cp)
  const currentCp = parseCodepointInput(el.codepoint);
  const currentWord = codepointToWord(currentCp);

  // Letters present in the map
  const letters = Array.from(new Set(
    Object.keys(WORD_TO_UCSUR_CP).map(firstLetterOfWord).filter(Boolean)
  )).sort();

  // Default letter: from current glyph word, else first in list
  let selectedLetter = currentWord ? firstLetterOfWord(currentWord) : (letters[0] || "a");

  const root = document.createElement("div");
  root.className = "glyphPicker";

  // Letter buttons row
  const lettersRow = document.createElement("div");
  lettersRow.className = "glyphLetters";

  // Words buttons container
  const wordsBox = document.createElement("div");
  wordsBox.className = "glyphWords";

  function renderWords(){
    wordsBox.innerHTML = "";

    const words = Object.keys(WORD_TO_UCSUR_CP)
      .filter(w => firstLetterOfWord(w) === selectedLetter)
      .sort();

    for (const w of words){
      const cp = WORD_TO_UCSUR_CP[w];
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "glyphWordBtn";

      const pressed = (currentWord === w);
      btn.setAttribute("aria-pressed", pressed ? "true" : "false");

      // preview glyph + word label
      const preview = document.createElement("span");
      preview.className = "glyphPreview";
      preview.textContent = String.fromCodePoint(cp);

      const label = document.createElement("span");
      label.textContent = w;

      btn.appendChild(preview);
      btn.appendChild(label);

      btn.addEventListener("click", () => {
        // set codepoint in the same format you already accept
        el.codepoint = "U+" + cp.toString(16).toUpperCase();
        scheduleAutosave();
        updateUiForSelection(); // re-render properties so pressed states update
        render();
      });

      wordsBox.appendChild(btn);
    }
  }

  function renderLetters(){
    lettersRow.innerHTML = "";
    for (const L of letters){
      const b = document.createElement("button");
      b.type = "button";
      b.className = "glyphLetterBtn";
      b.textContent = L.toUpperCase();
      b.setAttribute("aria-pressed", (L === selectedLetter) ? "true" : "false");
      b.addEventListener("click", () => {
        selectedLetter = L;
        renderLetters();
        renderWords();
      });
      lettersRow.appendChild(b);
    }
  }

  renderLetters();
  renderWords();

  root.appendChild(lettersRow);
  root.appendChild(wordsBox);
  return root;
}


function drawSitelenRasterLocal(el, x, y, w, h){
  // Optional background box if fill/stroke present (same logic as your text)
  if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
    ctx.save();
    ctx.fillStyle = el.fill;
    ctx.fillRect(x, y, w, h);
    ctx.restore();
  }
  if ((el.strokeW ?? 0) > 0){
    ctx.save();
    ctx.lineWidth = (el.strokeW ?? 1);
    ctx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
    ctx.strokeRect(x, y, w, h);
    ctx.restore();
  }

  // Ensure raster exists
  const entry = ensureSitelenRaster(el);
  if (entry && entry.canvas){
    // Draw like image: rotate/stretch handled by caller transform and drawImage scaling
    ctx.drawImage(entry.canvas, x, y, w, h);
  } else {
    // placeholder
    ctx.save();
    ctx.strokeStyle = "rgba(17,17,17,0.28)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.strokeRect(x+1, y+1, w-2, h-2);
    ctx.setLineDash([]);
    ctx.restore();
  }
}



  function drawGlyphLocal(el, x,y,w,h){
    // Optional background box if fill/stroke present
    if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
      ctx.save();
      ctx.fillStyle = el.fill;
      ctx.fillRect(x,y,w,h);
      ctx.restore();
    }

    const cp = parseCodepointInput(el.codepoint);
    const ch = (typeof cp === "number") ? String.fromCodePoint(cp) : "?";
    const fontSize = Math.max(6, (el.fontSize ?? 64) * Scene.view.zoom);
    const fontFamily = el.fontFamily || "TP-Cartouche-Font";

    ctx.save();
    ctx.fillStyle = el.color || "#111";
    ctx.font = `${fontSize}px ${cssFontFamily(fontFamily)}, system-ui, sans-serif`;
    ctx.textBaseline = "middle";
    ctx.textAlign = "center";

    const cx = x + w/2;
    const cy = y + h/2;

    ctx.fillText(ch, cx, cy);

    // optional border box for glyph (if strokeW)
    if ((el.strokeW ?? 0) > 0){
      ctx.save();
      ctx.lineWidth = (el.strokeW ?? 1);
      ctx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }
    ctx.restore();
  }

  function drawImageLocal(el, x,y,w,h){
    // CHANGE HERE: Image background is always transparent when an image is loaded
    const hasImage = !!(el.image && el.image.assetId && getImageAssetDataUrl(el.image.assetId));

    if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
      ctx.save();
      ctx.fillStyle = el.fill;
      ctx.fillRect(x,y,w,h);
      ctx.restore();
    }

    const img = ensureImageLoadedForElement(el);
    if (img){
      ctx.drawImage(img, x, y, w, h);
    } else {
      // placeholder
      ctx.save();
      ctx.strokeStyle = "rgba(17,17,17,0.28)";
      ctx.lineWidth = 2;
      ctx.setLineDash([6,4]);
      ctx.strokeRect(x+1,y+1,w-2,h-2);
      ctx.setLineDash([]);
      ctx.fillStyle = "rgba(17,17,17,0.55)";
      ctx.font = `${Math.max(12, 16*Scene.view.zoom)}px "PatrickHand", system-ui, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Image (embedded)", x+w/2, y+h/2);
      ctx.restore();
    }

    if ((el.strokeW ?? 0) > 0){
      ctx.save();
      ctx.lineWidth = (el.strokeW ?? 1);
      ctx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
      ctx.strokeRect(x,y,w,h);
      ctx.restore();
    }
  }

  function drawSelectionOverlay(){
    const sels = getSelectedElements();
    if (!sels.length) return;

    // highlight each selected element outline
    ctx.save();
    ctx.strokeStyle = "rgba(17,17,17,0.65)";
    ctx.lineWidth = 2;

    for (const el of sels){
      const cs = elementCorners(el).map(stageToScreen);
      ctx.beginPath();
      ctx.moveTo(cs[0].x, cs[0].y);
      for (let i=1;i<cs.length;i++) ctx.lineTo(cs[i].x, cs[i].y);
      ctx.closePath();
      ctx.stroke();
    }
    ctx.restore();

    // union AABB + handles
    const aabb = getSelectionAabb();
    const tl = stageToScreen({x:aabb.x, y:aabb.y});
    const br = stageToScreen({x:aabb.x + aabb.w, y:aabb.y + aabb.h});
    const x = tl.x, y = tl.y, w = br.x - tl.x, h = br.y - tl.y;

    ctx.save();
    ctx.strokeStyle = "rgba(17,17,17,0.35)";
    ctx.setLineDash([6,4]);
    ctx.lineWidth = 2;
    ctx.strokeRect(x,y,w,h);
    ctx.setLineDash([]);
    ctx.restore();

    const hs = handlesForAabb(aabb);

    // draw handles
    function drawHandle(box, fill){
      const p = stageToScreen({x:box.x, y:box.y});
      const q = stageToScreen({x:box.x+box.w, y:box.y+box.h});
      ctx.save();
      ctx.fillStyle = fill;
      ctx.strokeStyle = "rgba(17,17,17,0.55)";
      ctx.lineWidth = 1;
      ctx.fillRect(p.x, p.y, q.x - p.x, q.y - p.y);
      ctx.strokeRect(p.x, p.y, q.x - p.x, q.y - p.y);
      ctx.restore();
    }

    const fill = "rgba(255,255,255,0.85)";
    drawHandle(hs.ResizeNW, fill);
    drawHandle(hs.ResizeN, fill);
    drawHandle(hs.ResizeNE, fill);
    drawHandle(hs.ResizeE, fill);
    drawHandle(hs.ResizeSE, fill);
    drawHandle(hs.ResizeS, fill);
    drawHandle(hs.ResizeSW, fill);
    drawHandle(hs.ResizeW, fill);
    drawHandle(hs.Rotate, "rgba(255,255,255,0.95)");

    // draw line to rotate handle
    const c = stageToScreen(hs.center);
    const r = stageToScreen(hs.rotPt);
    ctx.save();
    ctx.strokeStyle = "rgba(17,17,17,0.55)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(c.x, y);
    ctx.lineTo(r.x, r.y + 6);
    ctx.stroke();
    ctx.restore();
  }

  function drawMarquee(mq){
    const p0 = stageToScreen({x:mq.x0, y:mq.y0});
    const p1 = stageToScreen({x:mq.x1, y:mq.y1});
    const x = Math.min(p0.x,p1.x);
    const y = Math.min(p0.y,p1.y);
    const w = Math.abs(p1.x-p0.x);
    const h = Math.abs(p1.y-p0.y);

    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.25)";
    ctx.strokeStyle = "rgba(17,17,17,0.45)";
    ctx.lineWidth = 2;
    ctx.setLineDash([6,4]);
    ctx.fillRect(x,y,w,h);
    ctx.strokeRect(x,y,w,h);
    ctx.setLineDash([]);
    ctx.restore();
  }

  /* ============================================================
     UI: Properties panel
     ============================================================ */
  const propsBody = $("propsBody");

  function setDisabled(id, v){
    $(id).disabled = !!v;
  }

  function updateUiForSelection(){
    const sels = getSelectedElements();
    const has = sels.length > 0;

    const locked = sels.some(e => !!e.isLocked);

    setDisabled("btnBringFwd", !has || locked);
    setDisabled("btnSendBack", !has || locked);

    // group buttons
    setDisabled("btnGroup", locked || !(sels.length >= 2 && !getGroupIdFromSelection()));
    setDisabled("btnUngroup", locked || !getGroupIdFromSelection());


    renderPropsPanel();
    updateClipboardButtons();

  }

  function commonValue(els, getter){
    if (!els.length) return null;
    const v0 = getter(els[0]);
    for (const e of els){
      if (getter(e) !== v0) return null;
    }
    return v0;
  }

function makeReadOnlyRow(label, value){
  const f = document.createElement("div");
  f.className = "field";
  const l = document.createElement("label");
  l.textContent = label;
  const inp = document.createElement("input");
  inp.type = "text";
  inp.value = String(value ?? "");
  inp.disabled = true;
  f.appendChild(l);
  f.appendChild(inp);
  return f;
}

function makeLockCheckbox(sels){
  const f = document.createElement("div");
  f.className = "field";

  const l = document.createElement("label");
  l.textContent = "Locked";

  const cb = document.createElement("input");
  cb.type = "checkbox";

  const any = sels.some(e => !!e.isLocked);
  const all = sels.every(e => !!e.isLocked);

  cb.checked = all;
  cb.indeterminate = (!all && any); // mixed state

  cb.addEventListener("change", () => {
    const v = !!cb.checked;
    for (const e of sels) e.isLocked = v;
    scheduleAutosave();
    updateUiForSelection(); // re-render props + buttons
    render();
    historyCommit("Edit properties");
  });

  f.appendChild(l);
  f.appendChild(cb);
  return f;
}


function makeCheckbox(label, checked, onChange){
  const row = document.createElement("div");
  row.className = "row";

  const f = document.createElement("div");
  f.className = "field";

  const l = document.createElement("label");
  l.textContent = label;

  const wrap = document.createElement("div");
  wrap.style.display = "flex";
  wrap.style.alignItems = "center";
  wrap.style.gap = "10px";

  const cb = document.createElement("input");
  cb.type = "checkbox";
  cb.checked = !!checked;
  cb.addEventListener("change", () => { onChange(cb.checked); historyCommit("Edit properties"); });

  const txt = document.createElement("div");
  txt.style.fontSize = "13px";
  txt.style.color = "var(--muted)";
  txt.textContent = cb.checked ? "On" : "Off";

  cb.addEventListener("change", () => { txt.textContent = cb.checked ? "On" : "Off"; historyCommit("Edit properties"); });

  wrap.appendChild(cb);
  wrap.appendChild(txt);

  f.appendChild(l);
  f.appendChild(wrap);
  row.appendChild(f);
  return row;
}


  function renderPropsPanel(){
  propsBody.innerHTML = "";

  const sels = getSelectedElements();
  if (!sels.length){
    propsBody.innerHTML = `<div class="hint">Select an element to edit its properties.</div>`;
    return;
  }

const single = sels.length === 1;

// “Active” group if either:
// - multi-select where all selected share the same groupId, OR
// - single-select where the element belongs to a group
const groupId = getGroupIdFromSelection() || (single ? (sels[0].groupId || null) : null);


  // Small section divider
  function addSection(title){
    const d = document.createElement("div");
    d.className = "hint";
    d.style.background = "rgba(255,255,255,0.22)";
    d.style.borderStyle = "dashed";
    d.style.padding = "8px 10px";
    d.style.fontSize = "13px";
    d.textContent = title;
    propsBody.appendChild(d);
  }

  // Header
  const header = document.createElement("div");
  header.className = "hint";
  header.textContent = single
    ? `Selected: ${sels[0].type} (${sels[0].id})`
    : (groupId ? `Selected: group (${sels.length} items)  [${groupId}]` : `Selected: ${sels.length} items`);
  propsBody.appendChild(header);


  // CHANGE HERE: isLocked is always the first editable property
propsBody.appendChild(makeLockCheckbox(sels));

// CHANGE HERE: if ANY selected element is locked, block all other property editing
if (sels.some(e => !!e.isLocked)){
  const msg = document.createElement("div");
  msg.className = "hint";
  msg.textContent = "This selection contains locked element(s). Unlock to edit or transform.";
  propsBody.appendChild(msg);
  return;
}

  // Common values for multi or single
  const commonFill = commonValue(sels, e => e.fill);
  const commonFillEnabled = commonValue(sels, e => e.fillEnabled);
  const commonStroke = commonValue(sels, e => e.stroke);
  const commonOpacity = commonValue(sels, e => String(e.opacity ?? 1));
  const commonStrokeW = commonValue(sels, e => String(e.strokeW ?? 0));

  // Helper: common appearance block (useful for both single and multi)
  function addAppearanceBlock(){
    addSection("Appearance");

    propsBody.appendChild(makeCheckbox("Allow fill", (commonFillEnabled ?? sels[0].fillEnabled) || false, (v) => {
      for (const e of sels) e.fillEnabled = !!v; // if multi-select supported
      scheduleAutosave();
      render();
    }));

    propsBody.appendChild(makeColorPicker(
      "Fill",
      (commonFill ?? sels[0].fill) || "#FFFFFF",
      (v) => {
        // LIVE preview only
        for (const e of sels) {
          console.log("Live fill :" + v);
          e.fill = rgbaOrHexToHex(v, "#FFFFFF");

          if (e.type === ElementType.Sitelen){
            invalidateSitelenCache(e.id);
            updateSitelenLayout(e, { preserveCenter: true });
          }
        }

        render();
      },
      (v) => {
        // COMMIT
        for (const e of sels) {
          console.log("Commit fill :" + v);
          e.fill = rgbaOrHexToHex(v, "#FFFFFF");

          if (e.type === ElementType.Sitelen){
            invalidateSitelenCache(e.id);
            updateSitelenLayout(e, { preserveCenter: true });
          }
        }

        scheduleAutosave();
        render();
        renderPropsPanel(); // safe now
      }
    ));




    propsBody.appendChild(makeColorPicker(
       "Stroke",
     (commonStroke ?? sels[0].stroke) || "#111111",
      (v) => {
        // LIVE preview only
        for (const e of sels) {
          console.log("Live stroke :" + v);
          e.stroke = rgbaOrHexToHex(v, "#111111");

          if (e.type === ElementType.Sitelen){
            invalidateSitelenCache(e.id);
            updateSitelenLayout(e, { preserveCenter: true });
          }
        }

        render();
      },
      (v) => {
        // COMMIT
        for (const e of sels) {
          console.log("Commit stroke :" + v);
          e.stroke = rgbaOrHexToHex(v, "#111111");

          if (e.type === ElementType.Sitelen){
            invalidateSitelenCache(e.id);
            updateSitelenLayout(e, { preserveCenter: true });
          }
        }

        scheduleAutosave();
        render();
        renderPropsPanel(); // safe now
      }
    ));

    propsBody.appendChild(makeNumberRow(
      "strokeW",
      "Stroke width",
      Number(commonStrokeW ?? sels[0].strokeW ?? 0),
      1,
      (v) => { for (const e of sels) e.strokeW = Math.max(0, v); scheduleAutosave(); render(); },
      (commonStrokeW === null && !single) ? "Mixed" : null
    ));

    propsBody.appendChild(makeNumberRow(
      "opacity",
      "Opacity (0..1)",
      Number(commonOpacity ?? (sels[0].opacity ?? 1)),
      0.05,
      (v) => { for (const e of sels) e.opacity = clamp(v, 0, 1); scheduleAutosave(); render(); },
      (commonOpacity === null && !single) ? "Mixed" : null,
      0,
      1
    ));
  }

// Group-level controls (show whenever we have a groupId)
if (groupId){
  addSection("Group");

  const g = Scene.groups[groupId] || (Scene.groups[groupId] = {
    id: groupId,
    createdAt: new Date().toISOString(),
    foreground: "#111111"
  });

  const fg = rgbaOrHexToHex(g.foreground || "#111111", "#111111");

  propsBody.appendChild(makeColorPicker(
    "Foreground (group)",
    fg,
    (v) => {            // LIVE preview only
      console.log("Live group foreground :" + v);
      applyGroupForeground(groupId, v);
      render();
    },
    (v) => {            // COMMIT
      console.log("Commit group foreground :" + v);
      applyGroupForeground(groupId, v);
      scheduleAutosave();
      render();
      renderPropsPanel();
    }
  ));
}

// If multi-select: show only common controls after group controls
if (!single){
  addAppearanceBlock();
  return;
}



  // Single selection: type-specific “useful first”
  const el = sels[0];

  if (el.type === ElementType.Text || el.type === ElementType.Sitelen){
    addSection( el.type === ElementType.Sitelen ? "Sitelen" : "Text");

    //used for text placeholder
    let placeholder = "";

        // ADD: Sitelen keepAspect (same behavior as Image)
    if (el.type === ElementType.Sitelen){
      //set the sitelen placeholder text
      //placeholder = "toki pona";
      placeholder = "mi kama sona e toki pona.\n" +
  ": sewi^ ni ni^ ni> ni< .\n" +
  "[ ota  kolon en ]\n" +
    "nanpa -12,340.57.\n" +
  "nanpa #~IIM.\n" +
  "nanpa Newen.\n" +
  "Unknown words ignored without double quotes.\n";

      //add aspect ratio checkbox
      propsBody.appendChild(makeCheckbox(
        "Keep aspect ratio",
        (el.keepAspect == null) ? true : !!el.keepAspect,
        (checked) => {
          const prev = (el.keepAspect == null) ? true : !!el.keepAspect;
          el.keepAspect = !!checked;

          // If turning OFF -> ON: revert to original "natural" size; keep center stable
          if (!prev && el.keepAspect){
            const cx = el.x + el.w/2;
            const cy = el.y + el.h/2;

            const r = ensureSitelenRaster(el);
            const ow =
              (el.sitelen && Number.isFinite(el.sitelen.origW)) ? el.sitelen.origW :
              (r ? r.naturalW : el.w);
            const oh =
              (el.sitelen && Number.isFinite(el.sitelen.origH)) ? el.sitelen.origH :
              (r ? r.naturalH : el.h);

            el.w = Math.max(8, ow);
            el.h = Math.max(8, oh);
            el.x = cx - el.w/2;
            el.y = cy - el.h/2;
          }

          scheduleAutosave();
          render();
          updateUiForSelection();
        }
      ));

      // ADD: read-only sizes (parallel to Image panel)
      const r = ensureSitelenRaster(el);
      const natW = (el.sitelen && Number.isFinite(el.sitelen.naturalW)) ? el.sitelen.naturalW : (r ? r.naturalW : null);
      const natH = (el.sitelen && Number.isFinite(el.sitelen.naturalH)) ? el.sitelen.naturalH : (r ? r.naturalH : null);

      if (natW && natH){
        propsBody.appendChild(makeReadOnlyRow("Rendered (intrinsic) size", `${natW} × ${natH}`));
      } else {
        propsBody.appendChild(makeReadOnlyRow("Rendered (intrinsic) size", "—"));
      }

      const origW = (el.sitelen && Number.isFinite(el.sitelen.origW)) ? el.sitelen.origW : el.w;
      const origH = (el.sitelen && Number.isFinite(el.sitelen.origH)) ? el.sitelen.origH : el.h;
      propsBody.appendChild(makeReadOnlyRow("Original box size", `${Number(origW)} × ${Number(origH)}`));
    }

    

    propsBody.appendChild(makeTextarea("Text", el.text ?? "", placeholder   ,(v) => {
      el.text = v;

      if (el.type === ElementType.Sitelen){
        invalidateSitelenCache(el.id);
        updateSitelenLayout(el, { preserveCenter: true });
      }

      scheduleAutosave();
      render();
    }));


    if (el.type === ElementType.Text){
      propsBody.appendChild(makeCheckbox(
        "Scale font with box",
        !!el.scaleFontWithBox,
        (checked) => {
          el.scaleFontWithBox = !!checked;
          scheduleAutosave();
          render();
          updateUiForSelection();
        }
      ));
    }

    // CHANGE HERE: Font family dropdown
    // CHANGE HERE: Sitelen defaults to PatrickHand
    const defaultFont = "PatrickHand";
    const currentFont = coerceFontValueToOption(el.fontFamily, defaultFont);


    propsBody.appendChild(makeSelect("Font family", currentFont, FONT_OPTIONS, (v) => {
        el.fontFamily = v;

        if (el.type === ElementType.Sitelen){
          invalidateSitelenCache(el.id);
          updateSitelenLayout(el, { preserveCenter: true });
        }

        scheduleAutosave(); 
        render();
    }));


    propsBody.appendChild(makeNumberRowWithPresets(
  "fontSize",
  "Font size",
  Number(el.fontSize ?? 24),
  1,
  FONT_SIZE_PRESETS,
  (v) => {
    el.fontSize = Math.max(6, v);

    if (el.type === ElementType.Sitelen){
      invalidateSitelenCache(el.id);
      updateSitelenLayout(el, { preserveCenter: true });
    }

    scheduleAutosave();
    render();
  },
  null,
  6,
  9999
));


    propsBody.appendChild(makeSelect("Align", el.align ?? "left", [
      ["left","Left"],["center","Center"],["right","Right"]
    ], (v) => {
  el.align = v;

  if (el.type === ElementType.Sitelen){
    invalidateSitelenCache(el.id);
    updateSitelenLayout(el, { preserveCenter: true });
  }

  scheduleAutosave();
  render();
  updateUiForSelection();
}));

   propsBody.appendChild(makeColorPicker(
      "Text color",
      el.color ?? "#111111",
      (v) => {
        // LIVE preview only
        console.log("Live text colour :" + v);
        el.color =  rgbaOrHexToHex(v, "#111111");

        if (el.type === ElementType.Sitelen){
          invalidateSitelenCache(el.id);
          updateSitelenLayout(el, { preserveCenter: true });
        }

        render();
      },
      (v) => {
        // COMMIT
        console.log("Commit text colour :" + v);
        el.color =  rgbaOrHexToHex(v, "#111111");

        if (el.type === ElementType.Sitelen){
          invalidateSitelenCache(el.id);
          updateSitelenLayout(el, { preserveCenter: true });
        }

        scheduleAutosave();
        render();
        renderPropsPanel(); // safe now
      }
    ));



    propsBody.appendChild(makeNumberRow("lineHeight", "Line height", Number(el.lineHeight ?? 1.15), 0.05, (v) => {
      el.lineHeight = clamp(v, 0.8, 3.0); scheduleAutosave(); render();
    }, null, 0.8, 3.0));

    // Then appearance (background/stroke/opacity)
    addAppearanceBlock();

  } else if (el.type === ElementType.Glyph){
    addSection("Glyph");



    // Enforce fixed font family (do not allow editing)
  el.fontFamily = "TP-Cartouche-Font";

    //propsBody.appendChild(makeTextRow("Code point (U+.... or 0x.... or single char)", el.codepoint ?? "", (v) => {
    //  el.codepoint = v; scheduleAutosave(); render();
    //}));
    // CHANGE HERE: 2-step glyph picker (letter -> words)
propsBody.appendChild(makeGlyphPicker(el));


    propsBody.appendChild(makeCheckbox(
      "Scale font with box",
      !!el.scaleFontWithBox,
      (checked) => {
        el.scaleFontWithBox = !!checked;
        scheduleAutosave();
        render();
        updateUiForSelection();
      }
    ));

 propsBody.appendChild(makeNumberRowWithPresets(
  "fontSize",
  "Font size",
  Number(el.fontSize ?? 64),
  1,
  FONT_SIZE_PRESETS,
  (v) => { el.fontSize = Math.max(6, v); scheduleAutosave(); render(); },
  null,
  6,
  9999
));


propsBody.appendChild(makeColorPicker(
      "Glyph color",
      el.color ?? "#111111",
      (v) => {
        // LIVE preview only
        console.log("Live glyph colour :" + v);
        el.color =  rgbaOrHexToHex(v, "#111111");
        render();
      },
      (v) => {
        // COMMIT
        console.log("Commit glyph colour :" + v);
        el.color =  rgbaOrHexToHex(v, "#111111")

        scheduleAutosave();
        render();
        renderPropsPanel(); // safe now
      }
    ));




    addAppearanceBlock();

  } else if (el.type === ElementType.Image){
    addSection("Image");

    const row = document.createElement("div");
    row.className = "row";

    const b = document.createElement("button");
    b.className = "btn";
    b.type = "button";
    b.textContent = el.image ? "Replace image…" : "Load image…";
    b.addEventListener("click", () => pickImageForElement(el));
    row.appendChild(b);

    const b2 = document.createElement("button");
    b2.className = "btn";
    b2.type = "button";
    b2.textContent = "Clear image";
    b2.disabled = !el.image;
    b2.addEventListener("click", () => {
      el.image = null;
      invalidateImageCache(el.id);
      scheduleAutosave(); render(); updateUiForSelection();
    });
    row.appendChild(b2);

    propsBody.appendChild(row);

    const note = document.createElement("div");
    note.className = "hint";
    note.textContent = el.image
      ? `Embedded image: ${el.image.mime}, ${el.image.naturalW}×${el.image.naturalH}`
      : "No image loaded. Images are embedded (no external links).";
    propsBody.appendChild(note);




  // CHANGE HERE: keepAspect checkbox (default true)
  propsBody.appendChild(makeCheckbox("Keep aspect ratio", (el.keepAspect == null) ? true : !!el.keepAspect, (checked) => {
    const prev = (el.keepAspect == null) ? true : !!el.keepAspect;
    el.keepAspect = !!checked;

    // If turning OFF -> ON: revert to original loaded box size (keep rotation; keep center stable)
    if (!prev && el.keepAspect && el.image && Number.isFinite(el.image.origW) && Number.isFinite(el.image.origH)){
      const cx = el.x + el.w/2;
      const cy = el.y + el.h/2;
      el.w = Math.max(8, el.image.origW);
      el.h = Math.max(8, el.image.origH);
      el.x = cx - el.w/2;
      el.y = cy - el.h/2;
    }

    scheduleAutosave();
    render();
    updateUiForSelection();
  }));


// CHANGE HERE: read-only sizes
  if (el.image){
    propsBody.appendChild(makeReadOnlyRow("Loaded (intrinsic) size", `${el.image.naturalW} × ${el.image.naturalH}`));
    propsBody.appendChild(makeReadOnlyRow("Original box size", `${Number(el.image.origW ?? el.w)} × ${Number(el.image.origH ?? el.h)}`));
  } else {
    propsBody.appendChild(makeReadOnlyRow("Loaded (intrinsic) size", "—"));
    propsBody.appendChild(makeReadOnlyRow("Original box size", "—"));
  }

    addAppearanceBlock();

  } else if (el.type === ElementType.Rect){
    addSection("Shape");

    // For rectangles, appearance is often first
    addAppearanceBlock();

    propsBody.appendChild(makeNumberRow("radius", "Corner radius", Number(el.radius ?? 0), 1, (v) => {
      el.radius = Math.max(0, v); scheduleAutosave(); render();
    }));
  } else {
    // Fallback: still give appearance controls
    addAppearanceBlock();
  }

  // Geometry last (because user can drag on canvas)
  addSection("Geometry");

  propsBody.appendChild(makeNumberRow("x", "X", el.x, 1, (v) => { el.x = v; scheduleAutosave(); render(); }));
  propsBody.appendChild(makeNumberRow("y", "Y", el.y, 1, (v) => { el.y = v; scheduleAutosave(); render(); }));
  propsBody.appendChild(makeNumberRow("w", "W", el.w, 1, (v) => { el.w = Math.max(8, v); scheduleAutosave(); render(); }));
  propsBody.appendChild(makeNumberRow("h", "H", el.h, 1, (v) => { el.h = Math.max(8, v); scheduleAutosave(); render(); }));
  propsBody.appendChild(makeNumberRow("rot", "Rotation (deg)", el.rotationDeg || 0, 1, (v) => { el.rotationDeg = v; scheduleAutosave(); render(); }));
}

// CHANGE HERE: static font options for dropdown
const FONT_OPTIONS = [
  ["PatrickHand", "Patrick Hand"], // NOTE: must match your @font-face family name
  ["Arial, Helvetica, sans-serif", "Arial"],
  ["'Times New Roman', Times, serif", "Times New Roman"],
  ["'Courier New', Courier, monospace", "Courier New"],
  ["system-ui, -apple-system, 'Segoe UI', Roboto, Arial, sans-serif", "system-ui"],
];

// CHANGE HERE: preset sizes shown in the dropdown
const FONT_SIZE_PRESETS = [8,10,12,14,16,18,20,22,24,28,32,36,40,44,48,56,64,72,80,92,104,120,144];


function coerceFontValueToOption(v, fallback){
  const raw = String(v ?? "").trim();
  const vals = new Set(FONT_OPTIONS.map(([val]) => val));
  return vals.has(raw) ? raw : fallback;
}

// CHANGE HERE: number row with a preset dropdown to the right
function makeNumberRowWithPresets(
  id,
  label,
  value,
  step,
  presets,
  onChange,
  placeholder = null,
  min = null,
  max = null
){
  const row = document.createElement("div");
  row.className = "row";

  const f = document.createElement("div");
  f.className = "field";

  const l = document.createElement("label");
  l.textContent = label;

  // Inline container: number input + select
  const inline = document.createElement("div");
  inline.className = "propInlineRow";

  const inp = document.createElement("input");
  inp.type = "number";
  inp.step = String(step ?? 1);
  if (min != null) inp.min = String(min);
  if (max != null) inp.max = String(max);
  if (placeholder != null) inp.placeholder = String(placeholder);
  inp.value = (value == null) ? "" : String(value);

  const sel = document.createElement("select");

  // First option = "Custom" (blank value)
  const optCustom = document.createElement("option");
  optCustom.value = "";
  optCustom.textContent = "Custom";
  sel.appendChild(optCustom);

  // Preset options
  const presetNums = Array.from(presets ?? []).map(n => Number(n)).filter(n => Number.isFinite(n)).sort((a,b)=>a-b);
  for (const n of presetNums){
    const o = document.createElement("option");
    o.value = String(n);
    o.textContent = String(n);
    sel.appendChild(o);
  }

  function syncSelectFromInput(){
    const n = Number(inp.value);
    if (!Number.isFinite(n)) { sel.value = ""; return; }
    const match = presetNums.includes(n) ? String(n) : "";
    sel.value = match;
  }

  // Initialize select state
  syncSelectFromInput();

  // Typing in the number box
  inp.addEventListener("input", () => {
    syncSelectFromInput();
    const n = Number(inp.value);
    if (!Number.isFinite(n)) return;
    onChange(n);
  });
  inp.addEventListener("change", () => {
    syncSelectFromInput();
    const n = Number(inp.value);
    if (!Number.isFinite(n)) return;
    onChange(n);
    historyCommit("Edit properties");
  });

  // Choosing a preset
  sel.addEventListener("change", () => {
    if (!sel.value){
      // "Custom" selected: do nothing, user types a value
      return;
    }
    const n = Number(sel.value);
    if (!Number.isFinite(n)) return;
    inp.value = String(n);
    onChange(n);
    historyCommit("Edit properties");
  });

  inline.appendChild(inp);
  inline.appendChild(sel);

  f.appendChild(l);
  f.appendChild(inline);

  row.appendChild(f);
  return row;
}



  function makeNumberRow(id, label, value, step, onChange, placeholder=null, min=null, max=null){
    const row = document.createElement("div");
    row.className = "row";
    const f = document.createElement("div");
    f.className = "field";
    const l = document.createElement("label");
    l.textContent = label;
    const inp = document.createElement("input");
    inp.type = "number";
    inp.step = String(step ?? 1);
    inp.value = String(Number.isFinite(value) ? value : 0);
    if (placeholder) inp.placeholder = placeholder;
    if (min != null) inp.min = String(min);
    if (max != null) inp.max = String(max);
    inp.addEventListener("input", () => {
      const v = Number(inp.value);
      if (!Number.isFinite(v)) return;
      onChange(v);
    });
    f.appendChild(l); f.appendChild(inp);
    row.appendChild(f);
    return row;
  }

  function makeTextRow(label, value, onChange){
    const row = document.createElement("div");
    row.className = "row";
    const f = document.createElement("div");
    f.className = "field";
    const l = document.createElement("label");
    l.textContent = label;
    const inp = document.createElement("input");
    inp.type = "text";
    inp.value = String(value ?? "");
    inp.addEventListener("input", () => onChange(inp.value));
    f.appendChild(l); f.appendChild(inp);
    row.appendChild(f);
    return row;
  }

  function makeTextarea(label, value, placeholder, onChange){
    const f = document.createElement("div");
    f.className = "field";
    const l = document.createElement("label");
    l.textContent = label;
    const ta = document.createElement("textarea");
    ta.value = String(value ?? "");
    ta.placeholder=placeholder;
    ta.addEventListener("input", () => onChange(ta.value));
    f.appendChild(l); f.appendChild(ta);
    return f;
  }

  function makeSelect(label, value, options, onChange){
    const f = document.createElement("div");
    f.className = "field";
    const l = document.createElement("label");
    l.textContent = label;
    const sel = document.createElement("select");
    for (const [val, txt] of options){
      const opt = document.createElement("option");
      opt.value = val;
      opt.textContent = txt;
      if (val === value) opt.selected = true;
      sel.appendChild(opt);
    }
    sel.addEventListener("change", () =>  { onChange(sel.value); historyCommit("Edit properties"); });
    f.appendChild(l); f.appendChild(sel);
    return f;
  }


function makeColorPicker(label, value, onLive, onCommit){
  const f = document.createElement("div");
  f.className = "field";

  const l = document.createElement("label");
  l.textContent = label;

  const inp = document.createElement("input");
  inp.type = "color";
  inp.value = rgbaOrHexToHex(value || "#111111", "#111111") ;

  // Live preview: do NOT rebuild props panel here.
  inp.addEventListener("input", (e) => {
    console.log("Colou Input Event");
    try { 
      const newValue = rgbaOrHexToHex(e.target.value || "#111111", "#111111") ;
      if (onLive) onLive(newValue); 
    } catch (err) { 
      console.warn(err); 
    }
  });

  // Commit: picker closed (most reliable across browsers).
  inp.addEventListener("change", (e) => {
    console.log("Colou Change Event");
    try {
      const newValue = rgbaOrHexToHex(e.target.value || "#111111", "#111111") ;
      if (onLive) onLive(newValue);
      // Ensure final value applied even if some browsers don't emit input as expected
      if (onCommit) {onCommit(newValue); historyCommit("Edit properties");}
    } catch (err) {
      console.warn(err);
    }
  });

  f.appendChild(l);
  f.appendChild(inp);
  return f;
}



  /* ============================================================
     Grouping
     ============================================================ */
  function groupSelection(){
    const sels = getSelectedElements();
    if (sels.length < 2) return;
    // Do not group if selection already all in same group
    if (getGroupIdFromSelection()) return;

    const gid = uid("grp");

    // Prefer the common color of text-like elements (if any), else default
    const textLikes = sels.filter(isTextLikeElement);
    const commonFg = commonValue(textLikes, e => e.color) || "#111111";

    Scene.groups[gid] = { id: gid, createdAt: new Date().toISOString(), foreground: commonFg };

    for (const el of sels) el.groupId = gid;


    // Selection becomes all in group (already is)
    scheduleAutosave();
    updateUiForSelection();
    render();
    historyCommit("Group");
    setStatus(`Grouped (${sels.length}).`);
  }

  function ungroupSelection(){
    const gid = getGroupIdFromSelection();
    if (!gid) return;
    const els = getElementsInGroup(gid);
    for (const el of els) el.groupId = null;
    delete Scene.groups[gid];

    // keep selection as ungrouped elements
    selectOnlyElements(els.map(e => e.id));
    scheduleAutosave();
    updateUiForSelection();
    render();
    historyCommit("Ungroup");
    setStatus("Ungrouped.");
  }

  /* ============================================================
     Layer order
     ============================================================ */
  function bringForward(){
    const ids = [...selectedIds];
    if (!ids.length) return;
    // Move selected elements one step forward preserving internal order
    const idxs = ids.map(id => Scene.elements.findIndex(e => e.id === id)).filter(i => i >= 0).sort((a,b)=>b-a);
    for (const i of idxs){
      if (i < Scene.elements.length - 1){
        const tmp = Scene.elements[i];
        Scene.elements[i] = Scene.elements[i+1];
        Scene.elements[i+1] = tmp;
      }
    }
    scheduleAutosave(); render();
  }

 function bringForwardZ(){
  moveSelectionZ(+1);
  scheduleAutosave();
  render();
  historyCommit("Reorder");
  updateUiForSelection();
}

  function sendBackward(){
    const ids = [...selectedIds];
    if (!ids.length) return;
    const idxs = ids.map(id => Scene.elements.findIndex(e => e.id === id)).filter(i => i >= 0).sort((a,b)=>a-b);
    for (const i of idxs){
      if (i > 0){
        const tmp = Scene.elements[i];
        Scene.elements[i] = Scene.elements[i-1];
        Scene.elements[i-1] = tmp;
      }
    }
    scheduleAutosave(); render();
  }

  function sendBackwardZ(){
    moveSelectionZ(-1);
    scheduleAutosave();
    render();
    historyCommit("Reorder");
    updateUiForSelection();
  }

//copy/paste
function copySelection(){
  if (selectionIsEmpty()){
    setStatus("Copy: nothing selected.");
    return;
  }

  const ids = selectionIdsArray();
  const els = ids.map(getElementById).filter(Boolean);

  // If selection corresponds to exactly one group, preserve it on paste as a new group
  const gid = getGroupIdFromSelection();
  const hadSingleGroup = !!gid;

  const copiedGroups = {};
  if (hadSingleGroup && Scene.groups[gid]){
    copiedGroups[gid] = deepClone(Scene.groups[gid]);
  }

  CLIPBOARD.elements = deepClone(els);
  CLIPBOARD.groups = copiedGroups;
  CLIPBOARD.hadSingleGroup = hadSingleGroup;
  CLIPBOARD.sourceGroupId = gid || null;
  CLIPBOARD.pasteIndex = 0;

  if (CLIPBOARD.hadSingleGroup && CLIPBOARD.sourceGroupId) {
    const grp = Scene.groups?.[CLIPBOARD.sourceGroupId] || null;
    CLIPBOARD.sourceGroupRecord = grp ? deepClone(grp) : null;
  } else {
    CLIPBOARD.sourceGroupRecord = null;
  }

  setStatus(`Copied ${els.length} element${els.length === 1 ? "" : "s"}.`);
  updateClipboardButtons();

}

function cutSelection(){
  if (selectionIsEmpty()){
    setStatus("Cut: nothing selected.");
    return;
  }

  // Block cutting locked elements (consistent with your delete rules)
  if (selectionHasLocked()){
    window.alert("This selection contains locked element(s). Unlock before cutting.");
    setStatus("Cut blocked: locked element(s).");
    return;
  }

  copySelection();

  const idsSet = new Set(selectionIdsArray());
  removeElementsByIds(idsSet);
  selectedIds.clear();

  scheduleAutosave();
  updateUiForSelection();
  render();
  historyCommit("Cut");
  setStatus("Cut.");
  updateClipboardButtons();

}

function pasteClipboard(){
  if (!CLIPBOARD.elements || !Array.isArray(CLIPBOARD.elements) || CLIPBOARD.elements.length === 0){
    setStatus("Paste: clipboard empty.");
    return;
  }

  // Compute a sensible offset (stage units). Use grid size if available.
  const base = Math.max(10, Number(Scene.stage.gridSize || 20));
  CLIPBOARD.pasteIndex += 1;
  const dx = base * 0.6 * CLIPBOARD.pasteIndex; // slightly smaller than one full grid step
  const dy = base * 0.6 * CLIPBOARD.pasteIndex;

  // Map old element ids -> new element ids
  const idMap = new Map();

  // If selection was a single group, create a new group for pasted items
// If selection was a single group, create a new group for pasted items
let newGroupId = null;
if (CLIPBOARD.hadSingleGroup && CLIPBOARD.sourceGroupId) {
  newGroupId = uid("grp");

  const nowIso = new Date().toISOString();
  const srcGrp = CLIPBOARD.sourceGroupRecord || Scene.groups?.[CLIPBOARD.sourceGroupId] || null;

  // Clone source group metadata if available; otherwise fall back to minimal record
  const newGrp = srcGrp ? deepClone(srcGrp) : {};

  // Force identity + timestamps for the new group
  newGrp.id = newGroupId;

  // Preserve original createdAt if you want provenance; or overwrite (choose one):
  // Option A: treat paste as "newly created"
  newGrp.createdAt = nowIso;

  // Optional: if you track modifiedAt / updatedAt
  if ("modifiedAt" in newGrp) newGrp.modifiedAt = nowIso;
  if ("updatedAt" in newGrp) newGrp.updatedAt = nowIso;

  // Important: if group record contains transient UI fields, strip them
  delete newGrp._drag;
  delete newGrp._startX;
  delete newGrp._startY;

  Scene.groups[newGroupId] = newGrp;
}


  const newEls = [];

  for (const src of CLIPBOARD.elements){
    const el = deepClone(src);

    // New identity
    const oldId = el.id;
    el.id = uid("el");
    idMap.set(oldId, el.id);

    // Position offset (down + right)
    el.x = (Number(el.x) || 0) + dx;
    el.y = (Number(el.y) || 0) + dy;

    // Group handling
    if (newGroupId){
      el.groupId = newGroupId;
    } else {
      // If it was not a single-group copy, do not carry group ids across (avoid referencing old groups)
      el.groupId = null;
    }

    // Remove transient drag fields if present
    delete el._startX; delete el._startY;
    delete el._startW; delete el._startH;
    delete el._startRot; delete el._startFontSize;
    delete el._startRadius;

    newEls.push(el);
  }

  // Add pasted elements on top
  for (const el of newEls){
    Scene.elements.push(el);
  }

  // Select pasted elements
  selectOnlyElements(newEls.map(e => e.id));

  scheduleAutosave();
  updateUiForSelection();
  render();
  historyCommit("Paste");

  setStatus(`Pasted ${newEls.length} element${newEls.length === 1 ? "" : "s"}.`);
  updateClipboardButtons();

}




function wireClipboardButtons(){
  const copyBtn  = document.getElementById("btnCopy");
  const cutBtn   = document.getElementById("btnCut");
  const pasteBtn = document.getElementById("btnPaste");
  if (!copyBtn || !cutBtn || !pasteBtn) return;

  const undoBtn  = document.getElementById("btnUndo");
  const redoBtn  = document.getElementById("btnRedo");

  if (undoBtn) undoBtn.addEventListener("click", () => historyUndo());
  if (redoBtn) redoBtn.addEventListener("click", () => historyRedo());

  copyBtn.addEventListener("click", () => copySelection());
  cutBtn.addEventListener("click",  () => cutSelection());
  pasteBtn.addEventListener("click",() => pasteClipboard());

  updateClipboardButtons(); // set initial enabled/disabled state
  updateUndoRedoUi();//update undo/redo buttons
}

function updateClipboardButtons(){
  const copyBtn  = document.getElementById("btnCopy");
  const cutBtn   = document.getElementById("btnCut");
  const pasteBtn = document.getElementById("btnPaste");
  if (!copyBtn || !cutBtn || !pasteBtn) return;

  const hasSel = selectedIds && selectedIds.size > 0;
  const canPaste = !!(CLIPBOARD && CLIPBOARD.elements && CLIPBOARD.elements.length);

  copyBtn.disabled  = !hasSel;
  cutBtn.disabled   = !hasSel || selectionHasLocked();
  pasteBtn.disabled = !canPaste;
}




  /* ============================================================
     Deletion
     ============================================================ */
  function deleteSelection(){
  if (!selectedIds.size) return;

  // CHANGE HERE: locked elements cannot be deleted
  if (selectionHasLocked()){
    window.alert("This element cannot be deleted because it is locked. Unlock it first.");
    setStatus("Delete blocked: locked element(s).");
    return;
  }

  // CHANGE HERE: always confirm delete to prevent accidental deletion
  const count = selectedIds.size;
  const ok = window.confirm(`Delete ${count} element${count === 1 ? "" : "s"}?`);
  if (!ok) return;

  const ids = new Set(selectedIds);
  Scene.elements = Scene.elements.filter(e => !ids.has(e.id));
  selectedIds.clear();

  // cleanup empty groups
  const used = new Set(Scene.elements.map(e => e.groupId).filter(Boolean));
  for (const gid of Object.keys(Scene.groups)){
    if (!used.has(gid)) delete Scene.groups[gid];
  }

  scheduleAutosave();
  updateUiForSelection();
  render();
  historyCommit("Delete");
  setStatus("Deleted.");
}


  /* ============================================================
     Pointer events on canvas
     ============================================================ */
  wrap.addEventListener("pointerdown", async (e) => {
    if (isTypingContext(document.activeElement)) return;

    const ptScreen = getPointerScreen(e);
    const ptStage = screenToStage(ptScreen);

    // Ensure we only interact within stage area for creation; selection may also be stage-limited.
    const insideStage = (ptStage.x >= 0 && ptStage.y >= 0 && ptStage.x <= Scene.stage.w && ptStage.y <= Scene.stage.h);

    if (activeTool === Tool.Pan){
      startPointerCapture(e);
      drag.mode = HANDLE.Pan;
      drag.startScreen = ptScreen;
      drag.panStartView = { zoom: Scene.view.zoom, ox: Scene.view.offsetX, oy: Scene.view.offsetY };
      setStatus("Panning…");
      return;
    }

    if (activeTool !== Tool.Select){
      if (!insideStage){
        setStatus("Click inside the stage to create elements.");
        return;
      }

      // Creation tools: create on pointerdown and switch back to Select (prevents duplicate-creation bug)
      if (activeTool === Tool.Text){
        const el = newTextElement(ptStage.x, ptStage.y);
        addElement(el);
        setTool(Tool.Select);
        return;
      }
      if (activeTool === Tool.Sitelen){
        const el = newSitelenElement(ptStage.x, ptStage.y);
        addElement(el);
        setTool(Tool.Select);
        return;
      }
      if (activeTool === Tool.Glyph){
        const el = newGlyphElement(ptStage.x, ptStage.y);
        addElement(el);
        setTool(Tool.Select);
        return;
      }
      if (activeTool === Tool.Rect){
        const el = newRectElement(ptStage.x, ptStage.y);
        addElement(el);
        setTool(Tool.Select);
        return;
      }
      if (activeTool === Tool.Image){
        const el = newImageElement(ptStage.x, ptStage.y);
        addElement(el);
        // Immediately prompt for image
        await pickImageForElement(el);
        setTool(Tool.Select);
        return;
      }
      if (activeTool === Tool.Delete){
        // Delete tool: delete element under pointer or selection
        const hit = pickTopmostElementAtStagePoint(ptStage);
        if (hit){
          selectOnlyElements(hit.groupId ? getElementsInGroup(hit.groupId).map(e=>e.id) : [hit.id]);
          deleteSelection();
        } else {
          deleteSelection();
        }
        setTool(Tool.Select);
        return;
      }
    }

    // Select tool behavior
    if (!insideStage){
      // Clicking outside stage clears selection unless shift
      if (!e.shiftKey) clearSelection();
      return;
    }

    // First: handle selection handles if any selected
    const handle = hitTestSelectionHandles(ptStage);
    if (handle !== HANDLE.None && anySelected()){

      // CHANGE HERE: block transforms if any selected is locked
      if (selectionHasLocked()){
        setStatus("Locked element(s): unlock to move/resize/rotate.");
        return;
      }
      
      startPointerCapture(e);
      beginDragSelectionMode(handle, ptScreen, ptStage);
      setStatus(handle === HANDLE.Rotate ? "Rotate…" : "Transform…");
      return;
    }

    // Hit test for selecting element
    const hit = pickTopmostElementAtStagePoint(ptStage);

    if (hit){
      // Group selection rule: click inside any element of the group selects the group set.
      const ids = hit.groupId ? getElementsInGroup(hit.groupId).map(e => e.id) : [hit.id];

      if (e.shiftKey){
        // toggle the *whole group* if grouped, or element if not
        const allSelected = ids.every(id => selectedIds.has(id));
        if (allSelected) ids.forEach(id => selectedIds.delete(id));
        else ids.forEach(id => selectedIds.add(id));
        updateUiForSelection();
        render();
      } else {
        // normal click: replace selection with this (or group)
        selectOnlyElements(ids);
        selectWholeGroupIfApplicable(hit, e);//????

      }


      // CHANGE HERE: block move if selection includes locked
      if (selectionHasLocked()){
        setStatus("Locked element(s): unlock to move.");
        return;
      }

      // Start move drag immediately (no duplicate creation bug)
      startPointerCapture(e);
      beginDragSelectionMode(HANDLE.Move, ptScreen, ptStage);
      setStatus("Move…");
      return;
    }

    // Empty space: marquee selection
    if (!e.shiftKey) selectedIds.clear();
    updateUiForSelection();

    startPointerCapture(e);
    drag.mode = HANDLE.Marquee;
    drag.startScreen = ptScreen;
    drag.startStage = ptStage;
    drag.marquee = { x0: ptStage.x, y0: ptStage.y, x1: ptStage.x, y1: ptStage.y };
    setStatus("Marquee select…");
    render();
  }, { passive: true });

  wrap.addEventListener("pointermove", (e) => {
    if (!drag.active || e.pointerId !== drag.pointerId) return;

    const ptScreen = getPointerScreen(e);
    const ptStage = screenToStage(ptScreen);

    if (drag.mode === HANDLE.Pan){
      const dxScreen = ptScreen.x - drag.startScreen.x;
      const dyScreen = ptScreen.y - drag.startScreen.y;
      const z = drag.panStartView.zoom;
      Scene.view.offsetX = drag.panStartView.ox + dxScreen / z;
      Scene.view.offsetY = drag.panStartView.oy + dyScreen / z;
      render();
      return;
    }

    if (drag.mode === HANDLE.Marquee){
      drag.marquee.x1 = ptStage.x;
      drag.marquee.y1 = ptStage.y;
      render();
      return;
    }

    if (drag.mode === HANDLE.Move){
      const dx = ptStage.x - drag.startStage.x;
      const dy = ptStage.y - drag.startStage.y;
      applyMoveToSelection(dx, dy);
      render();
      return;
    }

    if (drag.mode === HANDLE.Rotate){
      const aabb = drag.startAabb;
      const cx = aabb.x + aabb.w/2;
      const cy = aabb.y + aabb.h/2;
      const ang = Math.atan2(ptStage.y - cy, ptStage.x - cx);
      const delta = deg(ang - drag.startAngle);
      applyRotateToSelection(delta);
      render();
      return;
    }

    // resize handles
    if (
      drag.mode === HANDLE.ResizeNW || drag.mode === HANDLE.ResizeN || drag.mode === HANDLE.ResizeNE ||
      drag.mode === HANDLE.ResizeE  || drag.mode === HANDLE.ResizeSE || drag.mode === HANDLE.ResizeS  ||
      drag.mode === HANDLE.ResizeSW || drag.mode === HANDLE.ResizeW
    ){
      applyScaleToSelection(drag.mode, ptStage, e.shiftKey);
      render();
      return;
    }
  }, { passive: true });

  wrap.addEventListener("pointerup", (e) => {
    if (!drag.active || e.pointerId !== drag.pointerId) return;

    if (drag.mode === HANDLE.Marquee && drag.marquee){
      const x0 = Math.min(drag.marquee.x0, drag.marquee.x1);
      const y0 = Math.min(drag.marquee.y0, drag.marquee.y1);
      const x1 = Math.max(drag.marquee.x0, drag.marquee.x1);
      const y1 = Math.max(drag.marquee.y0, drag.marquee.y1);

      const selected = [];
      for (const el of Scene.elements){
        // Select if entire element AABB is inside marquee (as requested)
        const b = aabbOfElements([el]);
        if (b.x >= x0 && b.y >= y0 && (b.x+b.w) <= x1 && (b.y+b.h) <= y1){
          selected.push(el.id);
        }
      }

      // If any selected elements are in groups, expand selection to include full groups
      const expanded = new Set(selected);
      for (const id of selected){
        const el = getElementById(id);
        if (el && el.groupId){
          for (const gEl of getElementsInGroup(el.groupId)) expanded.add(gEl.id);
        }
      }

      // Merge with existing selection (shift behavior already handled at down by not clearing)
      for (const id of expanded) selectedIds.add(id);

      updateUiForSelection();
      drag.marquee = null;
      setStatus(`Selected: ${selectedIds.size}`);
      finalizeDrag();
      endPointerCapture();
      return;
    }

    finalizeDrag();
    endPointerCapture();
    setStatus("Ready.");
  }, { passive: true });

  wrap.addEventListener("pointercancel", (e) => {
    if (!drag.active || e.pointerId !== drag.pointerId) return;
    endPointerCapture();
    render();
    setStatus("Cancelled.");
  }, { passive: true });

  /* ============================================================
     Keyboard controls
     ============================================================ */
  window.addEventListener("keydown", (e) => {
    if (isTypingContext(document.activeElement)) return;

    if (e.key === "Escape"){
      clearSelection();
      setStatus("Selection cleared.");
      return;
    }

    if (e.key === "Delete" || e.key === "Backspace"){
      if (anySelected()){
        e.preventDefault();
        deleteSelection();
      }
      return;
    }

    const step = e.shiftKey ? 10 : 1;
    if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "ArrowUp" || e.key === "ArrowDown"){
      if (!anySelected()) return;

      if (selectionHasLocked()){
        setStatus("Locked element(s): unlock to move.");
        return;
      }

      e.preventDefault();
      const dx = (e.key === "ArrowLeft") ? -step : (e.key === "ArrowRight") ? step : 0;
      const dy = (e.key === "ArrowUp") ? -step : (e.key === "ArrowDown") ? step : 0;

      // Move selection by step (in stage units); apply snap if enabled
      // Use same applyMoveToSelection logic by faking drag start
      const snap = snapshotSelected();
      for (const s of snap){
        const el = getElementById(s.id);
        if (el){
          el._startX = el.x;
          el._startY = el.y;
        }
      }
      applyMoveToSelection(dx, dy);
      finalizeDrag();
      setStatus("Nudged.");
      return;
    }
  }, { passive: false });

  /* ============================================================
     Image picking
     ============================================================ */
  function pickImageForElement(el){
  const inp = $("filePickImage");
  inp.value = "";
  inp.onchange = async () => {
    const file = inp.files && inp.files[0];
    if (!file) return;

    // Store the image once in Assets; element references it by assetId.
    const dataUrl = await dataUrlFromBlob(file);
    const assetId = addImageAssetFromDataUrl(dataUrl);

    const img = new Image();
    img.onload = () => {
      const natW = img.naturalWidth || img.width || 0;
      const natH = img.naturalHeight || img.height || 0;

      // Keep your existing behavior: default size if needed
      if (!el.w || !el.h){
        el.w = natW || el.w || 0;
        el.h = natH || el.h || 0;
      }

      // IMPORTANT: store only assetId (no base64 on the element)
      el.image = {
        assetId,
        naturalW: natW,
        naturalH: natH,
        origW: natW,
        origH: natH
      };

      el.keepAspect = (el.keepAspect == null) ? true : !!el.keepAspect;
      el.fill = "#FFFFFF";

      invalidateImageCache(el.id);
      scheduleAutosave();
      updateUiForSelection();
      render();
      setStatus("Image embedded.");
    };

    img.src = dataUrl;
  };
  inp.click();
}

function syncSnapButtonsFromScene(){
  const bGrid = document.getElementById("btnSnapGrid");
  const bObjs = document.getElementById("btnSnapObjs");
  if (!bGrid || !bObjs) return;

  const st = Scene.stage || (Scene.stage = {});
  const gridOn = !!st.snapGrid;
  const objsOn = !!st.snapObjects;

  bGrid.setAttribute("aria-pressed", gridOn ? "true" : "false");
  bObjs.setAttribute("aria-pressed", objsOn ? "true" : "false");

  // Optional: make state explicit in text too (helps on subtle themes)
  //bGrid.textContent = gridOn ? "Snap: Grid (On)" : "Snap: Grid";
  //bObjs.textContent = objsOn ? "Snap: Objects (On)" : "Snap: Objects";
}

function syncStageDefaultsUiFromScene(){
  const bg = document.getElementById("stageBg");
  const dt = document.getElementById("defTextColor");
  const df = document.getElementById("defFill");
  const dfe = document.getElementById("defFillEnabled");
  const ds = document.getElementById("defStroke");
  const dsw = document.getElementById("defStrokeW");

  const st = Scene.stage || (Scene.stage = {});

 

  if (bg)  bg.value  = rgbaOrHexToHex(st.bg, DEFAULTS.stageBg);
  if (dt)  dt.value  = rgbaOrHexToHex(st.defaultTextColor, DEFAULTS.defaultTextColor);
  if (df)  df.value  = rgbaOrHexToHex(st.defaultFill, DEFAULTS.defaultFill);
  if (dfe){
    dfe.checked = !!Scene.stage.defaultFillEnabled;

    // Optional but helpful: disable the color picker when fill is disabled
    //const df = $("defFill");
    //if (df) df.disabled = !dfe.checked;
  }
  if (ds)  ds.value  = rgbaOrHexToHex(st.defaultStroke, DEFAULTS.defaultStroke);
  if (dsw) dsw.value = Number.isFinite(st.defaultStrokeW) ? st.defaultStrokeW : DEFAULTS.defaultStrokeW;

 console.log("Scene: " + JSON.stringify(st));

  syncSnapButtonsFromScene();
}


  /* ============================================================
     Import/Export JSON and Export PNG
     ============================================================ */

     // ---------- Hardening helpers (put near utilities) ----------

const IMPORT_LIMIT_BYTES = 2_000_000;     // 2 MB cap (adjust as needed)
const MAX_ELEMENTS = 5000;               // prevent DoS-by-huge-array
const MAX_GROUPS = 5000;
const MAX_TEXT_LEN = 50_000;             // cap long sitelen/source text fields

function safeJsonParse(text){
  // Size cap (approx bytes). This is not perfect for UTF-16, but prevents obvious abuse.
  if (text.length > IMPORT_LIMIT_BYTES) {
    throw new Error(`Import too large (> ${IMPORT_LIMIT_BYTES} chars).`);
  }

  // Reviver blocks common prototype-pollution keys anywhere in the document.
  return JSON.parse(text, (k, v) => {
    if (k === "__proto__" || k === "constructor" || k === "prototype") return undefined;
    return v;
  });
}

function isPlainObject(x){
  return x !== null && typeof x === "object" && (Object.getPrototypeOf(x) === Object.prototype || Object.getPrototypeOf(x) === null);
}



function mustBeFiniteNumber(x, name){
  if (typeof x !== "number" || !Number.isFinite(x)) throw new Error(`Invalid number: ${name}`);
  return x;
}

function mustBeString(x, name, maxLen = 10_000){
  if (typeof x !== "string") throw new Error(`Invalid string: ${name}`);
  if (x.length > maxLen) throw new Error(`String too long: ${name}`);
  return x;
}

function validateAndSanitizeScene(raw){
  if (!isPlainObject(raw)) throw new Error("Top-level scene must be an object.");

  // Allow either raw Scene or a wrapped payload (see export hardening below).
  const scene = raw.scene && isPlainObject(raw.scene) ? raw.scene : raw;

  if (!isPlainObject(scene.stage)) throw new Error("Missing/invalid stage.");
  if (!Array.isArray(scene.elements)) throw new Error("Missing/invalid elements array.");

  if (scene.elements.length > MAX_ELEMENTS) throw new Error(`Too many elements (> ${MAX_ELEMENTS}).`);
  if (scene.groups && Array.isArray(scene.groups) && scene.groups.length > MAX_GROUPS) {
    throw new Error(`Too many groups (> ${MAX_GROUPS}).`);
  }

  // Stage numeric hygiene + clamps
  const w = clamp(mustBeFiniteNumber(scene.stage.w, "stage.w"), 64, 20000);
  const h = clamp(mustBeFiniteNumber(scene.stage.h, "stage.h"), 64, 20000);
  const gridSize = clamp(mustBeFiniteNumber(scene.stage.gridSize ?? 20, "stage.gridSize"), 1, 1000);
  const snapTol = clamp(mustBeFiniteNumber(scene.stage.snapTol ?? 8, "stage.snapTol"), 0, 500);

  // Optional view/meta/groups defaults
  const meta = isPlainObject(scene.meta) ? scene.meta : {};
  const view = isPlainObject(scene.view) ? scene.view : {};
  const groups = Array.isArray(scene.groups) ? scene.groups : [];

  // Validate elements in a minimally-invasive way.
  // You can expand this per your exact element schema.
  const ids = new Set();
  const elements = scene.elements.map((el, idx) => {
    if (!isPlainObject(el)) throw new Error(`Element[${idx}] must be an object.`);
    const id = mustBeString(el.id ?? "", `elements[${idx}].id`, 200);
    if (!id) throw new Error(`Element[${idx}] missing id.`);
    if (ids.has(id)) throw new Error(`Duplicate element id: ${id}`);
    ids.add(id);

    // Defensive copies + numeric hygiene for common fields.
    // (Adjust keys to your actual schema.)
    const out = {...el};

    if ("x" in out) out.x = mustBeFiniteNumber(out.x, `elements[${idx}].x`);
    if ("y" in out) out.y = mustBeFiniteNumber(out.y, `elements[${idx}].y`);
    if ("w" in out) out.w = clamp(mustBeFiniteNumber(out.w, `elements[${idx}].w`), 1, 50000);
    if ("h" in out) out.h = clamp(mustBeFiniteNumber(out.h, `elements[${idx}].h`), 1, 50000);
    if ("rot" in out) out.rot = clamp(mustBeFiniteNumber(out.rot, `elements[${idx}].rot`), -360000, 360000);

    // Cap any large text payloads (sitelen source, labels, etc.)
    for (const k of ["text", "source", "sitelen", "label", "name"]) {
      if (k in out && typeof out[k] === "string") {
        if (out[k].length > MAX_TEXT_LEN) throw new Error(`Element[${idx}].${k} too long.`);
      }
    }

    return out;
  });

  // Return a sanitized, canonical scene object.
  return {
    meta,
    stage: { ...scene.stage, w, h, gridSize, snapTol },
    view,
    elements,
    groups
  };
}

function exportJson(){
  // Export only the stable, persisted parts.
  const stableScene = {
    meta: deepClone(Scene.meta),
    stage: deepClone(Scene.stage),
    view: deepClone(Scene.view),
    elements: deepClone(Scene.elements),
    groups: deepClone(Scene.groups),
  };

  const payload = { 
    format: "StaticCanvasLayout", 
    version: 2, 
    exportedAt: new Date().toISOString(), 
    scene: stableScene, 
    assets: serializeAssets() 
  };

  const blob = new Blob([JSON.stringify(payload, null, 2)], {type:"application/json"});
  downloadBlob(blob, `layout_${nowIso()}.json`);
  setStatus("Exported JSON.");
}

async function importJsonFromFile(file){
  // Basic file gating (not security, but good hygiene)
  if (!file) throw new Error("No file provided.");
  if (file.size > IMPORT_LIMIT_BYTES) throw new Error(`File too large (> ${IMPORT_LIMIT_BYTES} bytes).`);
  // Optional: if you only want .json
  // if (!/\.json$/i.test(file.name)) throw new Error("Please select a .json file.");

  let txt;
  try {
    txt = await file.text();
  } catch (e) {
    throw new Error("Could not read file.");
  }

  let raw;
  try {
    raw = safeJsonParse(txt);
  } catch (e) {
    throw new Error("Invalid JSON (parse failed).");
  }

  // If you already have normalizeScene(), keep it—but validate afterwards.
  // Support two formats:
  //  (A) Wrapper: { scene: {...}, assets: {...} }
  //  (B) Legacy:  {meta, stage, view, elements, groups, ...}  (scene directly)
  const isWrapper = raw && typeof raw === "object" && raw.scene && typeof raw.scene === "object";

  // If wrapper, load assets FIRST so normalizeScene can migrate/resolve legacy images if needed.
  if (isWrapper){
    try {
      deserializeAssets(raw.assets);
    } catch (e) {
      // If assets are malformed, fail early. Otherwise the scene will reference missing assetIds.
      throw new Error("Invalid assets data (deserialize failed).");
    }
  } else {
    // Legacy import: start with empty assets; normalizeScene may migrate legacy inline images into Assets.
    // (Do not clear Assets here if you want to allow merging imports; most editors expect replace.)
    // If you want replace semantics, uncomment:
    deserializeAssets(null);
  }

  // Normalize scene (wrapper uses raw.scene; legacy uses raw)
  let normalized;
  try {
    normalized = normalizeScene(isWrapper ? raw.scene : raw);
  } catch (e) {
    throw new Error("Invalid scene data (normalize failed).");
  }


  let sanitized;
  try {
    sanitized = validateAndSanitizeScene(normalized);
  } catch (e) {
    throw new Error(`Invalid scene format: ${e.message}`);
  }

  // Commit changes in one place only AFTER validation.
  Scene.meta = sanitized.meta;
  Scene.stage = sanitized.stage;
  Scene.view = sanitized.view;
  Scene.elements = sanitized.elements;
  Scene.groups = sanitized.groups;

  syncStageDefaultsUiFromScene();

  // Clear runtime state
  selectedIds.clear();
  imageCache.clear();

  try {
      await dbPut(DB_KEY, {
        scene: deepClone(Scene),
        assets: serializeAssets()
      });
  } catch (e) {
    // If persistence fails, you may still keep the imported scene in memory,
    // but make the failure explicit.
    setStatus("Imported JSON, but failed to save to local DB.");
  }

  // Update UI controls with sanitized stage values
  $("stageW").value = String(Scene.stage.w);
  $("stageH").value = String(Scene.stage.h);
  $("gridSize").value = String(Scene.stage.gridSize);
  $("snapTol").value = String(Scene.stage.snapTol);

  setStatus("Imported JSON.");
  updateUiForSelection();

  refreshAllSitelenElementsPreserveCenter();
  fitStageToView();
  render();
  historyReset("Import");

}





  function drawElementToOffscreen(octx, el){
    octx.save();
    octx.globalAlpha = clamp(el.opacity ?? 1, 0, 1);

    const cx = el.x + el.w/2;
    const cy = el.y + el.h/2;

    octx.translate(cx, cy);
    octx.rotate(rad(el.rotationDeg || 0));

    const x = -el.w/2;
    const y = -el.h/2;

    if (el.type === ElementType.Rect){
      // Rect
      const r = el.radius ?? 0;
      if (el.fillEnabled && el.fill && el.fill !== "transparent"){
        octx.fillStyle = el.fill;
        roundedRectPathOff(octx, x,y,el.w,el.h,r);
        octx.fill();
      }
      if ((el.strokeW ?? 0) > 0){
        octx.lineWidth = (el.strokeW ?? 1);
        octx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
        roundedRectPathOff(octx, x,y,el.w,el.h,r);
        octx.stroke();
      }
    } else if (el.type === ElementType.Text){
      // Text
      if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
        octx.fillStyle = el.fill;
        octx.fillRect(x,y,el.w,el.h);
      }
      
      const pad = 8;
      const innerX = x + pad;
      const innerY = y + pad;
      const innerW = Math.max(0, el.w - pad*2);
      const innerH = Math.max(0, el.h - pad*2);

      const fontSize = Math.max(6, (el.fontSize ?? 24));
      const fontFamily = el.fontFamily || "PatrickHand";
      const lineHeight = Math.max(0.8, el.lineHeight ?? 1.15);

      octx.fillStyle = el.color || "#111111";
      octx.font = `${fontSize}px ${cssFontFamily(fontFamily)}, system-ui, sans-serif`;
      octx.textBaseline = "top";

      let textAlign = (el.align || "left");
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right") textAlign = "left";
      octx.textAlign = textAlign;

      const rawLines = splitLinesForBox(el.text);
      const allLines = [];
      for (const ln0 of rawLines){
        const ln = (el.type === ElementType.Sitelen) ? renderSitelenLineToCanvasText(ln0) : String(ln0 ?? "");
        const wrapped = wrapLine(octx, ln, innerW);
        for (const wln of wrapped) allLines.push(wln);
      }

      const lhPx = fontSize * lineHeight;
      let ty = innerY;
      for (const ln of allLines){
        if (ty + lhPx > innerY + innerH + 0.5) break;
        let tx = innerX;
        if (textAlign === "center") tx = innerX + innerW/2;
        if (textAlign === "right") tx = innerX + innerW;
        octx.fillText(ln, tx, ty);
        ty += lhPx;
      }

      if ((el.strokeW ?? 0) > 0){
        octx.lineWidth = (el.strokeW ?? 1);
        octx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
        octx.strokeRect(x,y,el.w,el.h);
      }
    } else if (el.type === ElementType.Sitelen){
      const entry = ensureSitelenRaster(el);
      if (entry && entry.canvas){
        
        if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
          octx.fillStyle = el.fill;
          octx.fillRect(x,y,el.w,el.h);
        }

        // draw like image into the offscreen export, scaled to el.w/el.h
        octx.drawImage(entry.canvas, x, y, el.w, el.h);


        if ((el.strokeW ?? 0) > 0){
          octx.lineWidth = (el.strokeW ?? 1);
          octx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
          octx.strokeRect(x,y,el.w,el.h);
        }
      } else {
        // placeholder if raster missing
        octx.setLineDash([6,4]);
        octx.strokeRect(x+1,y+1,el.w-2,el.h-2);
        octx.setLineDash([]);
      }

    } else if (el.type === ElementType.Glyph){
      //glyph
      if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
        octx.fillStyle = el.fill;
        octx.fillRect(x,y,el.w,el.h);
      }

      const cp = parseCodepointInput(el.codepoint);
      const ch = (typeof cp === "number") ? String.fromCodePoint(cp) : "?";
      const fontSize = Math.max(6, (el.fontSize ?? 64));
      const fontFamily = el.fontFamily || "TP-Cartouche-Font";
     
      octx.font = `${fontSize}px ${cssFontFamily(fontFamily)}, system-ui, sans-serif`;
      octx.textBaseline = "middle";
      octx.textAlign = "center";
      octx.fillStyle = el.color;
      octx.fillText(ch, x + el.w/2, y + el.h/2);

      if ((el.strokeW ?? 0) > 0){
        octx.lineWidth = (el.strokeW ?? 1);
        octx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
        octx.strokeRect(x,y,el.w,el.h);
      }
    } else if (el.type === ElementType.Image){
      // CHANGE HERE: Export matches on-canvas behavior:
      // background fill only when there is NO loaded image
      const hasImage = !!(el.image && el.image.assetId && getImageAssetDataUrl(el.image.assetId));

      if (el.fillEnabled && el.fill && el.fill !== "transparent" && el.fill !== "rgba(255,255,255,0.0)"){
        octx.fillStyle = el.fill;
        octx.fillRect(x,y,el.w,el.h);
      }

      if (hasImage){
        const img = new Image();
        // NOTE: synchronous draw not possible reliably; we draw a placeholder instead if not loaded.
        // For export, we’ll do a best-effort direct draw using data URL (browser usually resolves quickly),
        // but to keep this single-pass, we do a lightweight approach:
        img.src = getImageAssetDataUrl(el.image.assetId);// `data:${el.image.mime};base64,${el.image.b64}`;
        // If already cached by the browser, width/height will be non-zero.
        if (img.complete && img.naturalWidth > 0){
          octx.drawImage(img, x,y,el.w,el.h);
        } else {
          // placeholder
          octx.strokeStyle = "rgba(17,17,17,0.28)";
          octx.lineWidth = 2;
          octx.setLineDash([6,4]);
          octx.strokeRect(x+1,y+1,el.w-2,el.h-2);
          octx.setLineDash([]);
        }
      } else {
        octx.strokeStyle = "rgba(17,17,17,0.28)";
        octx.lineWidth = 2;
        octx.setLineDash([6,4]);
        octx.strokeRect(x+1,y+1,el.w-2,el.h-2);
        octx.setLineDash([]);
      }
      if ((el.strokeW ?? 0) > 0){
        octx.lineWidth = (el.strokeW ?? 1);
        octx.strokeStyle = el.stroke || "rgba(17,17,17,0.35)";
        octx.strokeRect(x,y,el.w,el.h);
      }
    }

    octx.restore();
  }

  function exportPngTransparent(){
    console.log("Export PNG image");
    // Create offscreen canvas at exact stage size (no background fill => transparent)
    const off = document.createElement("canvas");
    off.width = Scene.stage.w;
    off.height = Scene.stage.h;
    const octx = off.getContext("2d");

    // Render scene at 1:1 stage coords (no view transforms)
    // Note: We do NOT draw grid or stage background for export.
    for (const el of Scene.elements){
      drawElementToOffscreen(octx, el);
    }

    off.toBlob((blob) => {
      if (!blob) return;
      downloadBlob(blob, `layout_${nowIso()}.png`);
      setStatus("Exported PNG (transparent).");
    }, "image/png");
  }

  function roundedRectPathOff(octx, x,y,w,h,r){
    const rr = Math.max(0, Math.min(r, w/2, h/2));
    octx.beginPath();
    octx.moveTo(x+rr, y);
    octx.arcTo(x+w, y, x+w, y+h, rr);
    octx.arcTo(x+w, y+h, x, y+h, rr);
    octx.arcTo(x, y+h, x, y, rr);
    octx.arcTo(x, y, x+w, y, rr);
    octx.closePath();
  }

  /* ============================================================
     Controls and buttons
     ============================================================ */
  $("toolSelect").addEventListener("click", () => setTool(Tool.Select));
  $("toolText").addEventListener("click", () => setTool(Tool.Text));
  $("toolSitelen").addEventListener("click", () => setTool(Tool.Sitelen));
  $("toolGlyph").addEventListener("click", () => setTool(Tool.Glyph));
  $("toolRect").addEventListener("click", () => setTool(Tool.Rect));
  $("toolImage").addEventListener("click", () => setTool(Tool.Image));

  $("toolDelete").addEventListener("click", () => {
  if (anySelected()){
    deleteSelection();     // this is where confirm happens
    setTool(Tool.Select);  // return to normal tool
  } else {
    setTool(Tool.Delete);  // no selection: use click-to-delete mode
  }
});


  $("toolPan").addEventListener("click", () => setTool(Tool.Pan));

  $("btnGroup").addEventListener("click", () => groupSelection());
  $("btnUngroup").addEventListener("click", () => ungroupSelection());

  $("btnBringFwd").addEventListener("click", () => bringForwardZ());
  $("btnSendBack").addEventListener("click", () => sendBackwardZ());

$("btnNew").addEventListener("click", async () => {
  // CHANGE HERE: prevent accidental clearing
  const hasAnything =
    (Array.isArray(Scene.elements) && Scene.elements.length > 0) ||
    (Scene.groups && typeof Scene.groups === "object" && Object.keys(Scene.groups).length > 0);

  if (hasAnything){
    const ok = window.confirm("This will clear the current canvas. Continue?");
    if (!ok) return;
  }

  Scene.stage.bg = DEFAULTS.stageBg;
Scene.stage.defaultTextColor = DEFAULTS.defaultTextColor;
Scene.stage.defaultFill = DEFAULTS.defaultFill;
Scene.stage.defaultFillEnabled = DEFAULTS.defaultFillEnabled;
Scene.stage.defaultStroke = DEFAULTS.defaultStroke;
Scene.stage.defaultStrokeW = DEFAULTS.defaultStrokeW;

  Scene.elements = [];
  Scene.groups = {};
  selectedIds.clear();
  imageCache.clear();

console.log("New Scene "+ JSON.stringify(Scene));

  scheduleAutosave();
  syncStageDefaultsUiFromScene();
  updateUiForSelection();

  render();
  historyReset("New");
  setStatus("Cleared.");
});


  $("btnExportJson").addEventListener("click", () => exportJson());
  $("btnImportJson").addEventListener("click", () => $("fileImportJson").click());
  $("fileImportJson").addEventListener("change", async () => {
    const f = $("fileImportJson").files && $("fileImportJson").files[0];
    if (!f) return;
    try{
      await importJsonFromFile(f);
    }catch(err){
      console.error(err);
      setStatus(`Import failed: ${err && err.message ? err.message : String(err)}`);
    }
  });

  $("btnExportPng").addEventListener("click", () => exportPngTransparent());

  // Stage toggles
  function setPressed(btn, pressed){
    btn.setAttribute("aria-pressed", pressed ? "true" : "false");
  }

  $("btnGrid").addEventListener("click", () => {
    Scene.stage.showGrid = !Scene.stage.showGrid;
    setPressed($("btnGrid"), Scene.stage.showGrid);
    scheduleAutosave(); render();
  });

  $("btnSnapGrid").addEventListener("click", () => {
    Scene.stage.snapGrid = !Scene.stage.snapGrid;
    setPressed($("btnSnapGrid"), Scene.stage.snapGrid);
    scheduleAutosave(); render();
  });

  $("btnSnapObjs").addEventListener("click", () => {
    Scene.stage.snapObjects = !Scene.stage.snapObjects;
    setPressed($("btnSnapObjs"), Scene.stage.snapObjects);
    scheduleAutosave(); render();
  });

  $("stageW").addEventListener("input", () => {
    const v = Number($("stageW").value);
    if (!Number.isFinite(v) || v < 64) return;
    Scene.stage.w = v;
    scheduleAutosave(); render();
  });
  $("stageH").addEventListener("input", () => {
    const v = Number($("stageH").value);
    if (!Number.isFinite(v) || v < 64) return;
    Scene.stage.h = v;
    scheduleAutosave(); render();
  });
  $("gridSize").addEventListener("input", () => {
    const v = Number($("gridSize").value);
    if (!Number.isFinite(v) || v < 2) return;
    Scene.stage.gridSize = v;
    scheduleAutosave(); render();
  });
  $("snapTol").addEventListener("input", () => {
    const v = Number($("snapTol").value);
    if (!Number.isFinite(v) || v < 1) return;
    Scene.stage.snapTol = v;
    scheduleAutosave(); render();
  });






function wireSnapButtons(){
  const bGrid = document.getElementById("btnSnapGrid");
  const bObjs = document.getElementById("btnSnapObjs");
  if (!bGrid || !bObjs) return;

  bGrid.addEventListener("click", () => {
    Scene.stage = Scene.stage || {};
    Scene.stage.snapGrid = !Scene.stage.snapGrid;
    syncSnapButtonsFromScene();
    render();
    saveToLocal?.();
  });

  bObjs.addEventListener("click", () => {
    Scene.stage = Scene.stage || {};
    Scene.stage.snapObjects = !Scene.stage.snapObjects;
    syncSnapButtonsFromScene();
    render();
    saveToLocal?.();
  });
}


function wireStageDefaultsUi(){
  const bg = document.getElementById("stageBg");
  const dt = document.getElementById("defTextColor");
  const df = document.getElementById("defFill");
  const dfe = document.getElementById("defFillEnabled");
  const ds = document.getElementById("defStroke");
  const dsw = document.getElementById("defStrokeW");

  if (bg){
    bg.addEventListener("input", (e) => {
      Scene.stage.bg = rgbaOrHexToHex(e.currentTarget.value, "#111111");
      render();
    });
    bg.addEventListener("change", (e) => {
      Scene.stage.bg =rgbaOrHexToHex(e.currentTarget.value, "#111111");
      scheduleAutosave();
      render();
    });
  }

  if (dt){

    dt.addEventListener("change", (e) => {
      Scene.stage.defaultTextColor = rgbaOrHexToHex(e.currentTarget.value, "#111111");
      scheduleAutosave();
      render();
    });
  }

  if (dfe){

    dfe.addEventListener("change", (e) => {
      Scene.stage.defaultFillEnabled = !!e.currentTarget.checked;
      scheduleAutosave();
      render();
    });
  }

  if (df){

    df.addEventListener("change", (e) => {
      // store as rgba with alpha=1 for consistency with your element fill strings
      Scene.stage.defaultFill = rgbaOrHexToHex(e.currentTarget.value, "#FFFFFF");
      scheduleAutosave();
      render();
    });
  }

  if (ds){

    ds.addEventListener("change", (e) => {
      Scene.stage.defaultStroke = rgbaOrHexToHex(e.currentTarget.value, "#111111");
      scheduleAutosave();
      render();
    });
  }

  if (dsw){

    dsw.addEventListener("change", (e) => {
      Scene.stage.defaultStrokeW = Math.max(0, Number(e.currentTarget.value || 0));
      scheduleAutosave();
      render();
    });
  }
}

  // View controls
  $("btnFit").addEventListener("click", () => fitStageToView());
  $("btnResetView").addEventListener("click", () => {
    Scene.view.zoom = 1.0;
    Scene.view.offsetX = 0;
    Scene.view.offsetY = 0;
    scheduleAutosave(); render();
  });
  $("btnZoomIn").addEventListener("click", () => {
    Scene.view.zoom = clamp(Scene.view.zoom * 1.15, 0.1, 10);
    scheduleAutosave(); render();
  });
  $("btnZoomOut").addEventListener("click", () => {
    Scene.view.zoom = clamp(Scene.view.zoom / 1.15, 0.1, 10);
    scheduleAutosave(); render();
  });

async function awaitFontLoading(){
  // Older browsers: nothing to await
  if (!document.fonts || !document.fonts.ready) return;

  // Proactively request the specific faces you will measure/draw with.
  // This avoids a race where document.fonts.ready resolves but a face is still not requested yet.
  const loads = [
    document.fonts.load('16px "TP-Nasin-Nanpa-Font"'),
    document.fonts.load('16px "TP-Cartouche-Font"'),
    document.fonts.load('16px "PatrickHand"'),
  ];

  try{
    await Promise.all(loads);
    await document.fonts.ready;
  }catch{
    // If a font fails to load, continue with fallbacks.
  }
}


document.fonts?.ready?.then(() => {
  for (const el of Scene.elements){
    if (el.type === ElementType.Sitelen){
      invalidateSitelenCache(el.id);
      updateSitelenLayout(el, { preserveCenter: true });
    }
  }
  render();
});

function relayoutAllSitelenAfterFontsReady(){
  return (document.fonts?.ready ?? Promise.resolve()).then(() => {
    for (const el of Scene.elements){
      if (el.type === ElementType.Sitelen || el.type === "Sitelen"){
        invalidateSitelenCache(el.id);
        updateSitelenLayout(el, { preserveCenter: true });
      }
    }
    render();
  });
}

document.addEventListener("keydown", (e) => {
  // Do not hijack shortcuts while typing in inputs/textareas/selects/contenteditable
  if (isTypingContext(document.activeElement)) return;

  const isMac = navigator.platform.toLowerCase().includes("mac");
  const mod = isMac ? e.metaKey : e.ctrlKey;

  if (!mod) return;

  const k = String(e.key || "").toLowerCase();


  if ( k === "z"){
    e.preventDefault();
    if (e.shiftKey) historyRedo();
    else historyUndo();
    return;
  }

  if (k === "y"){
    e.preventDefault();
    historyRedo();
    return;
  }


  if (k === "c"){
    e.preventDefault();
    copySelection();
    return;
  }

  if (k === "x"){
    e.preventDefault();
    cutSelection();
    return;
  }

  if (k === "v"){
    e.preventDefault();
    pasteClipboard();
    return;
  }
}, { passive: false });

  /* ============================================================
     Load initial state
     ============================================================ */
  async function init(){
    setStatus("Loading…");
    try{
      await awaitFontLoading(); // <-- add this FIRST

      const record = await dbGet(DB_KEY);

      //load assets if they exist in file, used in format 2
      if(record && record.assets){
        deserializeAssets(record.assets);
      }
      
      //revert back to format 1 for loading scene
      const saved = (record && record.scene) ? record.scene : record;
      if (saved && saved.stage && Array.isArray(saved.elements)){
        // restore
        Scene.meta = saved.meta || Scene.meta;
        Scene.stage = saved.stage;
        Scene.view = saved.view || Scene.view;
        Scene.elements = saved.elements || [];
        Scene.groups = saved.groups || {};

        // critical: run after restore
        await relayoutAllSitelenAfterFontsReady();

        $("stageW").value = String(Scene.stage.w);
        $("stageH").value = String(Scene.stage.h);
        $("gridSize").value = String(Scene.stage.gridSize);
        $("snapTol").value = String(Scene.stage.snapTol);

        setPressed($("btnGrid"), !!Scene.stage.showGrid);
        setPressed($("btnSnapGrid"), !!Scene.stage.snapGrid);
        setPressed($("btnSnapObjs"), !!Scene.stage.snapObjects);

        setStatus("Loaded.");
      } else {
        setStatus("No saved scene. Ready.");
      }
    }catch(err){
      console.warn(err);
      setStatus("IndexedDB unavailable. Running without autosave.");
    }

    wireStageDefaultsUi();
    syncStageDefaultsUiFromScene();

    updateUiForSelection();
    wireClipboardButtons();
    wireArrowKeyNudge();

    //resizeCanvasToDisplay();
    fitStageToView();
    render();
    historyReset("Init");

  }

  init();

  /* ============================================================
     How to extend
     ------------------------------------------------------------
     - Add new element types in ElementType, provide a constructor newXxxElement().
     - Add drawing logic in drawElement / drawElementToOffscreen.
     - Add properties in renderPropsPanel for your new type.
     - Add tool button and creation behavior in pointerdown creation section.
     ============================================================ */
})();
</script>
</body>
</html>
