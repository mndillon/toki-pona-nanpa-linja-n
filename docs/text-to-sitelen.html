<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multiline Text → Sitelen Pona → PNG image file download</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;
      --muted: #3f4750;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .controlsStack { display:flex; flex-direction:column; gap: 12px; margin-top:14px; }
    
 /* Toolbar row: keep everything aligned and compact */
.btnRow{
  display:flex;
  align-items:center;
  gap: 12px;
  flex-wrap: nowrap;
}

/* Compact "pill" control for toolbar */
.inlinePill{
  display:flex;
  flex-direction: row;
  align-items:center;
  gap: 10px;

  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid var(--panel-border);
  background: var(--panel-strong);

  min-width: 0;
}

/* Compact label styling */
.ctlLabel{
  font-size: 12px;
  color: var(--muted);
  white-space: nowrap;
  line-height: 1;
}

.tpInline{
  font-size: 12px;
  color: var(--muted);
  margin-left: 6px;
  white-space: nowrap;
}

/* Ensure you don't carry old wide min-widths */
.rgbControl{ min-width: auto; } /* remove/override any previous 240px */

/* Make the select fit the pill */
.inlinePill select{
  height: 34px;
  padding: 6px 10px;
}

/* Swatch stays small but looks intentional */
.swatch{
  width: 22px;
  height: 22px;
  border-radius: 6px;
  border: 1px solid var(--border);
  padding: 0;
  appearance: none;
  -webkit-appearance: none;
  cursor: pointer;
  overflow: hidden;
}
.swatch::-webkit-color-swatch-wrapper{ padding: 0; }
.swatch::-webkit-color-swatch{ border: none; border-radius: 6px; }
.swatch::-moz-color-swatch{ border: none; border-radius: 6px; }

/* Optional: keep the Render button visually aligned in height */
.btnBi{
  height: 50px;
  display:flex;
  flex-direction: column;
  justify-content: center;
}


/* If your selects are very wide, reduce them slightly */
#fontSizeSel{ width: 108px; } /* adjust as needed */


    label { display:block; font-size:12px; color: var(--muted); margin-bottom:6px; }

    textarea, input[type="text"], select {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg);
      font: inherit;
    }

    textarea { min-height: 180px; resize: vertical; }

    button {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: var(--bg); }

    .btnBi {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      line-height: 1.15;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    .tpLine {
      display: block;
      margin-top: 2px;
      font-size: 10pt;
      color: var(--muted);
      line-height: 1.25;
    }

    canvas {
      display:block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: transparent;
      max-width: 100%;
    }

    .small { font-size: 12px; color: var(--muted); }

    button:focus-visible,
    a:focus-visible,
    textarea:focus-visible,
    select:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: 0 !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    .inlineControl {
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 140px;
    }
    .inlineControl label {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
    }
    .inlineControl select {
      padding: 8px 10px;
      width: 160px;
      max-width: 100%;
    }

    /* NEW: RGB picker layout */
    .rgbControl { min-width: 240px; }
    .rgbRow { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .rgbRow select { width: 72px; padding: 8px 10px; }

    .hexLabel {
      font-size: 12px;
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src:
        /* url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v5.otf")   format("opentype"); */
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v7.otf")   format("opentype");
        
      font-display: swap;
    }

    @font-face {
      font-family: "TP-Nasin-Nanpa-Font";
      src:
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-v5.otf")   format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "Patrick-Head-Font";
      src:
        url("./fonts/PatrickHand-Regular.ttf")   format("truetype");
      font-display: swap;
    }

    /* ===== Toolbar overrides (paste at END of CSS) ===== */

/* Define the variables you referenced */
:root{
  --panel-strong: rgba(255,255,255,0.35);
  --panel-border: rgba(17,17,17,0.18);
}

/* Keep the toolbar on one line and vertically aligned */
.btnRow{
  display:flex;
  align-items:center;
  gap: 12px;
  flex-wrap: nowrap;
}

/* Turn inlineControl blocks into compact "pills" INSIDE the toolbar */
.btnRow .inlineControl{
  display:flex;
  flex-direction: row;     /* override your column layout */
  align-items:center;
  gap: 10px;

  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid var(--panel-border);
  background: var(--panel-strong);

  min-width: 0;            /* override min-width:140px */
}

/* Labels inline, no extra bottom margins */
.btnRow .inlineControl label{
  display:inline-flex;
  align-items:baseline;
  gap: 6px;
  margin: 0;               /* override label margin-bottom:6px */
  white-space: nowrap;
  line-height: 1;
}

/* Make the tp line behave inline in the toolbar */
.btnRow .inlineControl .tpLine{
  display:inline;
  margin: 0;
  font-size: 12px;         /* keep it compact; adjust if desired */
  line-height: 1;
}

/* Prevent selects from expanding to 100% width in the toolbar */
.btnRow .inlineControl select{
  width: auto !important;  /* overrides select{width:100%} */
  min-width: 108px;        /* reasonable fixed control width */
  padding: 6px 10px;
  height: 34px;
}

/* Kill the old RGB layout constraints in the toolbar */
.btnRow .rgbControl{ min-width: 0 !important; }
.btnRow .rgbRow{ flex-wrap: nowrap; }

/* Swatch alignment (in case it sits low/high) */
.btnRow .swatch{
  display:block;
  margin: 0;
}

/* Optional: make the Render button height visually match pills */
.btnRow .btnBi{
  height: 50px;
  padding: 8px 12px;
}

.nlModeControl{ display:none !important; }


/* CHANGE HERE: stack the action controls on small mobile screens */

/* ===== Mobile toolbar layout: Font size → Text color → Render ===== */
@media (max-width: 520px){
  .btnRow{
    flex-direction: column;
    align-items: flex-start;
    gap: 10px;
  }

  /* Each item gets its own line */
  .btnRow > *{
    width: 100%;
  }

  /* Order only on mobile */
  #ctlFontSize{ order: 1; }
  #ctlTextColor{ order: 2; }
  #btnRender{ order: 3; }

  /* Keep controls left-sized (not stretched full width) */
  #btnRender{ width: auto; }
  .btnRow .inlinePill{ width: auto; }
}

/* Portrait image: mobile-first */
    img.portrait{
      display:block;
      width:100%;
      max-width:100vw;
      height:auto;
    }
    @media (min-width:900px){
      img.portrait{ max-width:520px; margin-inline:auto; }
    }

  </style>
</head>

<body>
  <a href="#main" class="skipLink">
    Skip to content
    <span class="tpLine">o tawa lipu ni</span>
  </a>

  <main class="card" id="main" role="main" aria-labelledby="pageTitle">
    <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
      Toki Pona Multiline text → sitelen pona glyphs → PNG image file download
      <span class="tpLine">toki pona sitelen mute-linja tawa sitelen pona lon ilo sitelen</span>
    </h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> Any “nanpa-linja-n proper name” used here are encoding labels for numbers only, and do not propose or add any new Toki Pona lexicon.
      <span class="tpLine">
        sona: nimi “nanpa-linja-n proper name” ale lon ni li nimi pi pana nanpa taso. ona li pana ala e nimi sin pi toki pona.
      </span>
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <span class="tpLine">
        sona: ilo ni li lon nasin “as is”. mi pana ala e wawa pi pona.
        sina o lukin e ni: sitelen li pona anu seme.
      </span>
    </div>

    <div class="help" style="margin-top:10px;">
      Notes:
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>Converts Toki Pona words to sitelen pona glyphs.</li>
        <li>The sitelen pona glyphs can be downloaded as a png image file.</li>
        <li>Recognized nanpa-linja-n number phrases (<span class="mono">nanpa esun|en … nanpa</span>) render as nanpa-linja-n cartouches.</li>
        <li>Decimal-form numbers like <span class="mono">-5,432.10</span>, <span class="mono">1.2K</span>, or <span class="mono">.06</span> render as nanpa-linja-n cartouches.</li>
        <li>End-of-line full stops are not treated as part of a number (e.g. <span class="mono">06.</span>).</li>
        <li><strong>Cartouche:</strong> Inside of <span class="mono">[...]</span>, if all words are toki pona words, then they will all use their own glyphs, otherwise each letter of every word is mapped randomly.</li>
        <li><strong>Cartouche:</strong> Outside of <span class="mono">[...]</span>, only decimals, <span class="mono">#~</span> codes, nanpa-linja-n proper names, and nanpa-linja-n number phrases can produce cartouches.</li>
        <li><strong>Long pi:</strong> A long “pi” container can be written as <span class="mono">pi { ... }</span>.  Must have at least two words inside { ... }.  Cartouche inside long pi isn't working properly.</li>
        <li><strong>Middle dot:</strong> The Unicode character U+00B7 &#x2014; '&#x00B7;' is used to display the middle dot glyph.</li>
        <li><strong>Punctuation:</strong> Word 'ota' maps to middle dot, and word 'kolon' maps to colon, these are non-standard words and are used for convenience only.</li>
        <li><strong>Quotation:</strong> Text inside double quotes is rendered exactly as typed, e.g. "Hello World!".</li>
        <li>Unknown words are ignored.</li>
      </ul>
    </div>

    <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <div class="controlsStack" role="group" aria-label="Input and render action">

      <div>
        <label for="textIn">
          Enter multi-line Toki Pona text
          <span class="tpLine">o pana e sitelen toki pona lon linja mute</span>
        </label>
        <textarea id="textIn" class="mono" spellcheck="false" autocapitalize="none" autocomplete="off"
          placeholder="mi kama sona e toki pona.
nanpa -12,340.57.
nanpa 64.5M.
nanpa 9+3/4.
nanpa 007.
nanpa Newen.
nanpa #~WI.
[ ota sewi^ kolon  ni&lt; ]"></textarea>
      </div>

      <div class="btnRow" aria-label="Actions">
        <button id="btnRender" type="button" class="btnBi">
          <span>Render</span>
          <span class="tpLine">o sitelen</span>
        </button>

        <!-- Foreground color picker -->
        <div id="ctlTextColor" class="inlineControl inlinePill" role="group" aria-label="Text color">
          <span class="ctlLabel">
            Text color <span class="tpInline">kule pi sitelen</span>
          </span>
          <input id="fgPick" class="swatch" type="color" aria-label="Foreground color">
        </div>

        <!-- Font size -->
        <div id="ctlFontSize" class="inlineControl inlinePill" role="group" aria-label="Font size">
          <span class="ctlLabel">
            Font size <span class="tpInline">suli pi sitelen</span>
          </span>
          <select id="fontSizeSel" aria-describedby="fontSizeHelp">
            <option value="12">12 px</option>
            <option value="16">16 px</option>
            <option value="20">20 px</option>
            <option value="24">24 px</option>
            <option value="28">28 px</option>
            <option value="32">32 px</option>
            <option value="36">36 px</option>
            <option value="40">40 px</option>
            <option value="44">44 px</option>
            <option value="48">48 px</option>
            <option value="56" selected>56 px</option>
            <option value="64">64 px</option>
            <option value="72">72 px</option>
            <option value="80">80 px</option>
            <option value="88">88 px</option>
            <option value="96">96 px</option>
            <option value="120">120 px</option>
          </select>
          <div id="fontSizeHelp" class="sr-only">Changes the glyph and cartouche rendering size in the output.</div>
        </div>

      </div>
    </div>

    <div style="margin-top:14px;">
      <label>
        Output canvas
        <span class="tpLine">ilo sitelen kama</span>
      </label>
      <canvas id="outCanvas" aria-hidden="true"></canvas>

      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button id="btnDownloadPng" type="button" class="btnBi" aria-describedby="btnDownloadHelp">
          <span>Download PNG</span>
          <span class="tpLine">o kama jo e sitelen PNG</span>
        </button>
        <div id="btnDownloadHelp" class="sr-only">Downloads the output canvas as a transparent PNG.</div>

        <span class="small">
          (Transparent background)
          <span class="tpLine">(poka sitelen li lon ala)</span>
        </span>
      </div>

      <div class="help">&nbsp;</div>

      <div class="nlModeControl">
        <fieldset style="border:1px solid var(--border); border-radius:10px; padding:10px 12px; max-width: 560px;">
          <legend class="sr-only">Nanpa-linja-n render mode</legend>

          <div style="font-size:12px; color: var(--muted); margin-bottom:6px;">
            Nanpa-linja-n number output
          </div>

          <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
            <label style="display:flex; align-items:center; gap:8px; margin:0;">
              <input type="radio" name="nlMode" value="traditional" checked>
              <span>Traditional</span>
            </label>

            <label style="display:flex; align-items:center; gap:8px; margin:0;">
              <input type="radio" name="nlMode" value="uniform">
              <span>Uniform</span>
            </label>
          </div>
        </fieldset>
      </div>

      <div class="help">&nbsp;</div>
      <img class="portrait" src="./images/From_Decimal_Number_To_Cartouche.png" />
      <div class="help">&nbsp;</div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer
        <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a id="rendererLink" class="repoLink" href="./renderer.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n decimal number encoder + cartouche renderer
        </a>
        <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
      </div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n cartouche calculator
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a id="calculatorLink" class="repoLink" href="./calculator.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n cartouche calculator
        </a>
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n maze game
        <span class="tpLine">o lukin e musi pi nasin pi nanpa-linja-n lon toki pona</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a class="repoLink" href="./maze-toki.html" target="_blank" rel="noopener noreferrer">
          maze game
        </a>
        <span class="tpLine">musi pi nasin pi nanpa-linja-n lon toki pona</span>
      </div>

      <h1 class="nlModeControl" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona 15 puzzle game
        <span class="tpLine">o lukin e musi pi leko tawa nanpa Newelen pi toki pona</span>
      </h1>
      <div class="nlModeControl small" style="margin-bottom:10px;">
        <a class="repoLink" href="./15-puzzle-toki.html" target="_blank" rel="noopener noreferrer">
          15 puzzle game
        </a>
        <span class="tpLine">musi pi leko tawa nanpa Newelen pi toki pona</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out more Toki Pona tools
        <span class="tpLine">o lukin e ilo ante lon toki pona</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="./index.html" target="_blank" rel="noopener noreferrer">
          More Toki Pona tools
        </a>
        <span class="tpLine">ilo ante lon toki pona</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona sitelen pona fonts
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n/tree/main/docs/fonts" target="_blank" rel="noopener noreferrer">
          sitelen pona nanpa-linja-n fonts
        </a>
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </div>

      <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n main documentation
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </h1>
      <div class="help">The main documentation contains all the rules for converting decimal numbers into cartouches.</div>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n main documentation
        </a>
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </div>

      <div class="help">#~n</div>
    </div>
  </main>

  <script>
    "use strict";

    const elSrStatus = document.getElementById("srStatus");
    function announceStatus(msg) {
      if (!elSrStatus) return;
      elSrStatus.textContent = String(msg ?? "");
    }
    function showAlertAndAnnounce(msg) {
      const s = String(msg ?? "Unknown error");
      announceStatus(s);
      alert(s);
    }
    function nextFrame() {
      return new Promise(resolve => requestAnimationFrame(() => resolve()));
    }

    const FONT_FAMILY_TEXT = "TP-Nasin-Nanpa-Font";
    const FONT_FAMILY_CARTOUCHE = "TP-Cartouche-Font";
    const FONT_FAMILY_LITERAL = "Patrick-Head-Font";

    const FG_COLOR_STORAGE_KEY = "tpFgHex";
const FG_COLOR_QUERY_PARAM = "fg"; // optional: "#RRGGBB" (e.g. %23112233)

function clampByte(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return null;
  const i = Math.round(x);
  if (i < 0) return 0;
  if (i > 255) return 255;
  return i;
}

function byteToHex2(n) {
  const s = (n | 0).toString(16).toUpperCase();
  return (s.length === 1) ? ("0" + s) : s;
}

function rgbToHex(r, g, b) {
  return "#" + byteToHex2(r) + byteToHex2(g) + byteToHex2(b);
}

function parseRgbCsv(s) {
  const raw = String(s ?? "").trim();
  if (!raw) return null;
  const parts = raw.split(",").map(p => p.trim()).filter(Boolean);
  if (parts.length !== 3) return null;
  const r = clampByte(parts[0]);
  const g = clampByte(parts[1]);
  const b = clampByte(parts[2]);
  if (r == null || g == null || b == null) return null;
  return { r, g, b };
}

/**
 * Accepts:
 *  - "#RRGGBB" (any case)
 *  - "R,G,B"   (legacy, decimal 0..255)
 * Returns "#RRGGBB" uppercase, or null.
 */
function normalizeHexColor(s) {
  const raw = String(s ?? "").trim();
  if (!raw) return null;

  // Modern hex
  const m = /^#([0-9a-f]{6})$/i.exec(raw);
  if (m) return ("#" + m[1].toUpperCase());

  // Legacy CSV "R,G,B"
  const rgb = parseRgbCsv(raw);
  if (rgb) return rgbToHex(rgb.r, rgb.g, rgb.b);

  return null;
}


function readFgHexFromQuery() {
  try {
    const params = new URLSearchParams(window.location.search || "");
    return normalizeHexColor(params.get(FG_COLOR_QUERY_PARAM));
  } catch {
    return null;
  }
}

function loadFgHexFromStorage() {
  try {
    return normalizeHexColor(localStorage.getItem(FG_COLOR_STORAGE_KEY));
  } catch {
    return null;
  }
}

function saveFgHexToStorage(hex) {
  try { localStorage.setItem(FG_COLOR_STORAGE_KEY, hex); } catch {}
}

function getFgHex() {
  const pick = document.getElementById("fgPick");
  return normalizeHexColor(pick?.value) ?? "#000000";
}

function setFgHex(hex) {
  const pick = document.getElementById("fgPick");
  const h = normalizeHexColor(hex) ?? "#000000";
  if (pick) pick.value = h;
  saveFgHexToStorage(h);
  return h;
}

function initFgColorControls() {
  const q = readFgHexFromQuery();
  if (q) { setFgHex(q); return; }

  const s = loadFgHexFromStorage();
  if (s) { setFgHex(s); return; }

  setFgHex("#000000");
}

function wireFgColorControls() {
  const pick = document.getElementById("fgPick");
  if (!pick) return;

  // Use "input" for live updates while dragging; use "change" for updates on close.
  pick.addEventListener("input", async () => {
    try {
      const hex = getFgHex();
      saveFgHexToStorage(hex);
      await renderFromTextarea();
    } catch (e) {
      showAlertAndAnnounce(e?.message ?? String(e));
    }
  });
}


    /* ============================
       Font size selection (remember + query param)
       ============================ */
    const FONT_SIZE_STORAGE_KEY = "tpFontPx";
    const FONT_SIZE_QUERY_PARAM = "fontPx";
    const FONT_SIZE_QUERY_PARAM_ALIAS = "fontSize";
    const FONT_SIZE_ALLOWED = [12,16, 20, 24, 28, 32, 36, 40, 44, 48, 56, 64, 72, 80, 88, 96, 120];

    function clampAllowedFontPx(px) {
      const n = Number(px);
      if (!Number.isFinite(n)) return null;
      const i = Math.round(n);
      if (FONT_SIZE_ALLOWED.includes(i)) return i;
      if (i >= 12 && i <= 220) return i;
      return null;
    }

    function getFontPx() {
      const sel = document.getElementById("fontSizeSel");
      const v = sel ? sel.value : "";
      const px = clampAllowedFontPx(v);
      return px ?? 56;
    }

    function setFontPx(px) {
      const val = clampAllowedFontPx(px) ?? 56;
      const sel = document.getElementById("fontSizeSel");
      if (sel) {
        const exists = Array.from(sel.options).some(o => Number(o.value) === val);
        if (!exists) {
          const opt = document.createElement("option");
          opt.value = String(val);
          opt.textContent = `${val} px`;
          sel.appendChild(opt);
        }
        sel.value = String(val);
      }
      try { localStorage.setItem(FONT_SIZE_STORAGE_KEY, String(val)); } catch {}
      return val;
    }

    function readFontPxFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw = params.get(FONT_SIZE_QUERY_PARAM) ?? params.get(FONT_SIZE_QUERY_PARAM_ALIAS) ?? "";
        const val = clampAllowedFontPx(raw);
        return val;
      } catch {
        return null;
      }
    }

    function loadFontPxFromStorage() {
      try {
        const raw = localStorage.getItem(FONT_SIZE_STORAGE_KEY);
        const val = clampAllowedFontPx(raw);
        return val;
      } catch {
        return null;
      }
    }

    function applyFontPxFromQueryOrStorage() {
      const q = readFontPxFromQuery();
      if (q != null) { setFontPx(q); return; }
      const s = loadFontPxFromStorage();
      if (s != null) setFontPx(s);
      else setFontPx(56);
    }

    function wireFontSizeSelect() {
      const sel = document.getElementById("fontSizeSel");
      if (!sel) return;
      sel.addEventListener("change", async () => {
        try {
          const px = setFontPx(sel.value);
          DID_WARMUP = false;
          await fontsReadyForPx(px);
          await renderFromTextarea();
        } catch (e) {
          showAlertAndAnnounce(e?.message ?? String(e));
        }
      });
    }

    const WORD_GAP_PX  = 12;
    const LINE_GAP_PX  = 18;

    const CARTOUCHE_START_CP = 0xF1990;
    const CARTOUCHE_END_CP   = 0xF1991;

    // Long "pi { ... }" container glyphs
    const LONG_PI_START_CP = 0xF1993;   // START OF LONG PI
    const LONG_PI_EXT_CP   = 0xF1994;   // COMBINING LONG PI EXTENSION

    function tokenHasOpenCurly(tok) {
      return String(tok ?? "").includes("{");
    }

    function tokenHasCloseCurly(tok) {
      return String(tok ?? "").includes("}");
    }

    function extractCurlyContentFromTokens(tokens, startIdx) {
      let j = startIdx;
      while (j < tokens.length && !tokenHasCloseCurly(tokens[j])) j++;
      if (j >= tokens.length) return null; // no closing brace

      const joined = tokens.slice(startIdx, j + 1).join(" ");
      const open = joined.indexOf("{");
      const close = joined.lastIndexOf("}");
      if (open < 0 || close < 0 || close <= open) return null;

      const inner = joined.slice(open + 1, close).trim();
      return { inner, endIndex: j };
    }

    // Letters-only normalization (used by number-phrase parsing etc.)
    function normalizeTpWord(raw) { return String(raw ?? "").toLowerCase().replace(/[^a-z]/g, ""); }

    // NEW: glyph-key normalization (used for WORD_TO_UCSUR_CP lookups)
    // Keeps: a-z plus ^ < > : , . and middle dot ·
    function normalizeTpGlyphKey(raw) {
      return String(raw ?? "")
        .toLowerCase()
        .trim()
        .replace(/[^a-z^<>:,.·]/g, "");
    }

    function parseKnownTpWords(innerText) {
      // UPDATED: accept known glyph-keys, not just letters-only words
      const raw = String(innerText ?? "");
      const parts = raw.split(/\s+/).map(normalizeTpGlyphKey).filter(Boolean);
      const known = parts.filter(w => WORD_TO_UCSUR_CP[w] != null);
      return known;
    }

    async function ensureFontLoaded(pxOverride) {
      if (!document.fonts || !document.fonts.load || !document.fonts.check) return;

      const px = Math.max(8, Number(pxOverride ?? getFontPx() ?? 56));

      const sampleTextChar = String.fromCodePoint(0xF196C); // toki
      const sampleCartChar = String.fromCodePoint(0xF1990); // cartouche start
      const sampleLiteral  = "Hello";                       // literal font sample

      try {
        const okText = document.fonts.check(`${px}px "${FONT_FAMILY_TEXT}"`, sampleTextChar);
        const okCart = document.fonts.check(`${px}px "${FONT_FAMILY_CARTOUCHE}"`, sampleCartChar);
        const okLit  = document.fonts.check(`${px}px "${FONT_FAMILY_LITERAL}"`, sampleLiteral);

        const loads = [];
        if (!okText) loads.push(document.fonts.load(`${px}px "${FONT_FAMILY_TEXT}"`, sampleTextChar));
        if (!okCart) loads.push(document.fonts.load(`${px}px "${FONT_FAMILY_CARTOUCHE}"`, sampleCartChar));
        if (!okLit)  loads.push(document.fonts.load(`${px}px "${FONT_FAMILY_LITERAL}"`, sampleLiteral));

        if (loads.length) await Promise.all(loads);

        await document.fonts.ready;

        const okText2 = document.fonts.check(`${px}px "${FONT_FAMILY_TEXT}"`, sampleTextChar);
        const okCart2 = document.fonts.check(`${px}px "${FONT_FAMILY_CARTOUCHE}"`, sampleCartChar);
        const okLit2  = document.fonts.check(`${px}px "${FONT_FAMILY_LITERAL}"`, sampleLiteral);

        if (!okText2 || !okCart2 || !okLit2) {
          await Promise.all([
            document.fonts.load(`${px}px "${FONT_FAMILY_TEXT}"`, sampleTextChar),
            document.fonts.load(`${px}px "${FONT_FAMILY_CARTOUCHE}"`, sampleCartChar),
            document.fonts.load(`${px}px "${FONT_FAMILY_LITERAL}"`, sampleLiteral),
          ]);
          await document.fonts.ready;
        }
      } catch (e) {
        console.warn("[font] load threw error:", e);
      }
    }

    function warmUpCanvasFonts() {
      const c = document.createElement("canvas");
      c.width = 2; c.height = 2;
      const ctx = c.getContext("2d");

      const px = getFontPx();

      ctx.textBaseline = "alphabetic";

      ctx.font = `${px}px "${FONT_FAMILY_TEXT}"`;
      ctx.fillText(String.fromCodePoint(0xF196C), 0, 1);

      ctx.font = `${px}px "${FONT_FAMILY_CARTOUCHE}"`;
      ctx.fillText(String.fromCodePoint(0xF1990), 0, 1);
    }

    let DID_WARMUP = false;

    function warmUpCanvasFontsOnce() {
      if (DID_WARMUP) return;
      DID_WARMUP = true;
      warmUpCanvasFonts();
    }

    let FONTS_READY_PROMISE = null;
    let FONTS_READY_PX = null;

    function fontsReadyForPx(px) {
      const p = Math.max(8, Number(px ?? getFontPx() ?? 56));
      if (!FONTS_READY_PROMISE || FONTS_READY_PX !== p) {
        FONTS_READY_PX = p;
        FONTS_READY_PROMISE = (async () => {
          await ensureFontLoaded(p);
          await nextFrame();
          await nextFrame();
        })();
      }
      return FONTS_READY_PROMISE;
    }

    /* ============================
       Remember Traditional/Uniform + query param
       ============================ */
    const NL_MODE_STORAGE_KEY = "nlMode";
    const NL_MODE_QUERY_PARAM = "nlMode";
    const NL_MODE_QUERY_PARAM_ALIAS = "cartoucheDisplay";

    function getNanpaLinjanMode() {
      //const el = document.querySelector('input[name="nlMode"]:checked');
      //return (el && (el.value === "uniform" || el.value === "traditional")) ? el.value : "traditional";
      return "uniform";
    }

    function setNanpaLinjanMode(mode) {
      const v = (mode === "uniform") ? "uniform" : "traditional";
      const target = document.querySelector(`input[name="nlMode"][value="${v}"]`);
      if (target) target.checked = true;
      try { localStorage.setItem(NL_MODE_STORAGE_KEY, v); } catch {}
    }

    function loadNanpaLinjanModeFromStorage() {
      try {
        const v = localStorage.getItem(NL_MODE_STORAGE_KEY);
        if (v === "uniform" || v === "traditional") setNanpaLinjanMode(v);
      } catch {}
    }

    function readNanpaLinjanModeFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw =
          params.get(NL_MODE_QUERY_PARAM) ??
          params.get(NL_MODE_QUERY_PARAM_ALIAS) ??
          "";
        const v = String(raw).toLowerCase().trim();
        if (v === "uniform" || v === "traditional") return v;
      } catch {}
      return null;
    }

    function applyNanpaLinjanModeFromQueryOrStorage() {
      const q = readNanpaLinjanModeFromQuery();
      if (q) { setNanpaLinjanMode(q); return; }
      loadNanpaLinjanModeFromStorage();
    }

    function wireNanpaLinjanModeRadios() {
      const radios = document.querySelectorAll('input[name="nlMode"]');
      radios.forEach(r => {
        r.addEventListener("change", async () => {
          try {
            setNanpaLinjanMode(getNanpaLinjanMode());
            await renderFromTextarea();
          } catch (e) {
            showAlertAndAnnounce(e?.message ?? String(e));
          }
        });
      });
    }

    /* ============================
       Optional default input from query param (not remembered)
       ============================ */
    const INPUT_TEXT_QUERY_PARAM = "text";
    const INPUT_TEXT_QUERY_PARAM_ALIAS = "input";

    function readDefaultInputFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw = params.get(INPUT_TEXT_QUERY_PARAM) ?? params.get(INPUT_TEXT_QUERY_PARAM_ALIAS);
        if (raw == null) return null;

        const s = String(raw);
        if (!s.trim()) return null;

        return s.replace(/\\n/g, "\n");
      } catch {
        return null;
      }
    }

    function applyDefaultInputFromQuery() {
      const s = readDefaultInputFromQuery();
      if (s == null) return;
      if (elTextIn) elTextIn.value = s;
    }

    /* ============================
       Word → UCSUR map
       ============================ */
    const WORD_TO_UCSUR_CP = {
      "a": 0xF1900, "akesi": 0xF1901, "ala": 0xF1902, "alasa": 0xF1903,
      "ale": 0xF1904, "ali": 0xF1904, "anpa": 0xF1905, "ante": 0xF1906, "anu": 0xF1907,
      "awen": 0xF1908, "e": 0xF1909, "en": 0xF190A, "esun": 0xF190B, "ijo": 0xF190C,
      "ike": 0xF190D, "ilo": 0xF190E, "insa": 0xF190F, "jaki": 0xF1910, "jan": 0xF1911,
      "jelo": 0xF1912, "jo": 0xF1913, "kala": 0xF1914, "kalama": 0xF1915, "kama": 0xF1916,
      "kasi": 0xF1917, "ken": 0xF1918, "kepeken": 0xF1919, "kili": 0xF191A, "kiwen": 0xF191B,
      "ko": 0xF191C, "kon": 0xF191D, "kule": 0xF191E, "kulupu": 0xF191F, "kute": 0xF1920,
      "la": 0xF1921, "lape": 0xF1922, "laso": 0xF1923, "lawa": 0xF1924, "len": 0xF1925,
      "lete": 0xF1926, "li": 0xF1927, "lili": 0xF1928, "linja": 0xF1929, "lipu": 0xF192A,
      "loje": 0xF192B, "lon": 0xF192C, "luka": 0xF192D, "lukin": 0xF192E, "lupa": 0xF192F,
      "ma": 0xF1930, "mama": 0xF1931, "mani": 0xF1932, "meli": 0xF1933, "mi": 0xF1934,
      "mije": 0xF1935, "moku": 0xF1936, "moli": 0xF1937, "monsi": 0xF1938, "mu": 0xF1939,
      "mun": 0xF193A, "musi": 0xF193B, "mute": 0xF193C, "nanpa": 0xF193D, "nasa": 0xF193E,
      "nasin": 0xF193F, "nena": 0xF1940,
      "ni": 0xF1941,
    
      "nimi": 0xF1942, "noka": 0xF1943,
      "o": 0xF1944, "olin": 0xF1945, "ona": 0xF1946, "open": 0xF1947, "pakala": 0xF1948,
      "pali": 0xF1949, "palisa": 0xF194A, "pan": 0xF194B, "pana": 0xF194C, "pi": 0xF194D,
      "pilin": 0xF194E, "pimeja": 0xF194F, "pini": 0xF1950, "pipi": 0xF1951, "poka": 0xF1952,
      "poki": 0xF1953, "pona": 0xF1954, "pu": 0xF1955, "sama": 0xF1956, "seli": 0xF1957,
      "selo": 0xF1958, "seme": 0xF1959,
      "sewi": 0xF195A,
     
      "sijelo":0xF195B, "sike": 0xF195C, "sin": 0xF195D,
      "sina": 0xF195E, "sinpin": 0xF195F, "sitelen": 0xF1960, "sona": 0xF1961, "soweli": 0xF1962,
      "su": 0xF19A6,
      "suli": 0xF1963, "suno": 0xF1964, "supa": 0xF1965, "suwi": 0xF1966, "tan": 0xF1967,
      "taso": 0xF1968, "tawa": 0xF1969, "telo": 0xF196A, "tenpo": 0xF196B, "toki": 0xF196C,
      "tomo": 0xF196D, "tu": 0xF196E, "unpa": 0xF196F, "uta": 0xF1970, "utala": 0xF1971,
      "walo": 0xF1972, "wan": 0xF1973, "waso": 0xF1974, "wawa": 0xF1975, "weka": 0xF1976,
      "wile": 0xF1977, "namako": 0xF1978, "kin": 0xF1979, "oko": 0xF197A, "kipisi": 0xF197B,
      "leko": 0xF197C, "monsuta": 0xF197D, "tonsi": 0xF197E, "jasima": 0xF197F,
      "kijetesantakalu": 0xF1980, "soko": 0xF1981, "meso": 0xF1982, "epiku": 0xF1983,
      "kokosila": 0xF1984, "lanpan": 0xF1985, "n": 0xF1986, "misikeke": 0xF1987, "ku": 0xF1988,
      "pake": 0xF19A0, "apeja": 0xF19A1, "majuna": 0xF19A2, "powe": 0xF19A3,
        "linluwi":0xF19A4,
      
         "sewi^": 0xF198C,
  "ni>": 0xF198B,
      "ni^": 0xF198A,
      "ni<": 0xF1989,
      
      // punctuation / helpers
      "·": 0xF199C, ":": 0xF199D, ",": 0xF199E,
      "ota": 0xF199C, "kolon": 0xF199D, "koma": 0xF199E,
     

      // NEW: full stop (requested)
      ".": 0xF199C
    };
    //


    function isKnownTpWord(w) { return WORD_TO_UCSUR_CP[w] != null; }

    /* ============================
       Glyph-token normalization
       ============================ */
    function normalizeTpGlyphToken(raw) {
      const s0 = String(raw ?? "").trim().toLowerCase();
      if (!s0) return "";

      // keep pure punctuation tokens
      if (s0 === ":" || s0 === "·" || s0 === "," || s0 === ".") return s0;

      const stripped = s0.replace(/^[^a-z^<>:,.·]+|[^a-z^<>:,.·]+$/g, "");
      if (!stripped) return "";

      return normalizeTpGlyphKey(stripped);
    }

    function isKnownTpGlyphToken(t) { return WORD_TO_UCSUR_CP[t] != null; }

    /* ============================
       Nanpa-linja-n mappings
       ============================ */
    const NANPA_LINJA_N_WORD_TO_CP = {
      "nanpa": 0xF193D,
      "nasa":  0xF193E,
      "nasin": 0xF193F,
      "nena":  0xF1940,
      "ni":    0xF1941,
      "nimi":  0xF1942,
      "noka":  0xF1943,

      "esun":  0xF190B,
      "en":    0xF190A,
      "e":     0xF1909,

      "o":     0xF1944,
      "ona":   0xF1946,
      "ota":   0xF199C,

      "kulupu":0xF191F,

      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "seli":  0xF1957,
      "awen":  0xF1908,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913
    };

    const CP_NANPA = NANPA_LINJA_N_WORD_TO_CP["nanpa"];
    const CP_NENA  = NANPA_LINJA_N_WORD_TO_CP["nena"];
    const CP_EN    = NANPA_LINJA_N_WORD_TO_CP["en"];

    const UNIFORM_TO_NENA = new Set([
      NANPA_LINJA_N_WORD_TO_CP["nasa"],
      NANPA_LINJA_N_WORD_TO_CP["nasin"],
      NANPA_LINJA_N_WORD_TO_CP["ni"],
      NANPA_LINJA_N_WORD_TO_CP["nimi"],
      NANPA_LINJA_N_WORD_TO_CP["noka"],
      NANPA_LINJA_N_WORD_TO_CP["nena"]
    ]);

    const UNIFORM_TO_EN = new Set([
      NANPA_LINJA_N_WORD_TO_CP["e"],
      NANPA_LINJA_N_WORD_TO_CP["en"],
      NANPA_LINJA_N_WORD_TO_CP["esun"]
    ]);

    function uniformizeNanpaLinjanCartoucheCps(cps) {
      const a = Array.from(cps ?? []);
      if (a.length === 0) return a;

      for (let i = 0; i < a.length; i++) {
        const cp = a[i];

        if (cp === CP_NANPA) {
          if (i !== 0 && i !== a.length - 1) a[i] = CP_NENA;
          continue;
        }
        if (UNIFORM_TO_NENA.has(cp)) { a[i] = CP_NENA; continue; }
        if (UNIFORM_TO_EN.has(cp))   { a[i] = CP_EN; continue; }
      }
      return a;
    }

    const DIGIT_TOKENS = new Set(["NI","WE","TE","SE","NA","LE","NU","ME","PE","JE"]);
    const TOKEN_PREFIXES = ["KEKEKE","KEKE","KE","NONONO","NONO","NE","NO"];

    function nanpaCapsHasAtLeastOneDigitToken(tokens) {
      for (const t of (tokens ?? [])) {
        if (DIGIT_TOKENS.has(t)) return true;
      }
      return false;
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const end = s.length;

      while (i < end - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= end - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    function isValidNanpaLinjanProperName(raw) {
      const s = String(raw ?? "").replace(/\s+/g, "");
      if (!s) return false;
      if (!/^[a-zA-Z]+$/.test(s)) return false;
      if (!/[nN]$/.test(s)) return false;

      const core = s.slice(0, -1);
      if (core.length < 2 || (core.length % 2) !== 0) return false;

      const caps = core.toUpperCase() + "N";
      if (!caps.startsWith("NE")) return false;

      try { tokenizeNanpaCaps(caps); return true; }
      catch { return false; }
    }

    const NUMBER_CODE_LETTER_TO_PAIR = {
      "I":"NI","W":"WE","T":"TE","S":"SE","A":"NA",
      "L":"LE","U":"NU","M":"ME","P":"PE","J":"JE"
    };

    function normalizeNumberCodeInput(raw) {
      return String(raw ?? "").trim().replace(/\s+/g, "");
    }

    function tryParseNanpaLinjanNumberCodeToCaps(raw) {
      const s0 = normalizeNumberCodeInput(raw);
      if (!s0) return null;
      if (!s0.toUpperCase().startsWith("#~")) return null;

      const body = s0.slice(2).toUpperCase();
      if (!body) throw new Error("Number code '#~' must have letters after it.");
      if (!/^[A-Z]+$/.test(body)) throw new Error("Number code may only contain letters A–Z after '#~'.");

      const tokens = ["NE"];
      let i = 0;

      function ensureNEBeforeOperatorRun() {
        if (tokens[tokens.length - 1] !== "NE") tokens.push("NE");
      }

      while (i < body.length) {
        const ch = body[i];

        if (ch === "O") {
          let j = i;
          while (j < body.length && body[j] === "O") j++;
          const count = j - i;
          if (count < 1 || count > 3) throw new Error("Invalid run of 'O' in number code (max 3).");

          if (count === 1) {
            if (i === 0) tokens.push("NO");
            else tokens.push("NO","NE");
          } else {
            tokens.push("NO".repeat(count)); // NONO / NONONO
          }

          i = j;
          continue;
        }

        if (ch === "K") {
          let j = i;
          while (j < body.length && body[j] === "K") j++;
          const count = j - i;
          if (count < 1 || count > 3) throw new Error("Invalid run of 'K' in number code (max 3).");

          ensureNEBeforeOperatorRun();
          tokens.push("KE".repeat(count)); // KE / KEKE / KEKEKE
          i = j;
          continue;
        }

        const pair = NUMBER_CODE_LETTER_TO_PAIR[ch];
        if (!pair) throw new Error(`Invalid letter '${ch}' in number code.`);
        tokens.push(pair);
        i += 1;
      }

      tokens.push("N");

      const caps = tokens.join("");
      tokenizeNanpaCaps(caps);
      return { caps };
    }

    const TOKEN_TO_DIGIT_WORD = {
      "NI":"ijo","WE":"wan","TE":"tu","SE":"seli","NA":"awen",
      "LE":"luka","NU":"utala","ME":"mun","PE":"pipi","JE":"jo"
    };

    const WORD_FOR_NEGATIVE_SIGN = "ona";

    function nanpaCapsTokensToTpWords(tokens, { mode = "traditional" } = {}) {
      if (!tokens || tokens.length === 0) return [];

      const uniform = (mode === "uniform");
      const out = [];

      const E_WORD = uniform ? "en" : "esun";
      const E_WORD_FOR_NE_AFTER_START = uniform ? "en" : "e";
      const N_WORD = uniform ? "nena" : "nasa";

      const N_WORD_DECIMAL_POINT = uniform ? "nena" : "ni";
      const N_WORD_FRACTION = "nena";
      const N_END_WORD = "nanpa";

      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) {
            out.push("nanpa", E_WORD);
            afterStartingNe = true;
          } else {
            out.push(N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
          }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          afterStartingNe = false;
          const digitWord = TOKEN_TO_DIGIT_WORD[t];
          if (t === "NI" || t === "NA" || t === "NU") out.push(N_WORD, digitWord);
          else out.push(digitWord, E_WORD);
          continue;
        }

        if (t === "NO") {
          if (afterStartingNe) {
            out.push(N_WORD, WORD_FOR_NEGATIVE_SIGN);
            afterStartingNe = false;
            continue;
          }

          const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;
          if (nxt === "NE") {
            out.push(N_WORD_DECIMAL_POINT, "o", N_WORD, E_WORD_FOR_NE_AFTER_START);
            afterStartingNe = false;
            i += 1;
            continue;
          }

          out.push(N_WORD_DECIMAL_POINT, "o");
          afterStartingNe = false;
          continue;
        }

        if (t === "NONO") {
          out.push("nena","o","nena","o");
          afterStartingNe = false;
          continue;
        }

        if (t === "NONONO") {
          out.push(N_WORD,"o",N_WORD,"o",N_WORD,"o");
          afterStartingNe = false;
          continue;
        }

        if (t === "KE") { out.push("kulupu", E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START,"kulupu",E_WORD_FOR_NE_AFTER_START); afterStartingNe=false; continue; }

        if (t === "N") { out.push(N_END_WORD); afterStartingNe=false; continue; }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }

    function nanpaCapsToNanpaLinjanCodepoints(caps, { mode = "traditional" } = {}) {
      const tokens = tokenizeNanpaCaps(caps);
      if (!nanpaCapsHasAtLeastOneDigitToken(tokens)) return null;

      const tpWords = nanpaCapsTokensToTpWords(tokens, { mode });

      const cps = [];
      for (const w of tpWords) {
        const cp = NANPA_LINJA_N_WORD_TO_CP[w];
        if (cp == null) return null;
        cps.push(cp);
      }

      if (mode === "uniform") return uniformizeNanpaLinjanCartoucheCps(cps);
      return cps;
    }

    function tryDecodeNanpaLinjanIdentifierToCodepoints(rawText, { mode = "traditional" } = {}) {
      const s = String(rawText ?? "").trim();
      if (!s) return null;

      try {
        const parsed = tryParseNanpaLinjanNumberCodeToCaps(s);
        if (parsed?.caps) return nanpaCapsToNanpaLinjanCodepoints(parsed.caps, { mode });
      } catch {
        return null;
      }

      if (!isValidNanpaLinjanProperName(s)) return null;

      const compact = s.replace(/\s+/g, "");
      const core = compact.slice(0, -1);
      const caps = core.toUpperCase() + "N";
      return nanpaCapsToNanpaLinjanCodepoints(caps, { mode });
    }

    /* ============================================================
       Decimal recognizer + caps encoder
       ============================================================ */
    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]],
    ]);

    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      s = s.replace(/\u2044/g, "/");

      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return s;

      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
      }

      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      if (!prefixRaw) return `${num}/${den}`;

      const isNeg = prefixRaw.startsWith("-");
      const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

      if (!prefix) return `-${num}/${den}`;

      return isNeg ? `-${prefix}+${num}/${den}` : `${prefix}+${num}/${den}`;
    }

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar="_") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      return `${left}${decimalChar}${groups.join(sepChar)}${suffix}`;
    }

    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      s = s.replace(/[−‒–—]/g, "-");

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    const DEC_DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    function numberStrToNanpaCaps(
      s,
      { thousandsChar = ",", groupFractionTriplets = true, fractionGroupSize = 3 } = {}
    ) {
      if (s == null) throw new Error("s must be a string");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, "_");
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          const L = out.length;
          if (L >= 2 && out[L-2] === "NE" && out[L-1] === "NE") return;
          out.push("NE", "NE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "K" || last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount =
              (last === "K" || last === "T") ? 1 :
              (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        const intHasThousandsComma = (thousandsChar && ip.includes(thousandsChar));
        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) { out.push(DEC_DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { out.push("NE","KE"); continue; }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DEC_DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NE","KE");
            for (const d of groups[idx]) out.push(DEC_DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            let remaining = trailingZeroGroups;
            while (remaining > 0) {
              const chunk = Math.min(3, remaining);
              if (out[out.length - 1] !== "NE") out.push("NE");
              out.push("KE".repeat(chunk));
              remaining -= chunk;
              if (remaining > 0) out.push("NE");
            }
          }
        }

        if (hasDecimal) {
          out.push("NO","NE");

          if (!fracPart) throw new Error(`Missing fraction digits after '.' in "${s}"`);

          for (const ch of fracPart) {
            if (/\d/.test(ch)) { out.push(DEC_DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === "_") { pushNene(); continue; }
            if (ch === ",") { pushNene(); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          let remaining = magnitudeSuffixKeCount;
          while (remaining > 0) {
            const chunk = Math.min(3, remaining);
            if (out[out.length - 1] !== "NE") out.push("NE");
            out.push("KE".repeat(chunk));
            remaining -= chunk;
            if (remaining > 0) out.push("NE");
          }
        }

        out.push("N");
        return out.join("");
      }

      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
      }

      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);
        return numCaps + "NONO" + denCaps;
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function decimalStringToCaps(rawDecimal, opts = {}) {
      const normalized = normalizeVulgarFractionInput(rawDecimal);
      const caps = looksLikeNanpaCaps(normalized)
        ? normalized.toUpperCase()
        : numberStrToNanpaCaps(normalized, opts);

      tokenizeNanpaCaps(caps);
      return caps;
    }

    function findDecimalSequencesWithCaps(text, opts = {}) {
      const original = String(text ?? "");
      if (!original) return [];

      const s = original.replace(/[−‒–—]/g, "-");

      const vulgarChars = "¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞↉";
      const re = new RegExp(
        String.raw`(?<![A-Za-z])` +
        String.raw`(` +
          String.raw`-?\s*\d*\s*[${vulgarChars}]` +
          "|" +
          String.raw`-?\s*\d[\d, _-]*\s*\+\s*\d[\d, _-]*\s*\/\s*\d[\d, _-]*` +
          "|" +
          String.raw`-?\s*\d[\d, _-]*\s*\/\s*\d[\d, _-]*` +
          "|" +
          String.raw`-?\s*(?:\d[\d, _-]*|\.\d+)(?:\.\d[\d, _-]*)?(?:\s*[kKtTmMbB])?` +
        String.raw`)` +
        String.raw`(?![A-Za-z])`,
        "g"
      );

      const results = [];
      let m;

      while ((m = re.exec(s)) !== null) {
        const rawMatch = m[1];
        if (!rawMatch) continue;

        let candidate = rawMatch.trim().replace(/[)\]}.,;:!?]+$/g, "").trim();
        if (!candidate) continue;
        if (candidate === "-" || candidate === "+") continue;

        const rel = rawMatch.indexOf(candidate);
        const start = (rel >= 0) ? (m.index + rel) : m.index;
        const end = start + candidate.length;

        try {
          const caps = decimalStringToCaps(candidate, {
            thousandsChar: ",",
            groupFractionTriplets: true,
            fractionGroupSize: 3,
            ...opts,
          });

          results.push({ kind: "decimal", match: candidate, index: start, end, caps });
        } catch {
          // ignore
        }
      }

      results.sort((a, b) => a.index - b.index || b.end - a.end);
      const filtered = [];
      let lastEnd = -1;
      for (const r of results) {
        if (r.index < lastEnd) continue;
        filtered.push(r);
        lastEnd = r.end;
      }
      return filtered;
    }

    /* ============================================================
       #~ code and proper-name scanners
       ============================================================ */
    function findNumberCodeSequencesWithCaps(text) {
      const s = String(text ?? "");
      if (!s) return [];

      const re = /#~[A-Za-z]+/g;
      const out = [];
      let m;

      while ((m = re.exec(s)) !== null) {
        const raw = m[0];
        if (!raw) continue;

        const start = m.index | 0;
        const end = start + raw.length;

        try {
          const parsed = tryParseNanpaLinjanNumberCodeToCaps(raw);
          if (parsed?.caps) out.push({ kind: "code", index: start, end, caps: parsed.caps });
        } catch {
          // ignore invalid codes
        }
      }

      return out;
    }

    function findNanpaLinjanProperNameSequencesWithCaps(text) {
      const s = String(text ?? "");
      if (!s) return [];

      const re = /(^|[^A-Za-z])((?:ne)[A-Za-z]*(?:\s+[A-Za-z]{2,}){0,20}[A-Za-z]*[nN])(?![A-Za-z])/gi;

      const hits = [];
      let m;

      while ((m = re.exec(s)) !== null) {
        const lead = m[1] ?? "";
        const rawMatch = m[2] ?? "";
        if (!rawMatch) continue;

        const start = (m.index | 0) + lead.length;
        const end = start + rawMatch.length;

        const compact = rawMatch.replace(/\s+/g, "");
        if (compact.length < 5) continue;
        if (!isValidNanpaLinjanProperName(compact)) continue;

        const core = compact.slice(0, -1);
        const caps = core.toUpperCase() + "N";

        hits.push({ kind: "name", index: start, end, caps });
      }

      return hits;
    }

    /* ============================================================
       Nanpa-linja-n TP number-phrase scanner in plain text
       ============================================================ */
    function findNanpaLinjanTpPhraseSequences(text) {
      const s = String(text ?? "");
      if (!s) return [];

      const tokens = [];
      const reTok = /\S+/g;
      let m;
      while ((m = reTok.exec(s)) !== null) {
        const raw = m[0];
        tokens.push({
          raw,
          norm: normalizeTpWord(raw),
          start: m.index,
          end: (m.index + raw.length)
        });
      }
      if (tokens.length < 3) return [];

      const digitWords = new Set(
        Object.values(TOKEN_TO_DIGIT_WORD).filter(w => NANPA_LINJA_N_WORD_TO_CP[w] != null)
      );

      const hits = [];
      for (let i = 0; i < tokens.length - 2; i++) {
        if (tokens[i].norm !== "nanpa") continue;
        const n1 = tokens[i + 1]?.norm;
        if (!(n1 === "esun" || n1 === "en")) continue;

        let bestJ = -1;
        let bestWords = null;

        for (let j = i + 2; j < tokens.length; j++) {
          if (tokens[j].norm !== "nanpa") continue;

          const words = [];
          let allOk = true;
          let hasDigit = false;

          for (let k = i; k <= j; k++) {
            const w = tokens[k].norm;
            if (!w) { allOk = false; break; }
            if (NANPA_LINJA_N_WORD_TO_CP[w] == null) { allOk = false; break; }
            if (k >= i + 2 && k <= j - 1 && digitWords.has(w)) hasDigit = true;
            words.push(w);
          }

          if (!allOk || !hasDigit) continue;

          bestJ = j;
          bestWords = words;
        }

        if (bestJ >= 0 && bestWords) {
          hits.push({
            kind: "tpPhrase",
            index: tokens[i].start,
            end: tokens[bestJ].end,
            words: bestWords
          });
          i = bestJ;
        }
      }

      return hits;
    }

    function mergeAndGreedyFilterHits(allHits) {
      const hits = Array.from(allHits ?? []).filter(h =>
        h &&
        Number.isFinite(h.index) &&
        Number.isFinite(h.end) &&
        h.end > h.index &&
        (h.caps || (Array.isArray(h.words) && h.words.length > 0))
      );

      function priority(kind) {
        if (kind === "decimal") return 4;
        if (kind === "tpPhrase") return 3;
        if (kind === "code") return 2;
        return 1;
      }

      hits.sort((a, b) => {
        if (a.index !== b.index) return a.index - b.index;
        const la = (a.end - a.index);
        const lb = (b.end - b.index);
        if (la !== lb) return lb - la;
        return priority(b.kind) - priority(a.kind);
      });

      const out = [];
      let lastEnd = -1;

      for (const h of hits) {
        if (h.index < lastEnd) continue;
        out.push(h);
        lastEnd = h.end;
      }

      return out;
    }

    /* ============================
       TP phrase helpers
       ============================ */
    function tryParseNanpaLinjanTpPhraseWords(inputWords) {
      const words = Array.from(inputWords ?? []).map(normalizeTpWord).filter(Boolean);

      if (words.length < 3) return null;
      if (words[0] !== "nanpa") return null;
      if (!(words[1] === "esun" || words[1] === "en")) return null;
      if (words[words.length - 1] !== "nanpa") return null;

      for (const w of words) {
        if (NANPA_LINJA_N_WORD_TO_CP[w] == null) return null;
      }

      const digitWords = new Set(
        Object.values(TOKEN_TO_DIGIT_WORD).filter(w => NANPA_LINJA_N_WORD_TO_CP[w] != null)
      );

      const payload = words.slice(2, -1);
      const hasDigit = payload.some(w => digitWords.has(w));
      if (!hasDigit) return null;

      return { words };
    }

    function nanpaLinjanWordsToCodepoints(words, { mode = "traditional" } = {}) {
      const cps = [];
      for (const w0 of (words ?? [])) {
        const w = normalizeTpWord(w0);
        const cp = NANPA_LINJA_N_WORD_TO_CP[w];
        if (cp == null) return null;
        cps.push(cp);
      }
      if (mode === "uniform") return uniformizeNanpaLinjanCartoucheCps(cps);
      return cps;
    }

    function tpWordsToCodepoints(wordsOrTokens) {
      const cps = [];
      for (const w of (wordsOrTokens ?? [])) {
        const cp = WORD_TO_UCSUR_CP[w];
        if (cp != null) cps.push(cp);
      }
      return cps;
    }

    function setTextQuality(ctx) {
      try { ctx.textRendering = "optimizeLegibility"; } catch (_) {}
      try { ctx.fontKerning = "normal"; } catch (_) {}
    }

    /* ============================
       Random letters → glyphs
       ============================ */
    function buildLetterBuckets() {
      const buckets = new Map();
      for (const w of Object.keys(WORD_TO_UCSUR_CP)) {
        const k = String(w);
        if (!k) continue;
        const first = k[0].toLowerCase();
        if (!/^[a-z]$/.test(first)) continue;
        if (!buckets.has(first)) buckets.set(first, []);
        buckets.get(first).push(k);
      }
      return buckets;
    }
    const LETTER_BUCKETS = buildLetterBuckets();

    function randInt(n) {
      if (n <= 0) return 0;
      if (globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
        const buf = new Uint32Array(1);
        globalThis.crypto.getRandomValues(buf);
        return buf[0] % n;
      }
      return Math.floor(Math.random() * n);
    }

    function randomGlyphCpForLetter(letter) {
      const l = String(letter ?? "").toLowerCase();
      const arr = LETTER_BUCKETS.get(l);
      if (!arr || arr.length === 0) return null;

      // Exclude convenience punctuation-words from random output
      const banned = new Set(["ota", "kolon", "koma"]);
      const filtered = arr.filter(w => !banned.has(w));

      if (filtered.length === 0) return null;

      const word = filtered[randInt(filtered.length)];
      return WORD_TO_UCSUR_CP[word] ?? null;
    }

    function lettersToRandomGlyphCps(letters) {
      const cps = [];
      const s = String(letters ?? "").toLowerCase().replace(/[^a-z]/g, "");
      for (const ch of s) {
        const cp = randomGlyphCpForLetter(ch);
        if (cp != null) cps.push(cp);
      }
      return cps;
    }

    function splitLineIntoSegments(line) {
      const s = String(line ?? "");
      const out = [];

      let i = 0;

      function pushTextSegment(txt) {
        if (txt) out.push({ kind: "text", value: txt });
      }

      while (i < s.length) {
        const ch = s[i];

        if (ch === "[") {
          const j = s.indexOf("]", i + 1);
          if (j < 0) {
            pushTextSegment(s.slice(i));
            break;
          }
          pushTextSegment(s.slice(i, i));
          out.push({ kind: "bracket", value: s.slice(i + 1, j) });
          i = j + 1;
          continue;
        }

        if (ch === '"') {
          let j = i + 1;
          let found = false;
          while (j < s.length) {
            if (s[j] === '"' && s[j - 1] !== "\\") { found = true; break; }
            j++;
          }
          if (!found) {
            pushTextSegment(s.slice(i));
            break;
          }

          out.push({ kind: "quote", value: s.slice(i + 1, j) });
          i = j + 1;
          continue;
        }

        let j = i;
        while (j < s.length && s[j] !== "[" && s[j] !== '"') j++;
        pushTextSegment(s.slice(i, j));
        i = j;
      }

      return out;
    }

    function pushGapIfNeeded(elements, px) {
      if (elements.length === 0) return;
      const last = elements[elements.length - 1];
      if (last && last.type === "gap") return;
      elements.push({ type: "gap", px: px });
    }

    function renderFontCartoucheToCanvas(canvas, innerCps, { fontPx, padPx, fontFamily, fgCss }) {
      if (!canvas) throw new Error("renderFontCartoucheToCanvas: canvas missing");
      if (!innerCps || innerCps.length === 0) return { w: 0, h: 0, baselineY: 0 };

      const px = fontPx;
      const pad = padPx;
      const fam = fontFamily || FONT_FAMILY_TEXT;

      const run =
        String.fromCodePoint(CARTOUCHE_START_CP) +
        innerCps.map(cp => String.fromCodePoint(cp)).join("") +
        String.fromCodePoint(CARTOUCHE_END_CP);

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";
      ctx.font = `${px}px "${fam}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(run);

      const ascent  = (m.actualBoundingBoxAscent  != null) ? m.actualBoundingBoxAscent  : Math.ceil(px * 0.95);
      const descent = (m.actualBoundingBoxDescent != null) ? m.actualBoundingBoxDescent : Math.ceil(px * 0.35);

      const left  = (m.actualBoundingBoxLeft  != null) ? m.actualBoundingBoxLeft  : 0;
      const right = (m.actualBoundingBoxRight != null) ? m.actualBoundingBoxRight : Math.ceil(m.width);

      const w = Math.max(1, Math.ceil(left + right + pad * 2));
      const h = Math.max(1, Math.ceil(ascent + descent + pad * 2));

      canvas.width = w;
      canvas.height = h;

      const ctx2 = canvas.getContext("2d", { alpha: true });
      ctx2.clearRect(0, 0, w, h);
      ctx2.textBaseline = "alphabetic";
      ctx2.font = `${px}px "${fam}"`;
      setTextQuality(ctx2);

      ctx2.fillStyle = fgCss || "#111";

      const x = pad + left;
      const baselineY = pad + ascent;

      ctx2.fillText(run, x, baselineY);

      return { w, h, baselineY };
    }

    function makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily, fgCss }) {
      if (!cps || cps.length === 0) return;
      pushGapIfNeeded(elements, WORD_GAP_PX);

      const cart = document.createElement("canvas");
      const padPx = Math.max(4, Math.round(fontPx * 0.11));

      const r = renderFontCartoucheToCanvas(cart, cps, { fontPx, padPx, fontFamily, fgCss });
      if ((r.w | 0) <= 0 || (r.h | 0) <= 0) return;

      const baselineY = r.baselineY | 0;
      const ascent = baselineY;
      const descent = (r.h | 0) - baselineY;

      elements.push({
        type: "cartouche",
        canvas: cart,
        w: r.w,
        h: r.h,
        baselineY,
        ascent,
        descent,
        fontFamily: fontFamily || FONT_FAMILY_TEXT
      });
    }

    function makeRunElementFromCodepoints(elements, cps, { fontPx, fontFamily }) {
      if (!cps || cps.length === 0) return;
      pushGapIfNeeded(elements, WORD_GAP_PX);

      elements.push({
        type: "run",
        cps: Array.from(cps),
        px: fontPx,
        fontFamily: fontFamily || FONT_FAMILY_TEXT
      });
    }

    function renderTpWordsFromText(text, elements, { fontPx, mode }) {
      const rawTokens = String(text ?? "").trim().split(/\s+/).filter(Boolean);

      function emitPunctGlyph(ch) {
        // UPDATED: allow : · , .
        if (ch !== ":" && ch !== "·" && ch !== "," && ch !== ".") return false;
        const cp = WORD_TO_UCSUR_CP[ch];
        if (cp == null) return false;
        pushGapIfNeeded(elements, WORD_GAP_PX);
        elements.push({ type: "glyph", cp, px: fontPx, fontFamily: FONT_FAMILY_TEXT });
        return true;
      }

      function splitTokenPunct(tok) {
        const s = String(tok ?? "");
        if (!s) return { lead: "", core: "", trail: "" };

        // Decide whether this token should keep '.' and ',' inside the core
        // (e.g. 12,340.57 or .06 or -0.5)
        const numericLike =
          /[0-9]/.test(s) ||
          /^-?\.\d/.test(s) ||
          /^-?\d/.test(s);

        // Core characters:
        // - always: letters/digits, #~, ^<> (compound glyph keys like ni<)
        // - numericLike: also allow decimal/thousands punctuation (., _) and '-' inside
        const coreChar = numericLike
          ? /[#~A-Za-z0-9^<>.,_-]/
          : /[#~A-Za-z0-9^<>]/;

        let a = 0;
        let b = s.length;

        // Trim leading non-core chars into "lead"
        while (a < b && !coreChar.test(s[a])) a++;

        // Trim trailing non-core chars into "trail"
        while (b > a && !coreChar.test(s[b - 1])) b--;

        // EXTRA: even for numericLike tokens, strip common sentence punctuation at the end
        // so "12,340.57." => core "12,340.57" + trail "."
        while (b > a && /[)\]}.,;:!?]+$/.test(s.slice(b - 1, b))) b--;

        return { lead: s.slice(0, a), core: s.slice(a, b), trail: s.slice(b) };
      }


      for (let i = 0; i < rawTokens.length; i++) {
        const tok = rawTokens[i];
        const normTok = normalizeTpWord(tok);

        if (normTok === "pi") {
          const nextTok = rawTokens[i + 1];
          if (nextTok != null && tokenHasOpenCurly(nextTok)) {
            const extracted = extractCurlyContentFromTokens(rawTokens, i + 1);

            if (extracted && extracted.inner != null) {
              const innerWords = parseKnownTpWords(extracted.inner);

              if (innerWords.length >= 2) {
                const cps = [];
                cps.push(LONG_PI_START_CP);
                cps.push(WORD_TO_UCSUR_CP[innerWords[0]]);

                for (let k = 1; k < innerWords.length; k++) {
                  cps.push(LONG_PI_EXT_CP);
                  cps.push(WORD_TO_UCSUR_CP[innerWords[k]]);
                }

                makeRunElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_TEXT });
                i = extracted.endIndex;
                continue;
              }
            }
          }
        }

        const { lead, core, trail } = splitTokenPunct(tok);
        for (const ch of lead) emitPunctGlyph(ch);

        const trimmed = core;

        if (trimmed) {
          const idCps =
            tryDecodeNanpaLinjanIdentifierToCodepoints(trimmed, { mode }) ??
            tryDecodeNanpaLinjanIdentifierToCodepoints(trimmed.replace(/\s+/g, ""), { mode });

          if (idCps && idCps.length) {
            makeCartoucheElementFromCodepoints(elements, idCps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE });
            for (const ch of trail) emitPunctGlyph(ch);
            continue;
          }
        }

        // UPDATED: use glyph-key normalization for WORD_TO_UCSUR_CP lookup
        const glyphKey = normalizeTpGlyphKey(trimmed);
        if (glyphKey && WORD_TO_UCSUR_CP[glyphKey] != null) {
          pushGapIfNeeded(elements, WORD_GAP_PX);
          elements.push({ type: "glyph", cp: WORD_TO_UCSUR_CP[glyphKey], px: fontPx, fontFamily: FONT_FAMILY_TEXT });
        }

        for (const ch of trail) emitPunctGlyph(ch);
      }
    }

    function parseTextSegmentToElements(segmentText, elements, { fontPx }) {
      const mode = getNanpaLinjanMode();
      const s = String(segmentText ?? "");
      if (!s.trim()) return;

      const decHits = findDecimalSequencesWithCaps(s);
      const codeHits = findNumberCodeSequencesWithCaps(s);
      const nameHits = findNanpaLinjanProperNameSequencesWithCaps(s);
      const phraseHits = findNanpaLinjanTpPhraseSequences(s);

      const hits = mergeAndGreedyFilterHits([...decHits, ...phraseHits, ...codeHits, ...nameHits]);

      if (!hits || hits.length === 0) {
        renderTpWordsFromText(s, elements, { fontPx, mode });
        return;
      }

      let pos = 0;

      for (const h of hits) {
        const a = Math.max(0, h.index | 0);
        const b = Math.max(a, h.end | 0);

        if (a > pos) {
          renderTpWordsFromText(s.slice(pos, a), elements, { fontPx, mode });
        }

        const fgCss = getFgHex(); 

        if (h.kind === "tpPhrase") {
          const cps = nanpaLinjanWordsToCodepoints(h.words, { mode });
          if (cps && cps.length) {
            makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
          } else {
            renderTpWordsFromText(s.slice(a, b), elements, { fontPx, mode });
          }
        } else {
          const cps = nanpaCapsToNanpaLinjanCodepoints(h.caps, { mode });
          if (cps && cps.length) {
            makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
          } else {
            renderTpWordsFromText(s.slice(a, b), elements, { fontPx, mode });
          }
        }

        pos = b;
      }

      if (pos < s.length) {
        renderTpWordsFromText(s.slice(pos), elements, { fontPx, mode });
      }
    }

    function parseQuoteSegmentToElements(quoteContent, elements, { fontPx }) {
      const raw = String(quoteContent ?? "");
      let literal = raw.replace(/\\"/g, '"').replace(/\\\\/g, "\\");
      literal = literal.replace(/\t/g, "    ");
      if (literal.length === 0) return;
      makeLiteralTextElement(elements, literal, { fontPx, fontFamily: FONT_FAMILY_LITERAL });
    }

    function parseBracketSegmentToElements(bracketContent, elements, { fontPx }) {
      const content = String(bracketContent ?? "").trim();
      if (!content) return;

      const mode = getNanpaLinjanMode();
      const fgCss = getFgHex();
      try {
        const caps = decimalStringToCaps(content, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });
        const cps = nanpaCapsToNanpaLinjanCodepoints(caps, { mode });
        if (cps && cps.length) {
          makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
          return;
        }
      } catch {}

      const wordsRaw = content.split(/\s+/).filter(Boolean);
      const words = wordsRaw.map(normalizeTpWord).filter(Boolean);

      const parsedNumber = tryParseNanpaLinjanTpPhraseWords(words);
      if (parsedNumber) {
        const cps = nanpaLinjanWordsToCodepoints(parsedNumber.words, { mode });
        if (cps) makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
        return;
      }

      const idCps =
        tryDecodeNanpaLinjanIdentifierToCodepoints(content, { mode }) ??
        tryDecodeNanpaLinjanIdentifierToCodepoints(content.replace(/\s+/g, ""), { mode });

      if (idCps && idCps.length) {
        makeCartoucheElementFromCodepoints(elements, idCps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
        return;
      }

      const glyphTokens = wordsRaw.map(normalizeTpGlyphToken).filter(Boolean);
      if (glyphTokens.length >= 1 && glyphTokens.every(isKnownTpGlyphToken)) {
        makeCartoucheElementFromCodepoints(elements, tpWordsToCodepoints(glyphTokens), { fontPx, fontFamily: FONT_FAMILY_TEXT, fgCss });
        return;
      }

      makeCartoucheElementFromCodepoints(elements, lettersToRandomGlyphCps(content), { fontPx, fontFamily: FONT_FAMILY_TEXT, fgCss });
    }

    function lineToElements(line, { fontPx }) {
      let s = String(line ?? "");

      const segs = splitLineIntoSegments(s);
      const elements = [];

      for (const seg of segs) {
        if (seg.kind === "text") {
          parseTextSegmentToElements(seg.value, elements, { fontPx });
        } else if (seg.kind === "bracket") {
          parseBracketSegmentToElements(seg.value, elements, { fontPx });
        } else if (seg.kind === "quote") {
          parseQuoteSegmentToElements(seg.value, elements, { fontPx });
        }
      }

      while (elements.length > 0 && elements[elements.length - 1].type === "gap") elements.pop();
      return elements;
    }

    function measureTextRun(ctx, text, px, fontFamily) {
      const chars = String(text ?? "");
      ctx.font = `${px}px "${fontFamily}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(chars);

      const ascent  = (m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8));
      const descent = (m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2));
      const w = Math.ceil(m.width);

      return {
        chars,
        ascent,
        descent,
        left: 0,
        w,
        h: Math.ceil(ascent + descent),
        px,
        fontFamily
      };
    }

    function makeLiteralTextElement(elements, text, { fontPx, fontFamily }) {
      const s = String(text ?? "");
      if (!s) return;

      pushGapIfNeeded(elements, WORD_GAP_PX);
      elements.push({
        type: "text",
        text: s,
        px: fontPx,
        fontFamily: fontFamily || FONT_FAMILY_LITERAL
      });
    }

    function measureGlyph(ctx, cp, px, fontFamily) {
      const ch = String.fromCodePoint(cp);
      ctx.font = `${px}px "${fontFamily}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(ch);

      const ascent  = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

      const left = m.actualBoundingBoxLeft ?? 0;
      const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
      const tightW = Math.ceil(left + right);

      return { ch, ascent, descent, left, w: tightW, h: Math.ceil(ascent + descent), px, fontFamily };
    }

    function measureRun(ctx, cps, px, fontFamily) {
      const chars = (cps ?? []).map(cp => String.fromCodePoint(cp)).join("");
      ctx.font = `${px}px "${fontFamily}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(chars);

      const ascent  = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

      const left = m.actualBoundingBoxLeft ?? 0;
      const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
      const tightW = Math.ceil(left + right);

      return { chars, ascent, descent, left, w: tightW, h: Math.ceil(ascent + descent), px, fontFamily };
    }

    function renderAllLinesToCanvas(outCanvas, linesElements, { fontPx }) {
      const pad = 18;

      const tmp = document.createElement("canvas");
      const ctx = tmp.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const measuredLines = [];
      let maxLineW = 0;
      let totalH = 0;

      for (const lineEls of linesElements) {
        let w = 0;
        let maxAscent = 0;
        let maxDescent = 0;

        const measuredEls = [];

        for (const el of lineEls) {
          if (el.type === "text") {
            const fam = el.fontFamily || FONT_FAMILY_LITERAL;
            const r = measureTextRun(ctx, el.text, el.px ?? fontPx, fam);
            measuredEls.push({ ...el, m: r });
            w += r.w;

            if (r.ascent > maxAscent) maxAscent = r.ascent;
            if (r.descent > maxDescent) maxDescent = r.descent;
            continue;
          }

          if (el.type === "gap") {
            measuredEls.push(el);
            w += Math.max(0, el.px | 0);
            continue;
          }

          if (el.type === "glyph") {
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            const g = measureGlyph(ctx, el.cp, el.px ?? fontPx, fam);
            measuredEls.push({ ...el, m: g });
            w += g.w;

            if (g.ascent > maxAscent) maxAscent = g.ascent;
            if (g.descent > maxDescent) maxDescent = g.descent;
            continue;
          }

          if (el.type === "run") {
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            const r = measureRun(ctx, el.cps, el.px ?? fontPx, fam);
            measuredEls.push({ ...el, m: r });
            w += r.w;

            if (r.ascent > maxAscent) maxAscent = r.ascent;
            if (r.descent > maxDescent) maxDescent = r.descent;
            continue;
          }

          if (el.type === "cartouche") {
            measuredEls.push(el);
            w += (el.w | 0);

            const a = el.ascent ?? Math.ceil((el.h | 0) * 0.7);
            const d = el.descent ?? Math.ceil((el.h | 0) * 0.3);

            if (a > maxAscent) maxAscent = a;
            if (d > maxDescent) maxDescent = d;
            continue;
          }
        }

        const lineBoxH = Math.max(maxAscent + maxDescent, fontPx);
        measuredLines.push({ measuredEls, w, lineBoxH, maxAscent, maxDescent });

        if (w > maxLineW) maxLineW = w;
        totalH += lineBoxH;
      }

      totalH += Math.max(0, (measuredLines.length - 1) * LINE_GAP_PX);

      const outW = Math.max(1, Math.ceil(maxLineW + pad * 2));
      const outH = Math.max(1, Math.ceil(totalH + pad * 2));

      outCanvas.width = outW;
      outCanvas.height = outH;

      const outCtx = outCanvas.getContext("2d", { alpha: true });
      outCtx.clearRect(0, 0, outW, outH);
      outCtx.textBaseline = "alphabetic";
      outCtx.fillStyle = getFgHex();
      setTextQuality(outCtx);

      let y = pad;

      for (let li = 0; li < measuredLines.length; li++) {
        const L = measuredLines[li];
        let x = pad;

        const glyphBaseline = y + L.maxAscent;

        for (const el of L.measuredEls) {
          if (el.type === "text") {
            const m = el.m;
            const fam = el.fontFamily || FONT_FAMILY_LITERAL;
            outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
            outCtx.fillText(m.chars, x, glyphBaseline);
            x += m.w;
            continue;
          }

          if (el.type === "gap") { x += Math.max(0, el.px | 0); continue; }

          if (el.type === "glyph") {
            const m = el.m;
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
            const drawX = x + (m.left ?? 0);
            outCtx.fillText(m.ch, drawX, glyphBaseline);
            x += m.w;
            continue;
          }

          if (el.type === "run") {
            const m = el.m;
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
            const drawX = x + (m.left ?? 0);
            outCtx.fillText(m.chars, drawX, glyphBaseline);
            x += m.w;
            continue;
          }

          if (el.type === "cartouche") {
            const by = (el.baselineY != null) ? (el.baselineY | 0) : Math.floor((el.h | 0) * 0.75);
            const drawY = glyphBaseline - by;
            outCtx.drawImage(el.canvas, x, drawY);
            x += el.w;
            continue;
          }
        }

        y += L.lineBoxH;
        if (li < measuredLines.length - 1) y += LINE_GAP_PX;
      }
    }

    function safeFilenamePart(s) {
      const t = String(s ?? "").trim();
      if (!t) return "sitelen";
      return t.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 80) || "sitelen";
    }

    function downloadCanvasAsTransparentPng(canvas, { filenameBase = "sitelen", scale = 1 } = {}) {
      if (!canvas) throw new Error("Canvas not found.");

      const w = canvas.width | 0;
      const h = canvas.height | 0;
      if (w <= 0 || h <= 0) throw new Error("Canvas is empty (nothing to download yet).");

      const out = document.createElement("canvas");
      out.width = Math.max(1, Math.floor(w * scale));
      out.height = Math.max(1, Math.floor(h * scale));

      const ctx = out.getContext("2d", { alpha: true });
      ctx.clearRect(0, 0, out.width, out.height);
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(canvas, 0, 0, out.width, out.height);

      const filename = safeFilenamePart(filenameBase) + ".png";

      if (out.toBlob) {
        out.toBlob((blob) => {
          if (!blob) throw new Error("PNG export failed (no blob).");
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();

          setTimeout(() => URL.revokeObjectURL(url), 1000);
        }, "image/png");
        return;
      }

      const dataUrl = out.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    const elTextIn = document.getElementById("textIn");
    const outCanvas = document.getElementById("outCanvas");
    const btnRender = document.getElementById("btnRender");
    const btnDownload = document.getElementById("btnDownloadPng");

    async function renderFromTextarea() {
      const fontPx = getFontPx();

      await fontsReadyForPx(fontPx);
      warmUpCanvasFontsOnce();

      const raw = String(elTextIn.value ?? "");
      const lines = raw.replace(/\r\n/g, "\n").split("\n");
      const linesElements = lines.map(line => lineToElements(line, { fontPx }));

      const anyContent = linesElements.some(els =>
        els.some(e => e.type === "glyph" || e.type === "cartouche" || e.type === "run" || e.type === "text")
      );

      if (!anyContent) {
        outCanvas.width = 1;
        outCanvas.height = 1;
        const ctx = outCanvas.getContext("2d");
        ctx.clearRect(0, 0, 1, 1);
        announceStatus("Nothing to render (no recognized words).");
        return;
      }

      renderAllLinesToCanvas(outCanvas, linesElements, { fontPx });
      const  hex  = getFgHex();
      announceStatus(`Rendered sitelen pona. Mode: ${getNanpaLinjanMode()}. Font: ${fontPx}px. Color: ${hex}.`);
    }

    btnRender.addEventListener("click", async () => {
      try { await renderFromTextarea(); }
      catch (e) { showAlertAndAnnounce(e?.message ?? String(e)); }
    });

    btnDownload.addEventListener("click", () => {
      try {
        downloadCanvasAsTransparentPng(outCanvas, { filenameBase: "sitelen", scale: 1 });
        announceStatus("Downloaded PNG.");
      } catch (e) {
        showAlertAndAnnounce(e?.message ?? String(e));
      }
    });

    function setQueryParamOnLink(a, key, value) {
      if (!a) return;
      try {
        const u = new URL(a.getAttribute("href"), window.location.href);
        u.searchParams.set(key, value);
        a.setAttribute("href", u.pathname + "?" + u.searchParams.toString() + u.hash);
      } catch (e) {
        console.warn("[link] failed to set query param:", e);
      }
    }

    function updateExternalLinksWithCartoucheDisplay() {
      const mode = getNanpaLinjanMode();

      const calc = document.getElementById("calculatorLink");
      const rend = document.getElementById("rendererLink");

      setQueryParamOnLink(calc, "cartoucheDisplay", mode);
      setQueryParamOnLink(rend, "cartoucheDisplay", mode);
    }

    function wireCartoucheDisplayLinks() {
      updateExternalLinksWithCartoucheDisplay();

      const radios = document.querySelectorAll('input[name="nlMode"]');
      radios.forEach(r => {
        r.addEventListener("change", () => {
          updateExternalLinksWithCartoucheDisplay();
        });
      });

      const linkIds = ["calculatorLink", "rendererLink"];
      for (const id of linkIds) {
        const a = document.getElementById(id);
        if (!a) continue;
        a.addEventListener("click", () => {
          updateExternalLinksWithCartoucheDisplay();
        });
      }
    }

    window.addEventListener("load", async () => {
      try {
        if (btnRender) btnRender.disabled = true;
        if (btnDownload) btnDownload.disabled = true;
        announceStatus("Loading fonts…");

        applyNanpaLinjanModeFromQueryOrStorage();
        applyFontPxFromQueryOrStorage();
        applyDefaultInputFromQuery();

        initFgColorControls();
        wireFgColorControls();

        wireNanpaLinjanModeRadios();
        wireFontSizeSelect();
        wireCartoucheDisplayLinks();

        await fontsReadyForPx(getFontPx());
        warmUpCanvasFontsOnce();

        if (btnRender) btnRender.disabled = false;
        if (btnDownload) btnDownload.disabled = false;

        announceStatus("Fonts loaded. Ready to render.");
      } catch (e) {
        console.warn(e);
        if (btnRender) btnRender.disabled = false;
        if (btnDownload) btnDownload.disabled = false;
        announceStatus("Font loading failed; rendering may use fallback fonts.");
      }
    });
  </script>
</body>
</html>
