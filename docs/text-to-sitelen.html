<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Multiline Text → Sitelen Pona PNG</title>

  <style>
    :root {
      --pad: 14px;
      --gap: 12px;
      --border: #d0d7de;
      --bg: #F3DFC0;
      --muted: #3f4750;
    }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      margin: 24px;
      background: var(--bg);
    }

    .card {
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 16px;
      max-width: 980px;
    }

    .controlsStack { display:flex; flex-direction:column; gap: 12px; margin-top:14px; }
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; align-items:flex-end; }

    label { display:block; font-size:12px; color: var(--muted); margin-bottom:6px; }

    textarea, input[type="text"], select {
      width: 100%;
      box-sizing: border-box;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      background: var(--bg);
      font: inherit;
    }

    textarea { min-height: 180px; resize: vertical; }

    button {
      border: 1px solid var(--border);
      background: var(--bg);
      padding: 10px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
    }
    button:hover { background: var(--bg); }

    .btnBi {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
      line-height: 1.15;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .help { font-size: 12px; color: var(--muted); margin-top: 6px; line-height: 1.35; }

    .tpLine {
      display: block;
      margin-top: 2px;
      font-size: 10pt;
      color: var(--muted);
      line-height: 1.25;
    }

    canvas {
      display:block;
      border: 1px dashed var(--border);
      border-radius: 10px;
      background: transparent;
      max-width: 100%;
    }

    .small { font-size: 12px; color: var(--muted); }

    button:focus-visible,
    a:focus-visible,
    textarea:focus-visible,
    select:focus-visible,
    .skipLink:focus-visible {
      outline: 3px solid #111;
      outline-offset: 3px;
    }

    .skipLink {
      position: absolute;
      left: -9999px;
      top: 0;
      background: #fff;
      border: 2px solid #111;
      padding: 8px 10px;
      border-radius: 8px;
      color: #111;
      text-decoration: none;
    }
    .skipLink:focus {
      left: 24px;
      top: 24px;
      z-index: 9999;
    }

    .sr-only {
      position: absolute !important;
      width: 1px !important;
      height: 1px !important;
      padding: 0 !important;
      margin: 0 !important;
      overflow: hidden !important;
      clip: rect(0, 0, 0, 0) !important;
      white-space: nowrap !important;
      border: 0 !important;
    }

    .inlineControl {
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 140px;
    }
    .inlineControl label {
      margin: 0;
      font-size: 12px;
      color: var(--muted);
    }
    .inlineControl select {
      padding: 8px 10px;
      width: 160px;
      max-width: 100%;
    }

    /* NEW: RGB picker layout */
    .rgbControl { min-width: 240px; }
    .rgbRow { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .rgbRow select { width: 72px; padding: 8px 10px; }
    .swatch {
      width: 22px;
      height: 22px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: #111;
      flex: 0 0 auto;
    }
    .hexLabel {
      font-size: 12px;
      color: var(--muted);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
    }

    @font-face {
      font-family: "TP-Cartouche-Font";
      src:
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v2.woff2") format("woff2"),
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v2.woff")  format("woff"),
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR-nanpa-linja-n-v2.otf")   format("opentype");
      font-display: swap;
    }

    @font-face {
      font-family: "TP-Nasin-Nanpa-Font";
      src:
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.woff2") format("woff2"),
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.woff")  format("woff"),
        url("./fonts/nasin-nanpa-5.0.0-beta.3-UCSUR.otf")   format("opentype");
      font-display: swap;
    }
  </style>
</head>

<body>
  <a href="#main" class="skipLink">
    Skip to content
    <span class="tpLine">o tawa lipu ni</span>
  </a>

  <main class="card" id="main" role="main" aria-labelledby="pageTitle">
    <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
      Toki Pona Multiline text → sitelen pona glyphs → PNG file
      <span class="tpLine">toki pona sitelen mute-linja tawa sitelen pona lon ilo sitelen</span>
    </h1>

    <div class="help" style="margin-top:10px;">
      <strong>Note:</strong> Any “nanpa-linja-n proper name” used here are encoding labels for numbers only, and do not propose or add any new Toki Pona lexicon.
      <span class="tpLine">
        sona: nimi “nanpa-linja-n proper name” ale lon ni li nimi pi pana nanpa taso. ona li pana ala e nimi sin pi toki pona.
      </span>
    </div>

    <div class="help">
      <strong>Disclaimer:</strong> This tool is provided “as is”, with no claim, guarantee, or warranty that the output is correct,
      complete, or suitable for any purpose. You are responsible for verifying results.
      <span class="tpLine">
        sona: ilo ni li lon nasin “as is”. mi pana ala e wawa pi pona.
        sina o lukin e ni: sitelen li pona anu seme.
      </span>
    </div>

    <div class="help" style="margin-top:10px;">
      Rules:
      <ul style="margin:6px 0 0 18px; padding:0;">
        <li>Converts Toki Pona words to sitelen pona glyphs.</li>
        <li>Unknown words are ignored (except after “nanpa”, where unknown name-tokens are cartouched as letters).</li>
        <li>Recognized nanpa-linja-n number phrases (<span class="mono">nanpa esun|en … nanpa</span>) render as nanpa-linja-n cartouches.</li>
        <li>Decimal-form numbers like <span class="mono">-5,432.10</span>, <span class="mono">1.2K</span>, or <span class="mono">.06</span> render as nanpa-linja-n cartouches.</li>
        <li>End-of-line full stops are not treated as part of a number (e.g. <span class="mono">06.</span>).</li>
        <li><strong>Cartouche:</strong> Inside of <span class="mono">[...]</span>, if all words are toki pona words, then they will all use their own glyphs, otherwise each letter of every word is mapped randomly.</li>
        <li><strong>Cartouche:</strong> Outside of <span class="mono">[...]</span>, only decimals, <span class="mono">#~</span> codes, nanpa-linja-n proper names, and nanpa-linja-n number phrases can produce cartouches.</li>
        <li><strong>Long pi:</strong> A long “pi” container can be written as <span class="mono">pi { ... }</span>.  Must have at least two words inside { ... }.  Cartouche inside long pi isn't working properly.</li>
        <li><strong>Middle dot:</strong> The Unicode character U+00B7 &#x2014; '&#x00B7;' is used to display the middle dot glyph.</li>
        <li><strong>Punctuation:</strong> Word 'ota' maps to middle dot, and word 'kolon' maps to colon, these are non-standard words and are used for convenience only.</li>
     </ul>
    </div>

    <div id="srStatus" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>

    <div class="controlsStack" role="group" aria-label="Input and render action">

      <div>
        <label for="textIn">
          Enter multi-line Toki Pona text
          <span class="tpLine">o pana e sitelen toki pona lon linja mute</span>
        </label>
        <textarea id="textIn" class="mono" spellcheck="false" autocapitalize="none" autocomplete="off"
          placeholder="mi kama sona e toki pona.
nanpa -12,340.57.
nanpa 64.5M.
nanpa 9+3/4.
nanpa 007.
nanpa Newen.
nanpa #~WI.
[ ota kolon ]"></textarea>
      </div>

      <div class="btnRow" aria-label="Actions">
        <button id="btnRender" type="button" class="btnBi">
          <span>Render</span>
          <span class="tpLine">o sitelen</span>
        </button>

        <!-- NEW: Foreground color picker (to the left of font selector) -->
        <div class="inlineControl rgbControl" role="group" aria-label="Text color">
          <label for="fgR">
            Text color
            <span class="tpLine" style="display:inline; margin:0 0 0 6px;">kule pi sitelen</span>
          </label>

          <div class="rgbRow" aria-describedby="fgColorHelp">
            <select id="fgR" aria-label="Red channel"></select>
            <select id="fgG" aria-label="Green channel"></select>
            <select id="fgB" aria-label="Blue channel"></select>
            <div id="fgSwatch" class="swatch" aria-hidden="true"></div>
            <div id="fgHex" class="hexLabel" aria-hidden="true">#111111</div>
          </div>

          <div id="fgColorHelp" class="sr-only">
            Select foreground text color using red, green, and blue channels. The swatch previews the selected color.
          </div>
        </div>

        <div class="inlineControl" role="group" aria-label="Font size">
          <label for="fontSizeSel">
            Font size
            <span class="tpLine" style="display:inline; margin:0 0 0 6px;">suli pi sitelen</span>
          </label>
          <select id="fontSizeSel" aria-describedby="fontSizeHelp">
            <option value="12">12 px</option>
            <option value="16">16 px</option>
            <option value="20">20 px</option>
            <option value="24">24 px</option>
            <option value="28">28 px</option>
            <option value="32">32 px</option>
            <option value="36">36 px</option>
            <option value="40">40 px</option>
            <option value="44">44 px</option>
            <option value="48">48 px</option>
            <option value="56" selected>56 px</option>
            <option value="64">64 px</option>
            <option value="72">72 px</option>
            <option value="80">80 px</option>
            <option value="88">88 px</option>
            <option value="96">96 px</option>
            <option value="120">120 px</option>
          </select>
          <div id="fontSizeHelp" class="sr-only">Changes the glyph and cartouche rendering size in the output.</div>
        </div>
      </div>
    </div>

    <div style="margin-top:14px;">
      <label>
        Output canvas
        <span class="tpLine">ilo sitelen kama</span>
      </label>
      <canvas id="outCanvas" aria-hidden="true"></canvas>

      <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
        <button id="btnDownloadPng" type="button" class="btnBi" aria-describedby="btnDownloadHelp">
          <span>Download PNG</span>
          <span class="tpLine">o kama jo e sitelen PNG</span>
        </button>
        <div id="btnDownloadHelp" class="sr-only">Downloads the output canvas as a transparent PNG.</div>

        <span class="small">
          (Transparent background)
          <span class="tpLine">(poka sitelen li lon ala)</span>
        </span>
      </div>

      <div>
        <fieldset style="border:1px solid var(--border); border-radius:10px; padding:10px 12px; max-width: 560px;">
          <legend class="sr-only">Nanpa-linja-n render mode</legend>

          <div style="font-size:12px; color: var(--muted); margin-bottom:6px;">
            Nanpa-linja-n number output
          </div>

          <div style="display:flex; gap:16px; align-items:center; flex-wrap:wrap;">
            <label style="display:flex; align-items:center; gap:8px; margin:0;">
              <input type="radio" name="nlMode" value="traditional" checked>
              <span>Traditional</span>
            </label>

            <label style="display:flex; align-items:center; gap:8px; margin:0;">
              <input type="radio" name="nlMode" value="uniform">
              <span>Uniform</span>
            </label>
          </div>
        </fieldset>
      </div>

      <div class="help">&nbsp;</div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n decimal number encoder + cartouche renderer
        <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a id="rendererLink" class="repoLink" href="./renderer.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n decimal number encoder + cartouche renderer
        </a>
        <span class="tpLine">ilo pi pana nanpa (poka) + ilo sitelen pi poki nimi</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n cartouche calculator
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a id="calculatorLink" class="repoLink" href="./calculator.html" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n cartouche calculator
        </a>
        <span class="tpLine">ilo nanpa pi poki nimi pi nanpa-linja-n</span>
      </div>

      <h1 style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona sitelen pona fonts
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </h1>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n/tree/main/docs/fonts" target="_blank" rel="noopener noreferrer">
          sitelen pona nanpa-linja-n fonts
        </a>
        <span class="tpLine">o lukin e sitelen ona pi toki pona! mi kepeken sitelen ona mute ni</span>
      </div>

      <h1 id="pageTitle" style="margin:0 0 6px;font-size:18px;">
        Check out the Toki Pona nanpa-linja-n main documentation
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </h1>
      <div class="help">The main documentation contains all the rules for converting decimal numbers into cartouches.</div>
      <div class="small" style="margin-bottom:10px;">
        <a class="repoLink" href="https://github.com/mndillon/toki-pona-nanpa-linja-n" target="_blank" rel="noopener noreferrer">
          nanpa-linja-n main documentation
        </a>
        <span class="tpLine">lipu sona suli pi nanpa-linja-n</span>
      </div>

      <div class="help">#~n</div>
    </div>
  </main>

  <script>
    "use strict";

    const elSrStatus = document.getElementById("srStatus");
    function announceStatus(msg) {
      if (!elSrStatus) return;
      elSrStatus.textContent = String(msg ?? "");
    }
    function showAlertAndAnnounce(msg) {
      const s = String(msg ?? "Unknown error");
      announceStatus(s);
      alert(s);
    }

    const FONT_FAMILY_TEXT = "TP-Nasin-Nanpa-Font";
    const FONT_FAMILY_CARTOUCHE = "TP-Cartouche-Font";

    /* ============================
       NEW: Foreground color selection (remember + optional query param)
       ============================ */
    const FG_COLOR_STORAGE_KEY = "tpFgRgb";
    const FG_COLOR_QUERY_PARAM = "fg"; // optional: "R,G,B" (e.g. 17,34,51)

    function clampByte(n) {
      const x = Number(n);
      if (!Number.isFinite(x)) return null;
      const i = Math.round(x);
      if (i < 0) return 0;
      if (i > 255) return 255;
      return i;
    }

    function byteToHex2(n) {
      const s = (n | 0).toString(16).toUpperCase();
      return (s.length === 1) ? ("0" + s) : s;
    }

    function rgbToHex(r, g, b) {
      return "#" + byteToHex2(r) + byteToHex2(g) + byteToHex2(b);
    }

    function parseRgbCsv(s) {
      const raw = String(s ?? "").trim();
      if (!raw) return null;
      const parts = raw.split(",").map(p => p.trim()).filter(Boolean);
      if (parts.length !== 3) return null;
      const r = clampByte(parts[0]);
      const g = clampByte(parts[1]);
      const b = clampByte(parts[2]);
      if (r == null || g == null || b == null) return null;
      return { r, g, b };
    }

    function readFgRgbFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw = params.get(FG_COLOR_QUERY_PARAM);
        return parseRgbCsv(raw);
      } catch {
        return null;
      }
    }

    function loadFgRgbFromStorage() {
      try {
        const raw = localStorage.getItem(FG_COLOR_STORAGE_KEY);
        return parseRgbCsv(raw);
      } catch {
        return null;
      }
    }

    function saveFgRgbToStorage(r, g, b) {
      try { localStorage.setItem(FG_COLOR_STORAGE_KEY, `${r},${g},${b}`); } catch {}
    }

    function getFgRgb() {
      const rSel = document.getElementById("fgR");
      const gSel = document.getElementById("fgG");
      const bSel = document.getElementById("fgB");

      const r = clampByte(rSel ? rSel.value : null) ?? 0;
      const g = clampByte(gSel ? gSel.value : null) ?? 0;
      const b = clampByte(bSel ? bSel.value : null) ?? 0;

      return { r, g, b, css: `rgb(${r} ${g} ${b})`, hex: rgbToHex(r, g, b) };
    }

    function setFgRgb(r, g, b) {
      const rr = clampByte(r) ?? 0;
      const gg = clampByte(g) ?? 0;
      const bb = clampByte(b) ?? 0;

      const rSel = document.getElementById("fgR");
      const gSel = document.getElementById("fgG");
      const bSel = document.getElementById("fgB");

      if (rSel) rSel.value = String(rr);
      if (gSel) gSel.value = String(gg);
      if (bSel) bSel.value = String(bb);

      updateFgColorPreview();
      saveFgRgbToStorage(rr, gg, bb);
      return { r: rr, g: gg, b: bb };
    }

    function updateFgColorPreview() {
      const { css, hex } = getFgRgb();
      const sw = document.getElementById("fgSwatch");
      const hx = document.getElementById("fgHex");
      if (sw) sw.style.background = css;
      if (hx) hx.textContent = hex;
    }

    function populateRgbSelect(sel, labelPrefix) {
      if (!sel) return;
      sel.innerHTML = "";
      // Use 0..255 step 17 (0,17,...,255) to keep dropdowns compact.
      for (let v = 0; v <= 255; v += 17) {
        const opt = document.createElement("option");
        opt.value = String(v);
        opt.textContent = `${labelPrefix}${v}`;
        sel.appendChild(opt);
      }
      // Ensure 255 is present (it is with step 17, but keep safe)
      if (sel.options.length === 0 || sel.options[sel.options.length - 1].value !== "255") {
        const opt = document.createElement("option");
        opt.value = "255";
        opt.textContent = `${labelPrefix}255`;
        sel.appendChild(opt);
      }
    }

    function initFgColorControls() {
      const rSel = document.getElementById("fgR");
      const gSel = document.getElementById("fgG");
      const bSel = document.getElementById("fgB");

      populateRgbSelect(rSel, "R ");
      populateRgbSelect(gSel, "G ");
      populateRgbSelect(bSel, "B ");

      const q = readFgRgbFromQuery();
      if (q) { setFgRgb(q.r, q.g, q.b); return; }

      const s = loadFgRgbFromStorage();
      if (s) { setFgRgb(s.r, s.g, s.b); return; }

      // Default: black (matches your previous #000000 feel)
      setFgRgb(0, 0, 0);
    }

    function wireFgColorControls() {
      const rSel = document.getElementById("fgR");
      const gSel = document.getElementById("fgG");
      const bSel = document.getElementById("fgB");

      const onChange = async () => {
        try {
          const { r, g, b } = getFgRgb();
          saveFgRgbToStorage(r, g, b);
          updateFgColorPreview();
          await renderFromTextarea();
        } catch (e) {
          showAlertAndAnnounce(e?.message ?? String(e));
        }
      };

      if (rSel) rSel.addEventListener("change", onChange);
      if (gSel) gSel.addEventListener("change", onChange);
      if (bSel) bSel.addEventListener("change", onChange);
    }

    /* ============================
       Font size selection (remember + query param)
       ============================ */
    const FONT_SIZE_STORAGE_KEY = "tpFontPx";
    const FONT_SIZE_QUERY_PARAM = "fontPx";
    const FONT_SIZE_QUERY_PARAM_ALIAS = "fontSize";
    const FONT_SIZE_ALLOWED = [12,16, 20, 24, 28, 32, 36, 40, 44, 48, 56, 64, 72, 80, 88, 96, 120];

    function clampAllowedFontPx(px) {
      const n = Number(px);
      if (!Number.isFinite(n)) return null;
      const i = Math.round(n);
      if (FONT_SIZE_ALLOWED.includes(i)) return i;
      if (i >= 12 && i <= 220) return i;
      return null;
    }

    function getFontPx() {
      const sel = document.getElementById("fontSizeSel");
      const v = sel ? sel.value : "";
      const px = clampAllowedFontPx(v);
      return px ?? 56;
    }

    function setFontPx(px) {
      const val = clampAllowedFontPx(px) ?? 56;
      const sel = document.getElementById("fontSizeSel");
      if (sel) {
        const exists = Array.from(sel.options).some(o => Number(o.value) === val);
        if (!exists) {
          const opt = document.createElement("option");
          opt.value = String(val);
          opt.textContent = `${val} px`;
          sel.appendChild(opt);
        }
        sel.value = String(val);
      }
      try { localStorage.setItem(FONT_SIZE_STORAGE_KEY, String(val)); } catch {}
      return val;
    }

    function readFontPxFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw = params.get(FONT_SIZE_QUERY_PARAM) ?? params.get(FONT_SIZE_QUERY_PARAM_ALIAS) ?? "";
        const val = clampAllowedFontPx(raw);
        return val;
      } catch {
        return null;
      }
    }

    function loadFontPxFromStorage() {
      try {
        const raw = localStorage.getItem(FONT_SIZE_STORAGE_KEY);
        const val = clampAllowedFontPx(raw);
        return val;
      } catch {
        return null;
      }
    }

    function applyFontPxFromQueryOrStorage() {
      const q = readFontPxFromQuery();
      if (q != null) { setFontPx(q); return; }
      const s = loadFontPxFromStorage();
      if (s != null) setFontPx(s);
      else setFontPx(56);
    }

    function wireFontSizeSelect() {
      const sel = document.getElementById("fontSizeSel");
      if (!sel) return;
      sel.addEventListener("change", async () => {
        try {
          setFontPx(sel.value);
          await renderFromTextarea();
        } catch (e) {
          showAlertAndAnnounce(e?.message ?? String(e));
        }
      });
    }

    const WORD_GAP_PX  = 12;
    const LINE_GAP_PX  = 18;

    const CARTOUCHE_START_CP = 0xF1990;
    const CARTOUCHE_END_CP   = 0xF1991;

    // Long "pi { ... }" container glyphs
    const LONG_PI_START_CP = 0xF1993;   // START OF LONG PI
    const LONG_PI_EXT_CP   = 0xF1994;   // COMBINING LONG PI EXTENSION

    function tokenHasOpenCurly(tok) {
      return String(tok ?? "").includes("{");
    }

    function tokenHasCloseCurly(tok) {
      return String(tok ?? "").includes("}");
    }

    function extractCurlyContentFromTokens(tokens, startIdx) {
      let j = startIdx;
      while (j < tokens.length && !tokenHasCloseCurly(tokens[j])) j++;
      if (j >= tokens.length) return null; // no closing brace

      const joined = tokens.slice(startIdx, j + 1).join(" ");
      const open = joined.indexOf("{");
      const close = joined.lastIndexOf("}");
      if (open < 0 || close < 0 || close <= open) return null;

      const inner = joined.slice(open + 1, close).trim();
      return { inner, endIndex: j };
    }

    function parseKnownTpWords(innerText) {
      // ignore spaces; accept only known TP words (letters only)
      const raw = String(innerText ?? "");
      const parts = raw.split(/\s+/).map(normalizeTpWord).filter(Boolean);
      const known = parts.filter(w => isKnownTpWord(w));
      return known;
    }

    async function ensureFontLoaded() {
      if (!document.fonts || !document.fonts.load || !document.fonts.check) return;

      const sampleTextChar = String.fromCodePoint(0xF196C);
      const sampleCartChar = String.fromCodePoint(0xF1990);

      try {
        await document.fonts.load(`24px "${FONT_FAMILY_TEXT}"`, sampleTextChar);
        await document.fonts.load(`24px "${FONT_FAMILY_CARTOUCHE}"`, sampleCartChar);
        await document.fonts.ready;
      } catch (e) {
        console.warn("[font] load threw error:", e);
      }
    }

    /* ============================
       Remember Traditional/Uniform + query param
       ============================ */
    const NL_MODE_STORAGE_KEY = "nlMode";
    const NL_MODE_QUERY_PARAM = "nlMode";
    const NL_MODE_QUERY_PARAM_ALIAS = "cartoucheDisplay";

    function getNanpaLinjanMode() {
      const el = document.querySelector('input[name="nlMode"]:checked');
      return (el && (el.value === "uniform" || el.value === "traditional")) ? el.value : "traditional";
    }

    function setNanpaLinjanMode(mode) {
      const v = (mode === "uniform") ? "uniform" : "traditional";
      const target = document.querySelector(`input[name="nlMode"][value="${v}"]`);
      if (target) target.checked = true;
      try { localStorage.setItem(NL_MODE_STORAGE_KEY, v); } catch {}
    }

    function loadNanpaLinjanModeFromStorage() {
      try {
        const v = localStorage.getItem(NL_MODE_STORAGE_KEY);
        if (v === "uniform" || v === "traditional") setNanpaLinjanMode(v);
      } catch {}
    }

    function readNanpaLinjanModeFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw =
          params.get(NL_MODE_QUERY_PARAM) ??
          params.get(NL_MODE_QUERY_PARAM_ALIAS) ??
          "";
        const v = String(raw).toLowerCase().trim();
        if (v === "uniform" || v === "traditional") return v;
      } catch {}
      return null;
    }

    function applyNanpaLinjanModeFromQueryOrStorage() {
      const q = readNanpaLinjanModeFromQuery();
      if (q) { setNanpaLinjanMode(q); return; }
      loadNanpaLinjanModeFromStorage();
    }

    function wireNanpaLinjanModeRadios() {
      const radios = document.querySelectorAll('input[name="nlMode"]');
      radios.forEach(r => {
        r.addEventListener("change", async () => {
          try {
            setNanpaLinjanMode(getNanpaLinjanMode());
            await renderFromTextarea();
          } catch (e) {
            showAlertAndAnnounce(e?.message ?? String(e));
          }
        });
      });
    }

    /* ============================
       Optional default input from query param (not remembered)
       ============================ */
    const INPUT_TEXT_QUERY_PARAM = "text";
    const INPUT_TEXT_QUERY_PARAM_ALIAS = "input";

    function readDefaultInputFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search || "");
        const raw = params.get(INPUT_TEXT_QUERY_PARAM) ?? params.get(INPUT_TEXT_QUERY_PARAM_ALIAS);
        if (raw == null) return null;

        const s = String(raw);
        if (!s.trim()) return null;

        return s.replace(/\\n/g, "\n");
      } catch {
        return null;
      }
    }

    function applyDefaultInputFromQuery() {
      const s = readDefaultInputFromQuery();
      if (s == null) return;
      if (elTextIn) elTextIn.value = s;
    }

    /* ============================
       Word → UCSUR map
       ============================ */
    const WORD_TO_UCSUR_CP = {
      "a": 0xF1900, "akesi": 0xF1901, "ala": 0xF1902, "alasa": 0xF1903,
      "ale": 0xF1904, "ali": 0xF1904, "anpa": 0xF1905, "ante": 0xF1906, "anu": 0xF1907,
      "awen": 0xF1908, "e": 0xF1909, "en": 0xF190A, "esun": 0xF190B, "ijo": 0xF190C,
      "ike": 0xF190D, "ilo": 0xF190E, "insa": 0xF190F, "jaki": 0xF1910, "jan": 0xF1911,
      "jelo": 0xF1912, "jo": 0xF1913, "kala": 0xF1914, "kalama": 0xF1915, "kama": 0xF1916,
      "kasi": 0xF1917, "ken": 0xF1918, "kepeken": 0xF1919, "kili": 0xF191A, "kiwen": 0xF191B,
      "ko": 0xF191C, "kon": 0xF191D, "kule": 0xF191E, "kulupu": 0xF191F, "kute": 0xF1920,
      "la": 0xF1921, "lape": 0xF1922, "laso": 0xF1923, "lawa": 0xF1924, "len": 0xF1925,
      "lete": 0xF1926, "li": 0xF1927, "lili": 0xF1928, "linja": 0xF1929, "lipu": 0xF192A,
      "loje": 0xF192B, "lon": 0xF192C, "luka": 0xF192D, "lukin": 0xF192E, "lupa": 0xF192F,
      "ma": 0xF1930, "mama": 0xF1931, "mani": 0xF1932, "meli": 0xF1933, "mi": 0xF1934,
      "mije": 0xF1935, "moku": 0xF1936, "moli": 0xF1937, "monsi": 0xF1938, "mu": 0xF1939,
      "mun": 0xF193A, "musi": 0xF193B, "mute": 0xF193C, "nanpa": 0xF193D, "nasa": 0xF193E,
      "nasin": 0xF193F, "nena": 0xF1940, "ni": 0xF1941, "nimi": 0xF1942, "noka": 0xF1943,
      "o": 0xF1944, "olin": 0xF1945, "ona": 0xF1946, "open": 0xF1947, "pakala": 0xF1948,
      "pali": 0xF1949, "palisa": 0xF194A, "pan": 0xF194B, "pana": 0xF194C, "pi": 0xF194D,
      "pilin": 0xF194E, "pimeja": 0xF194F, "pini": 0xF1950, "pipi": 0xF1951, "poka": 0xF1952,
      "poki": 0xF1953, "pona": 0xF1954, "pu": 0xF1955, "sama": 0xF1956, "seli": 0xF1957,
      "selo": 0xF1958, "seme": 0xF1959, "sewi": 0xF195A, "sijelo":0xF195B, "sike": 0xF195C, "sin": 0xF195D,
      "sina": 0xF195E, "sinpin": 0xF195F, "sitelen": 0xF1960, "sona": 0xF1961, "soweli": 0xF1962,
      "suli": 0xF1963, "suno": 0xF1964, "supa": 0xF1965, "suwi": 0xF1966, "tan": 0xF1967,
      "taso": 0xF1968, "tawa": 0xF1969, "telo": 0xF196A, "tenpo": 0xF196B, "toki": 0xF196C,
      "tomo": 0xF196D, "tu": 0xF196E, "unpa": 0xF196F, "uta": 0xF1970, "utala": 0xF1971,
      "walo": 0xF1972, "wan": 0xF1973, "waso": 0xF1974, "wawa": 0xF1975, "weka": 0xF1976,
      "wile": 0xF1977, "namako": 0xF1978, "kin": 0xF1979, "oko": 0xF197A, "kipisi": 0xF197B,
      "leko": 0xF197C, "monsuta": 0xF197D, "tonsi": 0xF197E, "jasima": 0xF197F,
      "kijetesantakalu": 0xF1980, "soko": 0xF1981, "meso": 0xF1982, "epiku": 0xF1983,
      "kokosila": 0xF1984, "lanpan": 0xF1985, "n": 0xF1986, "misikeke": 0xF1987, "ku": 0xF1988,
      "pake": 0xF19A0, "apeja": 0xF19A1, "majuna": 0xF19A2, "powe": 0xF19A3,
      "·": 0xF199C, ":": 0xF199D,
      "ota": 0xF199C, "kolon": 0xF199D
    };

    function isKnownTpWord(w) { return WORD_TO_UCSUR_CP[w] != null; }

    // Letters-only normalization (used by number-phrase parsing etc.)
    function normalizeTpWord(raw) { return String(raw ?? "").toLowerCase().replace(/[^a-z]/g, ""); }

    // NEW: glyph-token normalization that preserves ":" and "·" and also handles trailing punctuation
    function normalizeTpGlyphToken(raw) {
      const s0 = String(raw ?? "").trim().toLowerCase();
      if (!s0) return "";
      if (s0 === ":" || s0 === "·") return s0;

      const stripped = s0.replace(/^[^a-z:·]+|[^a-z:·]+$/g, "");
      if (!stripped) return "";
      if (stripped === ":" || stripped === "·") return stripped;

      return stripped.replace(/[^a-z]/g, "");
    }

    function isKnownTpGlyphToken(t) { return WORD_TO_UCSUR_CP[t] != null; }

    /* ============================
       Nanpa-linja-n mappings
       ============================ */
    const NANPA_LINJA_N_WORD_TO_CP = {
      "nanpa": 0xF193D,
      "nasa":  0xF193E,
      "nasin": 0xF193F,
      "nena":  0xF1940,
      "ni":    0xF1941,
      "nimi":  0xF1942,
      "noka":  0xF1943,

      "esun":  0xF190B,
      "en":    0xF190A,
      "e":     0xF1909,

      "o":     0xF1944,
      "ona":   0xF1946,

      "kulupu":0xF191F,

      "ijo":   0xF190C,
      "wan":   0xF1973,
      "tu":    0xF196E,
      "seli":  0xF1957,
      "awen":  0xF1908,
      "luka":  0xF192D,
      "utala": 0xF1971,
      "mun":   0xF193A,
      "pipi":  0xF1951,
      "jo":    0xF1913
    };

    const CP_NANPA = NANPA_LINJA_N_WORD_TO_CP["nanpa"];
    const CP_NENA  = NANPA_LINJA_N_WORD_TO_CP["nena"];
    const CP_EN    = NANPA_LINJA_N_WORD_TO_CP["en"];

    const UNIFORM_TO_NENA = new Set([
      NANPA_LINJA_N_WORD_TO_CP["nasa"],
      NANPA_LINJA_N_WORD_TO_CP["nasin"],
      NANPA_LINJA_N_WORD_TO_CP["ni"],
      NANPA_LINJA_N_WORD_TO_CP["nimi"],
      NANPA_LINJA_N_WORD_TO_CP["noka"],
      NANPA_LINJA_N_WORD_TO_CP["nena"]
    ]);

    const UNIFORM_TO_EN = new Set([
      NANPA_LINJA_N_WORD_TO_CP["e"],
      NANPA_LINJA_N_WORD_TO_CP["en"],
      NANPA_LINJA_N_WORD_TO_CP["esun"]
    ]);

    function uniformizeNanpaLinjanCartoucheCps(cps) {
      const a = Array.from(cps ?? []);
      if (a.length === 0) return a;

      for (let i = 0; i < a.length; i++) {
        const cp = a[i];

        if (cp === CP_NANPA) {
          if (i !== 0 && i !== a.length - 1) a[i] = CP_NENA;
          continue;
        }
        if (UNIFORM_TO_NENA.has(cp)) { a[i] = CP_NENA; continue; }
        if (UNIFORM_TO_EN.has(cp))   { a[i] = CP_EN; continue; }
      }
      return a;
    }

    const DIGIT_TOKENS = new Set(["NI","WE","TE","SE","NA","LE","NU","ME","PE","JE"]);
    const TOKEN_PREFIXES = ["KEKEKE","KEKE","KE","NONONO","NONO","NE","NO"];

    function nanpaCapsHasAtLeastOneDigitToken(tokens) {
      for (const t of (tokens ?? [])) {
        if (DIGIT_TOKENS.has(t)) return true;
      }
      return false;
    }

    function tokenizeNanpaCaps(caps) {
      if (caps == null) throw new Error("caps must be a string");
      const s = String(caps).trim().toUpperCase();
      if (!s) throw new Error("caps is empty");
      if (!s.endsWith("N")) throw new Error("nanpa-caps must end with final terminator 'N'");
      if (!s.startsWith("NE")) throw new Error("nanpa-caps must start with 'NE'");

      const tokens = [];
      let i = 0;
      const end = s.length;

      while (i < end - 1) {
        let matched = null;
        for (const pref of TOKEN_PREFIXES) {
          if (s.startsWith(pref, i)) { matched = pref; break; }
        }
        if (matched != null) { tokens.push(matched); i += matched.length; continue; }

        if (i + 2 <= end - 1) {
          const two = s.slice(i, i + 2);
          if (DIGIT_TOKENS.has(two)) { tokens.push(two); i += 2; continue; }
        }

        throw new Error(`Invalid tokenization at position ${i} in caps string "${caps}"`);
      }

      tokens.push("N");
      return tokens;
    }

    function isValidNanpaLinjanProperName(raw) {
      const s = String(raw ?? "").replace(/\s+/g, "");
      if (!s) return false;
      if (!/^[a-zA-Z]+$/.test(s)) return false;
      if (!/[nN]$/.test(s)) return false;

      const core = s.slice(0, -1);
      if (core.length < 2 || (core.length % 2) !== 0) return false;

      const caps = core.toUpperCase() + "N";
      if (!caps.startsWith("NE")) return false;

      try { tokenizeNanpaCaps(caps); return true; }
      catch { return false; }
    }

    const NUMBER_CODE_LETTER_TO_PAIR = {
      "I":"NI","W":"WE","T":"TE","S":"SE","A":"NA",
      "L":"LE","U":"NU","M":"ME","P":"PE","J":"JE"
    };

    function normalizeNumberCodeInput(raw) {
      return String(raw ?? "").trim().replace(/\s+/g, "");
    }

    function tryParseNanpaLinjanNumberCodeToCaps(raw) {
      const s0 = normalizeNumberCodeInput(raw);
      if (!s0) return null;
      if (!s0.toUpperCase().startsWith("#~")) return null;

      const body = s0.slice(2).toUpperCase();
      if (!body) throw new Error("Number code '#~' must have letters after it.");
      if (!/^[A-Z]+$/.test(body)) throw new Error("Number code may only contain letters A–Z after '#~'.");

      const tokens = ["NE"];
      let i = 0;

      function ensureNEBeforeOperatorRun() {
        if (tokens[tokens.length - 1] !== "NE") tokens.push("NE");
      }

      while (i < body.length) {
        const ch = body[i];

        if (ch === "O") {
          let j = i;
          while (j < body.length && body[j] === "O") j++;
          const count = j - i;
          if (count < 1 || count > 3) throw new Error("Invalid run of 'O' in number code (max 3).");

          if (count === 1) {
            if (i === 0) tokens.push("NO");
            else tokens.push("NO","NE");
          } else {
            tokens.push("NO".repeat(count)); // NONO / NONONO
          }

          i = j;
          continue;
        }

        if (ch === "K") {
          let j = i;
          while (j < body.length && body[j] === "K") j++;
          const count = j - i;
          if (count < 1 || count > 3) throw new Error("Invalid run of 'K' in number code (max 3).");

          ensureNEBeforeOperatorRun();
          tokens.push("KE".repeat(count)); // KE / KEKE / KEKEKE
          i = j;
          continue;
        }

        const pair = NUMBER_CODE_LETTER_TO_PAIR[ch];
        if (!pair) throw new Error(`Invalid letter '${ch}' in number code.`);
        tokens.push(pair);
        i += 1;
      }

      tokens.push("N");

      const caps = tokens.join("");
      tokenizeNanpaCaps(caps);
      return { caps };
    }

    const TOKEN_TO_DIGIT_WORD = {
      "NI":"ijo","WE":"wan","TE":"tu","SE":"seli","NA":"awen",
      "LE":"luka","NU":"utala","ME":"mun","PE":"pipi","JE":"jo"
    };

    function nanpaCapsTokensToTpWords(tokens) {
      const out = [];
      let afterStartingNe = false;

      for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];

        if (t === "NE") {
          if (out.length === 0) { out.push("nanpa","esun"); afterStartingNe = true; }
          else { out.push("nasa","e"); afterStartingNe = false; }
          continue;
        }

        if (DIGIT_TOKENS.has(t)) {
          const dw = TOKEN_TO_DIGIT_WORD[t];
          if (t === "NI" || t === "NA" || t === "NU") out.push("nasa", dw);
          else out.push(dw, "esun");
          afterStartingNe = false;
          continue;
        }

        if (t === "NO") {
          const nxt = (i + 1 < tokens.length) ? tokens[i + 1] : null;

          if (nxt === "NE") {
            out.push("ni","o","nasa","e");
            afterStartingNe = false;
            i += 1;
            continue;
          }

          out.push("ni","o");
          afterStartingNe = false;
          continue;
        }

        if (t === "NONO") { out.push("nena","o","nena","o"); afterStartingNe=false; continue; }
        if (t === "NONONO") { out.push("nasa","o","nasa","o","nasa","o"); afterStartingNe=false; continue; }

        if (t === "KE") { out.push("kulupu","e"); afterStartingNe=false; continue; }
        if (t === "KEKE") { out.push("kulupu","e","kulupu","e"); afterStartingNe=false; continue; }
        if (t === "KEKEKE") { out.push("kulupu","e","kulupu","e","kulupu","e"); afterStartingNe=false; continue; }

        if (t === "N") { out.push("nanpa"); afterStartingNe=false; continue; }

        throw new Error(`Unknown token "${t}"`);
      }

      return out;
    }

    function nanpaCapsToNanpaLinjanCodepoints(caps, { mode = "traditional" } = {}) {
      const tokens = tokenizeNanpaCaps(caps);

      if (!nanpaCapsHasAtLeastOneDigitToken(tokens)) return null;

      const tpWords = nanpaCapsTokensToTpWords(tokens);

      const cps = [];
      for (const w of tpWords) {
        const cp = NANPA_LINJA_N_WORD_TO_CP[w];
        if (cp == null) return null;
        cps.push(cp);
      }

      if (mode === "uniform") return uniformizeNanpaLinjanCartoucheCps(cps);
      return cps;
    }

    function tryDecodeNanpaLinjanIdentifierToCodepoints(rawText, { mode = "traditional" } = {}) {
      const s = String(rawText ?? "").trim();
      if (!s) return null;

      try {
        const parsed = tryParseNanpaLinjanNumberCodeToCaps(s);
        if (parsed?.caps) return nanpaCapsToNanpaLinjanCodepoints(parsed.caps, { mode });
      } catch {
        return null;
      }

      if (!isValidNanpaLinjanProperName(s)) return null;

      const compact = s.replace(/\s+/g, "");
      const core = compact.slice(0, -1);
      const caps = core.toUpperCase() + "N";
      return nanpaCapsToNanpaLinjanCodepoints(caps, { mode });
    }

    /* ============================================================
       Decimal recognizer + caps encoder
       ============================================================ */
    const VULGAR_FRACTIONS = new Map([
      ["¼", [1, 4]], ["½", [1, 2]], ["¾", [3, 4]],
      ["⅐", [1, 7]], ["⅑", [1, 9]], ["⅒", [1, 10]],
      ["⅓", [1, 3]], ["⅔", [2, 3]],
      ["⅕", [1, 5]], ["⅖", [2, 5]], ["⅗", [3, 5]], ["⅘", [4, 5]],
      ["⅙", [1, 6]], ["⅚", [5, 6]],
      ["⅛", [1, 8]], ["⅜", [3, 8]], ["⅝", [5, 8]], ["⅞", [7, 8]],
      ["↉", [0, 3]],
    ]);

    function normalizeVulgarFractionInput(raw) {
      if (raw == null) return "";
      let s = String(raw).trim();
      if (!s) return s;

      s = s.replace(/\u2044/g, "/");

      let found = null;
      for (const ch of s) {
        if (VULGAR_FRACTIONS.has(ch)) { found = ch; break; }
      }
      if (!found) return s;

      const lastChar = s.slice(-1);
      if (!VULGAR_FRACTIONS.has(lastChar)) {
        throw new Error("Vulgar fraction characters must appear at the end (e.g., 9¾ or ¾).");
      }

      if (s.slice(1).includes("-")) {
        throw new Error("Only one negative sign is allowed, and it must be at the start.");
      }

      const [num, den] = VULGAR_FRACTIONS.get(lastChar);
      const prefixRaw = s.slice(0, -1).trim();

      if (!prefixRaw) return `${num}/${den}`;

      const isNeg = prefixRaw.startsWith("-");
      const prefix = isNeg ? prefixRaw.slice(1).trim() : prefixRaw;

      if (!prefix) return `-${num}/${den}`;

      return isNeg ? `-${prefix}+${num}/${den}` : `${prefix}+${num}/${den}`;
    }

    function looksLikeNanpaCaps(s) {
      if (!s) return false;
      const t = String(s).trim();
      if (!t) return false;
      if (!/^[A-Za-z]+[Nn]$/.test(t)) return false;
      return t.slice(0, 2).toUpperCase() === "NE";
    }

    function groupFractionDigitsOnly(s, decimalChar=".", groupSize=3, sepChar="_") {
      const str = String(s);
      const idx = str.indexOf(decimalChar);
      if (idx < 0) return str;

      const left = str.slice(0, idx);
      const right = str.slice(idx + 1);

      let i = 0;
      while (i < right.length && /[0-9]/.test(right[i])) i++;
      const fracDigits = right.slice(0, i);
      const suffix = right.slice(i);

      if (fracDigits.length <= groupSize) return str;
      if (sepChar && fracDigits.includes(sepChar)) return str;

      const groups = [];
      for (let j = 0; j < fracDigits.length; j += groupSize) {
        groups.push(fracDigits.slice(j, j + groupSize));
      }
      return `${left}${decimalChar}${groups.join(sepChar)}${suffix}`;
    }

    function normalizeLooseSeparators(raw) {
      if (raw == null) return "";
      let s = String(raw);

      s = s.replace(/[−‒–—]/g, "-");

      const isNeg = s.startsWith("-");
      const head = isNeg ? "-" : "";
      const rest = isNeg ? s.slice(1) : s;

      let r = rest.replace(/\s+/g, " ");
      r = r.replace(/-+/g, "-");

      return (head + r).trim();
    }

    const DEC_DIGIT_TO_TOKEN = {
      "0": "NI", "1": "WE", "2": "TE", "3": "SE", "4": "NA",
      "5": "LE", "6": "NU", "7": "ME", "8": "PE", "9": "JE",
    };

    function numberStrToNanpaCaps(
      s,
      { thousandsChar = ",", groupFractionTriplets = true, fractionGroupSize = 3 } = {}
    ) {
      if (s == null) throw new Error("s must be a string");
      let raw = normalizeLooseSeparators(String(s));
      if (!raw) throw new Error("Empty value cannot be encoded");

      if (groupFractionTriplets) {
        raw = groupFractionDigitsOnly(raw, ".", fractionGroupSize, "_");
      }

      function stripFinalTerminator(segCaps) {
        if (!segCaps) return segCaps;
        if (!segCaps.endsWith("N")) throw new Error(`Segment caps did not end with 'N': ${segCaps}`);
        return segCaps.slice(0, -1);
      }

      function encodeSingleNumberSegment(segment, includeInitialNe) {
        let seg = String(segment).trim();
        if (seg === "") throw new Error(`Empty numeric segment in ${s}`);

        if (seg.slice(0, 1).toUpperCase() === "N") {
          seg = seg.slice(1).trim();
          if (seg === "") throw new Error(`Missing numeric part after leading 'N' prefix in ${s}`);
        }

        const out = [];
        if (includeInitialNe) out.push("NE");

        function pushNene() {
          const L = out.length;
          if (L >= 2 && out[L-2] === "NE" && out[L-1] === "NE") return;
          out.push("NE", "NE");
        }

        if (seg.startsWith("-")) {
          if (seg.startsWith("-.")) seg = "-0." + seg.slice(2);
          out.push("NO");
          seg = seg.slice(1).trim();
        }

        let magnitudeSuffixKeCount = 0;
        if (seg.length > 0) {
          const last = seg.slice(-1).toUpperCase();
          if (last === "K" || last === "T" || last === "M" || last === "B") {
            magnitudeSuffixKeCount =
              (last === "K" || last === "T") ? 1 :
              (last === "M") ? 2 : 3;
            seg = seg.slice(0, -1).trim();
            if (!seg) throw new Error(`Missing numeric part before magnitude suffix ${last} in ${s}`);
          }
        }

        if ((seg.match(/\./g) || []).length > 1) {
          throw new Error(`Invalid numeric segment with multiple decimals: ${segment}`);
        }

        let intPart = seg;
        let fracPart = "";
        let hasDecimal = false;
        if (seg.includes(".")) {
          [intPart, fracPart] = seg.split(".", 2);
          hasDecimal = true;
        }

        let ip = String(intPart ?? "").trim();
        if (ip === "") ip = "0";

        const intHasThousandsComma = (thousandsChar && ip.includes(thousandsChar));
        const hasLooseSep = /[ -]/.test(ip);

        if (hasLooseSep) {
          let ip2 = String(ip)
            .replace(/\s+/g, " ")
            .replace(/-+/g, "-")
            .trim();

          ip2 = ip2.replace(/^[ -]+/, "").replace(/[ -]+$/, "");
          if (ip2 === "") ip2 = "0";

          for (const ch of ip2) {
            if (/\d/.test(ch)) { out.push(DEC_DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            if (thousandsChar && ch === thousandsChar) { out.push("NE","KE"); continue; }
            throw new Error(`Unsupported character "${ch}" in integer part of "${s}"`);
          }
        } else {
          const groups = thousandsChar ? ip.split(thousandsChar) : [ip];
          for (const g of groups) {
            if (g === "" || !/^\d+$/.test(g)) throw new Error(`Invalid integer group "${g}" in "${s}"`);
          }

          let trailingZeroGroups = 0;
          for (let k = groups.length - 1; k >= 1; k--) {
            const g = groups[k];
            if (g.length === 3 && g === "000") trailingZeroGroups += 1;
            else break;
          }

          for (const d of groups[0]) out.push(DEC_DIGIT_TO_TOKEN[d]);

          const nGroups = groups.length;
          const lastNonTrailingIdx = nGroups - trailingZeroGroups;

          for (let idx = 1; idx < lastNonTrailingIdx; idx++) {
            out.push("NE","KE");
            for (const d of groups[idx]) out.push(DEC_DIGIT_TO_TOKEN[d]);
          }

          if (trailingZeroGroups > 0) {
            out.push("NE");
            let remaining = trailingZeroGroups;
            while (remaining > 0) {
              const chunk = Math.min(3, remaining);
              if (out[out.length - 1] !== "NE") out.push("NE");
              out.push("KE".repeat(chunk));
              remaining -= chunk;
              if (remaining > 0) out.push("NE");
            }
          }
        }

        if (hasDecimal) {
          if (intHasThousandsComma) out.push("NO");
          else out.push("NO","NE");

          if (!fracPart) throw new Error(`Missing fraction digits after '.' in "${s}"`);

          for (const ch of fracPart) {
            if (/\d/.test(ch)) { out.push(DEC_DIGIT_TO_TOKEN[ch]); continue; }
            if (ch === "_") { pushNene(); continue; }
            if (ch === ",") { pushNene(); continue; }
            if (ch === " " || ch === "-") { pushNene(); continue; }
            throw new Error(`Unsupported character "${ch}" in fraction part of "${s}"`);
          }
        }

        if (magnitudeSuffixKeCount > 0) {
          out.push("NE");
          let remaining = magnitudeSuffixKeCount;
          while (remaining > 0) {
            const chunk = Math.min(3, remaining);
            if (out[out.length - 1] !== "NE") out.push("NE");
            out.push("KE".repeat(chunk));
            remaining -= chunk;
            if (remaining > 0) out.push("NE");
          }
        }

        out.push("N");
        return out.join("");
      }

      if (raw.includes("+")) {
        const [left, right] = raw.split("+", 2);
        let leftCaps = encodeSingleNumberSegment(left, true);

        if (!right.includes("/")) throw new Error(`Mixed number must contain '/' after '+': ${s}`);
        const [num, den] = right.split("/", 2);

        let numCaps = encodeSingleNumberSegment(num, false);
        let denCaps = encodeSingleNumberSegment(den, false);

        leftCaps = stripFinalTerminator(leftCaps);
        numCaps = stripFinalTerminator(numCaps);

        return leftCaps + "NONONO" + numCaps + "NONO" + denCaps;
      }

      if (raw.includes("/")) {
        const [num, den] = raw.split("/", 2);
        let numCaps = encodeSingleNumberSegment(num, true);
        let denCaps = encodeSingleNumberSegment(den, false);
        numCaps = stripFinalTerminator(numCaps);
        return numCaps + "NONO" + denCaps;
      }

      return encodeSingleNumberSegment(raw, true);
    }

    function decimalStringToCaps(rawDecimal, opts = {}) {
      const normalized = normalizeVulgarFractionInput(rawDecimal);
      const caps = looksLikeNanpaCaps(normalized)
        ? normalized.toUpperCase()
        : numberStrToNanpaCaps(normalized, opts);

      tokenizeNanpaCaps(caps);
      return caps;
    }

    function findDecimalSequencesWithCaps(text, opts = {}) {
      const original = String(text ?? "");
      if (!original) return [];

      const s = original.replace(/[−‒–—]/g, "-");

      const vulgarChars = "¼½¾⅐⅑⅒⅓⅔⅕⅖⅗⅘⅙⅚⅛⅜⅝⅞↉";
      const re = new RegExp(
        String.raw`(?<![A-Za-z])` +
        String.raw`(` +
          String.raw`-?\s*\d*\s*[${vulgarChars}]` +
          "|" +
          String.raw`-?\s*\d[\d, _-]*\s*\+\s*\d[\d, _-]*\s*\/\s*\d[\d, _-]*` +
          "|" +
          String.raw`-?\s*\d[\d, _-]*\s*\/\s*\d[\d, _-]*` +
          "|" +
          String.raw`-?\s*(?:\d[\d, _-]*|\.\d+)(?:\.\d[\d, _-]*)?(?:\s*[kKtTmMbB])?` +
        String.raw`)` +
        String.raw`(?![A-Za-z])`,
        "g"
      );

      const results = [];
      let m;

      while ((m = re.exec(s)) !== null) {
        const rawMatch = m[1];
        if (!rawMatch) continue;

        let candidate = rawMatch.trim().replace(/[)\]}.,;:!?]+$/g, "").trim();
        if (!candidate) continue;
        if (candidate === "-" || candidate === "+") continue;

        const rel = rawMatch.indexOf(candidate);
        const start = (rel >= 0) ? (m.index + rel) : m.index;
        const end = start + candidate.length;

        try {
          const caps = decimalStringToCaps(candidate, {
            thousandsChar: ",",
            groupFractionTriplets: true,
            fractionGroupSize: 3,
            ...opts,
          });

          results.push({ kind: "decimal", match: candidate, index: start, end, caps });
        } catch {
          // ignore
        }
      }

      results.sort((a, b) => a.index - b.index || b.end - a.end);
      const filtered = [];
      let lastEnd = -1;
      for (const r of results) {
        if (r.index < lastEnd) continue;
        filtered.push(r);
        lastEnd = r.end;
      }
      return filtered;
    }

    /* ============================================================
       #~ code and proper-name scanners
       ============================================================ */
    function findNumberCodeSequencesWithCaps(text) {
      const s = String(text ?? "");
      if (!s) return [];

      const re = /#~[A-Za-z]+/g;
      const out = [];
      let m;

      while ((m = re.exec(s)) !== null) {
        const raw = m[0];
        if (!raw) continue;

        const start = m.index | 0;
        const end = start + raw.length;

        try {
          const parsed = tryParseNanpaLinjanNumberCodeToCaps(raw);
          if (parsed?.caps) out.push({ kind: "code", index: start, end, caps: parsed.caps });
        } catch {
          // ignore invalid codes
        }
      }

      return out;
    }

    function findNanpaLinjanProperNameSequencesWithCaps(text) {
      const s = String(text ?? "");
      if (!s) return [];

      const re = /(^|[^A-Za-z])((?:ne)[A-Za-z]*(?:\s+[A-Za-z]{2,}){0,20}[A-Za-z]*[nN])(?![A-Za-z])/gi;

      const hits = [];
      let m;

      while ((m = re.exec(s)) !== null) {
        const lead = m[1] ?? "";
        const rawMatch = m[2] ?? "";
        if (!rawMatch) continue;

        const start = (m.index | 0) + lead.length;
        const end = start + rawMatch.length;

        const compact = rawMatch.replace(/\s+/g, "");
        if (compact.length < 5) continue;
        if (!isValidNanpaLinjanProperName(compact)) continue;

        const core = compact.slice(0, -1);
        const caps = core.toUpperCase() + "N";

        hits.push({ kind: "name", index: start, end, caps });
      }

      return hits;
    }

    /* ============================================================
       ADD: nanpa-linja-n TP number-phrase scanner in plain text
       ============================================================ */
    function findNanpaLinjanTpPhraseSequences(text) {
      const s = String(text ?? "");
      if (!s) return [];

      const tokens = [];
      const reTok = /\S+/g;
      let m;
      while ((m = reTok.exec(s)) !== null) {
        const raw = m[0];
        tokens.push({
          raw,
          norm: normalizeTpWord(raw),
          start: m.index,
          end: (m.index + raw.length)
        });
      }
      if (tokens.length < 3) return [];

      const digitWords = new Set(
        Object.values(TOKEN_TO_DIGIT_WORD).filter(w => NANPA_LINJA_N_WORD_TO_CP[w] != null)
      );

      const hits = [];
      for (let i = 0; i < tokens.length - 2; i++) {
        if (tokens[i].norm !== "nanpa") continue;
        const n1 = tokens[i + 1]?.norm;
        if (!(n1 === "esun" || n1 === "en")) continue;

        let bestJ = -1;
        let bestWords = null;

        for (let j = i + 2; j < tokens.length; j++) {
          if (tokens[j].norm !== "nanpa") continue;

          const words = [];
          let allOk = true;
          let hasDigit = false;

          for (let k = i; k <= j; k++) {
            const w = tokens[k].norm;
            if (!w) { allOk = false; break; }
            if (NANPA_LINJA_N_WORD_TO_CP[w] == null) { allOk = false; break; }
            if (k >= i + 2 && k <= j - 1 && digitWords.has(w)) hasDigit = true;
            words.push(w);
          }

          if (!allOk || !hasDigit) continue;

          bestJ = j;
          bestWords = words;
        }

        if (bestJ >= 0 && bestWords) {
          hits.push({
            kind: "tpPhrase",
            index: tokens[i].start,
            end: tokens[bestJ].end,
            words: bestWords
          });
          i = bestJ;
        }
      }

      return hits;
    }

    function mergeAndGreedyFilterHits(allHits) {
      const hits = Array.from(allHits ?? []).filter(h =>
        h &&
        Number.isFinite(h.index) &&
        Number.isFinite(h.end) &&
        h.end > h.index &&
        (h.caps || (Array.isArray(h.words) && h.words.length > 0))
      );

      function priority(kind) {
        if (kind === "decimal") return 4;
        if (kind === "tpPhrase") return 3;
        if (kind === "code") return 2;
        return 1;
      }

      hits.sort((a, b) => {
        if (a.index !== b.index) return a.index - b.index;
        const la = (a.end - a.index);
        const lb = (b.end - b.index);
        if (la !== lb) return lb - la;
        return priority(b.kind) - priority(a.kind);
      });

      const out = [];
      let lastEnd = -1;

      for (const h of hits) {
        if (h.index < lastEnd) continue;
        out.push(h);
        lastEnd = h.end;
      }

      return out;
    }

    /* ============================
       TP phrase helpers
       ============================ */
    function tryParseNanpaLinjanTpPhraseWords(inputWords) {
      const words = Array.from(inputWords ?? []).map(normalizeTpWord).filter(Boolean);

      if (words.length < 3) return null;
      if (words[0] !== "nanpa") return null;
      if (!(words[1] === "esun" || words[1] === "en")) return null;
      if (words[words.length - 1] !== "nanpa") return null;

      for (const w of words) {
        if (NANPA_LINJA_N_WORD_TO_CP[w] == null) return null;
      }

      const digitWords = new Set(
        Object.values(TOKEN_TO_DIGIT_WORD).filter(w => NANPA_LINJA_N_WORD_TO_CP[w] != null)
      );

      const payload = words.slice(2, -1);
      const hasDigit = payload.some(w => digitWords.has(w));
      if (!hasDigit) return null;

      return { words };
    }

    function nanpaLinjanWordsToCodepoints(words, { mode = "traditional" } = {}) {
      const cps = [];
      for (const w0 of (words ?? [])) {
        const w = normalizeTpWord(w0);
        const cp = NANPA_LINJA_N_WORD_TO_CP[w];
        if (cp == null) return null;
        cps.push(cp);
      }
      if (mode === "uniform") return uniformizeNanpaLinjanCartoucheCps(cps);
      return cps;
    }

    function tpWordsToCodepoints(wordsOrTokens) {
      const cps = [];
      for (const w of (wordsOrTokens ?? [])) {
        const cp = WORD_TO_UCSUR_CP[w];
        if (cp != null) cps.push(cp);
      }
      return cps;
    }

    function setTextQuality(ctx) {
      try { ctx.textRendering = "optimizeLegibility"; } catch (_) {}
      try { ctx.fontKerning = "normal"; } catch (_) {}
    }

    /* ============================
       Random letters → glyphs
       ============================ */
    function buildLetterBuckets() {
      const buckets = new Map();
      for (const w of Object.keys(WORD_TO_UCSUR_CP)) {
        const k = String(w);
        if (!k) continue;
        const first = k[0].toLowerCase();
        if (!/^[a-z]$/.test(first)) continue;
        if (!buckets.has(first)) buckets.set(first, []);
        buckets.get(first).push(k);
      }
      return buckets;
    }
    const LETTER_BUCKETS = buildLetterBuckets();

    function randInt(n) {
      if (n <= 0) return 0;
      if (globalThis.crypto && typeof globalThis.crypto.getRandomValues === "function") {
        const buf = new Uint32Array(1);
        globalThis.crypto.getRandomValues(buf);
        return buf[0] % n;
      }
      return Math.floor(Math.random() * n);
    }

    function randomGlyphCpForLetter(letter) {
      const l = String(letter ?? "").toLowerCase();
      const arr = LETTER_BUCKETS.get(l);
      if (!arr || arr.length === 0) return null;
      const word = arr[randInt(arr.length)];
      return WORD_TO_UCSUR_CP[word] ?? null;
    }

    function lettersToRandomGlyphCps(letters) {
      const cps = [];
      const s = String(letters ?? "").toLowerCase().replace(/[^a-z]/g, "");
      for (const ch of s) {
        const cp = randomGlyphCpForLetter(ch);
        if (cp != null) cps.push(cp);
      }
      return cps;
    }

    function splitLineIntoSegments(line) {
      const s = String(line ?? "");
      const parts = s.split(/(\[[^\]]*\])/g);
      const out = [];
      for (const p of parts) {
        if (!p) continue;
        if (p.startsWith("[") && p.endsWith("]")) out.push({ kind: "bracket", value: p.slice(1, -1) });
        else out.push({ kind: "text", value: p });
      }
      return out;
    }

    function pushGapIfNeeded(elements, px) {
      if (elements.length === 0) return;
      const last = elements[elements.length - 1];
      if (last && last.type === "gap") return;
      elements.push({ type: "gap", px: px });
    }

    /* CHANGED: allow configurable foreground color */
    function renderFontCartoucheToCanvas(canvas, innerCps, { fontPx, padPx, fontFamily, fgCss }) {
      if (!canvas) throw new Error("renderFontCartoucheToCanvas: canvas missing");
      if (!innerCps || innerCps.length === 0) return { w: 0, h: 0, baselineY: 0 };

      const px = fontPx;
      const pad = padPx;
      const fam = fontFamily || FONT_FAMILY_TEXT;

      const run =
        String.fromCodePoint(CARTOUCHE_START_CP) +
        innerCps.map(cp => String.fromCodePoint(cp)).join("") +
        String.fromCodePoint(CARTOUCHE_END_CP);

      const ctx = canvas.getContext("2d");
      ctx.textBaseline = "alphabetic";
      ctx.font = `${px}px "${fam}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(run);

      const ascent  = (m.actualBoundingBoxAscent  != null) ? m.actualBoundingBoxAscent  : Math.ceil(px * 0.95);
      const descent = (m.actualBoundingBoxDescent != null) ? m.actualBoundingBoxDescent : Math.ceil(px * 0.35);

      const left  = (m.actualBoundingBoxLeft  != null) ? m.actualBoundingBoxLeft  : 0;
      const right = (m.actualBoundingBoxRight != null) ? m.actualBoundingBoxRight : Math.ceil(m.width);

      const w = Math.max(1, Math.ceil(left + right + pad * 2));
      const h = Math.max(1, Math.ceil(ascent + descent + pad * 2));

      canvas.width = w;
      canvas.height = h;

      const ctx2 = canvas.getContext("2d", { alpha: true });
      ctx2.clearRect(0, 0, w, h);
      ctx2.textBaseline = "alphabetic";
      ctx2.font = `${px}px "${fam}"`;
      setTextQuality(ctx2);

      ctx2.fillStyle = fgCss || "#111";

      const x = pad + left;
      const baselineY = pad + ascent;

      ctx2.fillText(run, x, baselineY);

      return { w, h, baselineY };
    }

    function makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily, fgCss }) {
      if (!cps || cps.length === 0) return;
      pushGapIfNeeded(elements, WORD_GAP_PX);

      const cart = document.createElement("canvas");
      const padPx = Math.max(4, Math.round(fontPx * 0.11));

      const r = renderFontCartoucheToCanvas(cart, cps, { fontPx, padPx, fontFamily, fgCss });
      if ((r.w | 0) <= 0 || (r.h | 0) <= 0) return;

      const baselineY = r.baselineY | 0;
      const ascent = baselineY;
      const descent = (r.h | 0) - baselineY;

      elements.push({
        type: "cartouche",
        canvas: cart,
        w: r.w,
        h: r.h,
        baselineY,
        ascent,
        descent,
        fontFamily: fontFamily || FONT_FAMILY_TEXT
      });
    }

    function makeRunElementFromCodepoints(elements, cps, { fontPx, fontFamily }) {
      if (!cps || cps.length === 0) return;
      pushGapIfNeeded(elements, WORD_GAP_PX);

      elements.push({
        type: "run",
        cps: Array.from(cps),
        px: fontPx,
        fontFamily: fontFamily || FONT_FAMILY_TEXT
      });
    }

    function renderTpWordsFromText(text, elements, { fontPx, mode }) {
      const rawTokens = String(text ?? "").trim().split(/\s+/).filter(Boolean);

      function emitPunctGlyph(ch) {
        if (ch !== ":" && ch !== "·") return false;
        const cp = WORD_TO_UCSUR_CP[ch];
        if (cp == null) return false;
        pushGapIfNeeded(elements, WORD_GAP_PX);
        elements.push({ type: "glyph", cp, px: fontPx, fontFamily: FONT_FAMILY_TEXT });
        return true;
      }

      function splitTokenPunct(tok) {
        const s = String(tok ?? "");
        if (!s) return { lead: "", core: "", trail: "" };

        let a = 0;
        let b = s.length;

        while (a < b && !/[#~A-Za-z0-9]/.test(s[a])) a++;
        while (b > a && !/[#~A-Za-z0-9]/.test(s[b - 1])) b--;

        return { lead: s.slice(0, a), core: s.slice(a, b), trail: s.slice(b) };
      }

      for (let i = 0; i < rawTokens.length; i++) {
        const tok = rawTokens[i];
        const normTok = normalizeTpWord(tok);

        if (normTok === "pi") {
          const nextTok = rawTokens[i + 1];
          if (nextTok != null && tokenHasOpenCurly(nextTok)) {
            const extracted = extractCurlyContentFromTokens(rawTokens, i + 1);

            if (extracted && extracted.inner != null) {
              const innerWords = parseKnownTpWords(extracted.inner);

              if (innerWords.length >= 2) {
                const cps = [];
                cps.push(LONG_PI_START_CP);
                cps.push(WORD_TO_UCSUR_CP[innerWords[0]]);

                for (let k = 1; k < innerWords.length; k++) {
                  cps.push(LONG_PI_EXT_CP);
                  cps.push(WORD_TO_UCSUR_CP[innerWords[k]]);
                }

                makeRunElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_TEXT });
                i = extracted.endIndex;
                continue;
              }
            }
          }
        }

        const { lead, core, trail } = splitTokenPunct(tok);
        for (const ch of lead) emitPunctGlyph(ch);

        const trimmed = core;

        if (trimmed) {
          const idCps =
            tryDecodeNanpaLinjanIdentifierToCodepoints(trimmed, { mode }) ??
            tryDecodeNanpaLinjanIdentifierToCodepoints(trimmed.replace(/\s+/g, ""), { mode });

          if (idCps && idCps.length) {
            // cartouche color is handled where cartouches are created (parseTextSegmentToElements)
            makeCartoucheElementFromCodepoints(elements, idCps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE });
            for (const ch of trail) emitPunctGlyph(ch);
            continue;
          }
        }

        const norm = normalizeTpWord(trimmed);
        if (norm && isKnownTpWord(norm)) {
          pushGapIfNeeded(elements, WORD_GAP_PX);
          elements.push({ type: "glyph", cp: WORD_TO_UCSUR_CP[norm], px: fontPx, fontFamily: FONT_FAMILY_TEXT });
        }

        for (const ch of trail) emitPunctGlyph(ch);
      }
    }

    function parseTextSegmentToElements(segmentText, elements, { fontPx }) {
      const mode = getNanpaLinjanMode();
      const s = String(segmentText ?? "");
      if (!s.trim()) return;

      const decHits = findDecimalSequencesWithCaps(s);
      const codeHits = findNumberCodeSequencesWithCaps(s);
      const nameHits = findNanpaLinjanProperNameSequencesWithCaps(s);
      const phraseHits = findNanpaLinjanTpPhraseSequences(s);

      const hits = mergeAndGreedyFilterHits([...decHits, ...phraseHits, ...codeHits, ...nameHits]);

      if (!hits || hits.length === 0) {
        renderTpWordsFromText(s, elements, { fontPx, mode });
        return;
      }

      let pos = 0;

      for (const h of hits) {
        const a = Math.max(0, h.index | 0);
        const b = Math.max(a, h.end | 0);

        if (a > pos) {
          renderTpWordsFromText(s.slice(pos, a), elements, { fontPx, mode });
        }

        const fgCss = getFgRgb().css;

        if (h.kind === "tpPhrase") {
          const cps = nanpaLinjanWordsToCodepoints(h.words, { mode });
          if (cps && cps.length) {
            makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
          } else {
            renderTpWordsFromText(s.slice(a, b), elements, { fontPx, mode });
          }
        } else {
          const cps = nanpaCapsToNanpaLinjanCodepoints(h.caps, { mode });
          if (cps && cps.length) {
            makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
          } else {
            renderTpWordsFromText(s.slice(a, b), elements, { fontPx, mode });
          }
        }

        pos = b;
      }

      if (pos < s.length) {
        renderTpWordsFromText(s.slice(pos), elements, { fontPx, mode });
      }
    }

    function parseBracketSegmentToElements(bracketContent, elements, { fontPx }) {
      const content = String(bracketContent ?? "").trim();
      if (!content) return;

      const mode = getNanpaLinjanMode();
      const fgCss = getFgRgb().css;

      try {
        const caps = decimalStringToCaps(content, { thousandsChar: ",", groupFractionTriplets: true, fractionGroupSize: 3 });
        const cps = nanpaCapsToNanpaLinjanCodepoints(caps, { mode });
        if (cps && cps.length) {
          makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
          return;
        }
      } catch {}

      const wordsRaw = content.split(/\s+/).filter(Boolean);
      const words = wordsRaw.map(normalizeTpWord).filter(Boolean);

      const parsedNumber = tryParseNanpaLinjanTpPhraseWords(words);
      if (parsedNumber) {
        const cps = nanpaLinjanWordsToCodepoints(parsedNumber.words, { mode });
        if (cps) makeCartoucheElementFromCodepoints(elements, cps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
        return;
      }

      const idCps =
        tryDecodeNanpaLinjanIdentifierToCodepoints(content, { mode }) ??
        tryDecodeNanpaLinjanIdentifierToCodepoints(content.replace(/\s+/g, ""), { mode });

      if (idCps && idCps.length) {
        makeCartoucheElementFromCodepoints(elements, idCps, { fontPx, fontFamily: FONT_FAMILY_CARTOUCHE, fgCss });
        return;
      }

      const glyphTokens = wordsRaw.map(normalizeTpGlyphToken).filter(Boolean);
      if (glyphTokens.length >= 1 && glyphTokens.every(isKnownTpGlyphToken)) {
        makeCartoucheElementFromCodepoints(elements, tpWordsToCodepoints(glyphTokens), { fontPx, fontFamily: FONT_FAMILY_TEXT, fgCss });
        return;
      }

      makeCartoucheElementFromCodepoints(elements, lettersToRandomGlyphCps(content), { fontPx, fontFamily: FONT_FAMILY_TEXT, fgCss });
    }

    function lineToElements(line, { fontPx }) {
      let s = String(line ?? "");
      s = s.replace(/\.\s*$/, "");

      const segs = splitLineIntoSegments(s);
      const elements = [];

      for (const seg of segs) {
        if (seg.kind === "text") parseTextSegmentToElements(seg.value, elements, { fontPx });
        else parseBracketSegmentToElements(seg.value, elements, { fontPx });
      }

      while (elements.length > 0 && elements[elements.length - 1].type === "gap") elements.pop();
      return elements;
    }

    function measureGlyph(ctx, cp, px, fontFamily) {
      const ch = String.fromCodePoint(cp);
      ctx.font = `${px}px "${fontFamily}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(ch);

      const ascent  = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

      const left = m.actualBoundingBoxLeft ?? 0;
      const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
      const tightW = Math.ceil(left + right);

      return { ch, ascent, descent, left, w: tightW, h: Math.ceil(ascent + descent), px, fontFamily };
    }

    function measureRun(ctx, cps, px, fontFamily) {
      const chars = (cps ?? []).map(cp => String.fromCodePoint(cp)).join("");
      ctx.font = `${px}px "${fontFamily}"`;
      setTextQuality(ctx);
      const m = ctx.measureText(chars);

      const ascent  = m.actualBoundingBoxAscent ?? Math.ceil(px * 0.8);
      const descent = m.actualBoundingBoxDescent ?? Math.ceil(px * 0.2);

      const left = m.actualBoundingBoxLeft ?? 0;
      const right = m.actualBoundingBoxRight ?? Math.ceil(m.width);
      const tightW = Math.ceil(left + right);

      return { chars, ascent, descent, left, w: tightW, h: Math.ceil(ascent + descent), px, fontFamily };
    }

    function renderAllLinesToCanvas(outCanvas, linesElements, { fontPx }) {
      const pad = 18;

      const tmp = document.createElement("canvas");
      const ctx = tmp.getContext("2d");
      ctx.textBaseline = "alphabetic";

      const measuredLines = [];
      let maxLineW = 0;
      let totalH = 0;

      for (const lineEls of linesElements) {
        let w = 0;
        let maxAscent = 0;
        let maxDescent = 0;

        const measuredEls = [];

        for (const el of lineEls) {
          if (el.type === "gap") {
            measuredEls.push(el);
            w += Math.max(0, el.px | 0);
            continue;
          }

          if (el.type === "glyph") {
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            const g = measureGlyph(ctx, el.cp, el.px ?? fontPx, fam);
            measuredEls.push({ ...el, m: g });
            w += g.w;

            if (g.ascent > maxAscent) maxAscent = g.ascent;
            if (g.descent > maxDescent) maxDescent = g.descent;
            continue;
          }

          if (el.type === "run") {
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            const r = measureRun(ctx, el.cps, el.px ?? fontPx, fam);
            measuredEls.push({ ...el, m: r });
            w += r.w;

            if (r.ascent > maxAscent) maxAscent = r.ascent;
            if (r.descent > maxDescent) maxDescent = r.descent;
            continue;
          }

          if (el.type === "cartouche") {
            measuredEls.push(el);
            w += (el.w | 0);

            const a = el.ascent ?? Math.ceil((el.h | 0) * 0.7);
            const d = el.descent ?? Math.ceil((el.h | 0) * 0.3);

            if (a > maxAscent) maxAscent = a;
            if (d > maxDescent) maxDescent = d;
            continue;
          }
        }

        const lineBoxH = Math.max(maxAscent + maxDescent, fontPx);
        measuredLines.push({ measuredEls, w, lineBoxH, maxAscent, maxDescent });

        if (w > maxLineW) maxLineW = w;
        totalH += lineBoxH;
      }

      totalH += Math.max(0, (measuredLines.length - 1) * LINE_GAP_PX);

      const outW = Math.max(1, Math.ceil(maxLineW + pad * 2));
      const outH = Math.max(1, Math.ceil(totalH + pad * 2));

      outCanvas.width = outW;
      outCanvas.height = outH;

      const outCtx = outCanvas.getContext("2d", { alpha: true });
      outCtx.clearRect(0, 0, outW, outH);
      outCtx.textBaseline = "alphabetic";
      outCtx.fillStyle = getFgRgb().css;  // CHANGED: use selected foreground color
      setTextQuality(outCtx);

      let y = pad;

      for (let li = 0; li < measuredLines.length; li++) {
        const L = measuredLines[li];
        let x = pad;

        const glyphBaseline = y + L.maxAscent;

        for (const el of L.measuredEls) {
          if (el.type === "gap") { x += Math.max(0, el.px | 0); continue; }

          if (el.type === "glyph") {
            const m = el.m;
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
            const drawX = x + (m.left ?? 0);
            outCtx.fillText(m.ch, drawX, glyphBaseline);
            x += m.w;
            continue;
          }

          if (el.type === "run") {
            const m = el.m;
            const fam = el.fontFamily || FONT_FAMILY_TEXT;
            outCtx.font = `${(el.px ?? fontPx)}px "${fam}"`;
            const drawX = x + (m.left ?? 0);
            outCtx.fillText(m.chars, drawX, glyphBaseline);
            x += m.w;
            continue;
          }

          if (el.type === "cartouche") {
            const by = (el.baselineY != null) ? (el.baselineY | 0) : Math.floor((el.h | 0) * 0.75);
            const drawY = glyphBaseline - by;
            outCtx.drawImage(el.canvas, x, drawY);
            x += el.w;
            continue;
          }
        }

        y += L.lineBoxH;
        if (li < measuredLines.length - 1) y += LINE_GAP_PX;
      }
    }

    function safeFilenamePart(s) {
      const t = String(s ?? "").trim();
      if (!t) return "sitelen";
      return t.replace(/[^a-zA-Z0-9._-]+/g, "_").slice(0, 80) || "sitelen";
    }

    function downloadCanvasAsTransparentPng(canvas, { filenameBase = "sitelen", scale = 1 } = {}) {
      if (!canvas) throw new Error("Canvas not found.");

      const w = canvas.width | 0;
      const h = canvas.height | 0;
      if (w <= 0 || h <= 0) throw new Error("Canvas is empty (nothing to download yet).");

      const out = document.createElement("canvas");
      out.width = Math.max(1, Math.floor(w * scale));
      out.height = Math.max(1, Math.floor(h * scale));

      const ctx = out.getContext("2d", { alpha: true });
      ctx.clearRect(0, 0, out.width, out.height);
      ctx.imageSmoothingEnabled = true;
      ctx.drawImage(canvas, 0, 0, out.width, out.height);

      const filename = safeFilenamePart(filenameBase) + ".png";

      if (out.toBlob) {
        out.toBlob((blob) => {
          if (!blob) throw new Error("PNG export failed (no blob).");
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();

          setTimeout(() => URL.revokeObjectURL(url), 1000);
        }, "image/png");
        return;
      }

      const dataUrl = out.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = dataUrl;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    const elTextIn = document.getElementById("textIn");
    const outCanvas = document.getElementById("outCanvas");
    const btnRender = document.getElementById("btnRender");
    const btnDownload = document.getElementById("btnDownloadPng");

    async function renderFromTextarea() {
      await ensureFontLoaded();

      const fontPx = getFontPx();

      const raw = String(elTextIn.value ?? "");
      const lines = raw.replace(/\r\n/g, "\n").split("\n");
      const linesElements = lines.map(line => lineToElements(line, { fontPx }));

      const anyContent = linesElements.some(els =>
        els.some(e => e.type === "glyph" || e.type === "cartouche" || e.type === "run")
      );
      if (!anyContent) {
        outCanvas.width = 1;
        outCanvas.height = 1;
        const ctx = outCanvas.getContext("2d");
        ctx.clearRect(0, 0, 1, 1);
        announceStatus("Nothing to render (no recognized words).");
        return;
      }

      renderAllLinesToCanvas(outCanvas, linesElements, { fontPx });
      const { hex } = getFgRgb();
      announceStatus(`Rendered sitelen pona. Mode: ${getNanpaLinjanMode()}. Font: ${fontPx}px. Color: ${hex}.`);
    }

    btnRender.addEventListener("click", async () => {
      try { await renderFromTextarea(); }
      catch (e) { showAlertAndAnnounce(e?.message ?? String(e)); }
    });

    btnDownload.addEventListener("click", () => {
      try {
        downloadCanvasAsTransparentPng(outCanvas, { filenameBase: "sitelen", scale: 1 });
        announceStatus("Downloaded PNG.");
      } catch (e) {
        showAlertAndAnnounce(e?.message ?? String(e));
      }
    });

    function setQueryParamOnLink(a, key, value) {
      if (!a) return;
      try {
        const u = new URL(a.getAttribute("href"), window.location.href);
        u.searchParams.set(key, value);
        a.setAttribute("href", u.pathname + "?" + u.searchParams.toString() + u.hash);
      } catch (e) {
        console.warn("[link] failed to set query param:", e);
      }
    }

    function updateExternalLinksWithCartoucheDisplay() {
      const mode = getNanpaLinjanMode();

      const calc = document.getElementById("calculatorLink");
      const rend = document.getElementById("rendererLink");

      setQueryParamOnLink(calc, "cartoucheDisplay", mode);
      setQueryParamOnLink(rend, "cartoucheDisplay", mode);
    }

    function wireCartoucheDisplayLinks() {
      updateExternalLinksWithCartoucheDisplay();

      const radios = document.querySelectorAll('input[name="nlMode"]');
      radios.forEach(r => {
        r.addEventListener("change", () => {
          updateExternalLinksWithCartoucheDisplay();
        });
      });

      const linkIds = ["calculatorLink", "rendererLink"];
      for (const id of linkIds) {
        const a = document.getElementById(id);
        if (!a) continue;
        a.addEventListener("click", () => {
          updateExternalLinksWithCartoucheDisplay();
        });
      }
    }

    window.addEventListener("load", async () => {
      try {
        await ensureFontLoaded();

        applyNanpaLinjanModeFromQueryOrStorage();
        applyFontPxFromQueryOrStorage();
        applyDefaultInputFromQuery();

        // NEW: init + wire foreground color controls
        initFgColorControls();
        wireFgColorControls();

        wireNanpaLinjanModeRadios();
        wireFontSizeSelect();
        wireCartoucheDisplayLinks();

        // Ensure preview is correct even if no change event fires
        updateFgColorPreview();
      } catch (e) {
        console.warn(e);
      }
    });
  </script>
</body>
</html>
